<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8 />
<title>Ultimate Music Toy</title>
<link rel="stylesheet" href="jquery-ui.css" />
<script src="jquery-1.10.2.js"></script>
<script src="jquery-ui.js"></script>
<link rel="stylesheet" href="style.css" />

<script src="mt19937class.js" ></script>
<script>

// (C) 2011-2014 Wayne Radinsky

/*jslint browser: true, devel: true, passfail: true */
/*global MersenneTwister19937 */
/*global jQuery */

var gUmt;

// notes about terminology:
// lpnum -- loop number
// vcnum -- voice number
// "cursor" -- various cursors point to the end of an array + 1
//             (point where new notes will be added)
// instParams -- instrument parameters -- not used yet but will hold
//                instrument-specific parameters
// fpt -- "floating-point" -- floating point value of pitches for scale notes
//        (notes are expressed as both a ratio, num/dnom, and a floating-point
//        value where 2^fpt is proportional to the pitch
//        pitch values in gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].pitch
//        are RAW pitches and in floating-point format.

//    umtJSabort, umtCx, and umtCtstr are debugging functions that will be
//    REMOVED from the final product (assuming there is ever any such thing as a
//    final product :P )
// 
//    Anything that starts with umt_test is test code and will be removed
//    (or at least shoved aside into some other file).
// 
//    Actual music code starts with the function umtGetAudioContext


function umtJSabort(msg) {
    "use strict";
    window.alert(msg);
    throw new Error('Aborting javascript: ' + msg);
}

function umtCx(stringparameter) {
    "use strict";
    // this function exists just so I don't have to type 'console.log' over and
    // over (was originally just 'cx', the 'umt_' prefix made it longer, d'oh!),
    // plus prevents output from changing!
    console.log(stringparameter);
}

function umtCtstr(anyparameter) {
    "use strict";
    // a supposedly simple function to make a string from a var for debug
    //dumps, that has gotten way complicated over time...
    var x, rv, z, name, isArr;
    if (typeof anyparameter === 'object') {
        if (anyparameter === null) {
            return 'null';
        }
        name = '';
        isArr = false;
        if (anyparameter.constructor !== undefined) {
            name = anyparameter.constructor.toString();
        }
        if (name === 'function Object() { [native code] }') {
            name = '';
        }
        if (name === 'function Array() { [native code] }') {
            name = '';
            isArr = true;
        }
        if (name === 'function AudioContext() { [native code] }') {
            return 'object AudioContext';
        }
        if (name === '') {
            rv = '';
            for (z in anyparameter) {
                if (anyparameter.hasOwnProperty(z)) {
                    rv = rv + ', ' + z + ': ' + umtCtstr(anyparameter[z]);
                }
            }
            if (isArr) {
                return 'array [ ' + rv.substring(2) + ' ]';
            }
            return 'object { ' + rv.substring(2) + ' }';
        }
        return '{[Code Object]}';
    }
    if (typeof anyparameter === 'number') {
        return 'number ' + anyparameter.toString();
    }
    if (typeof anyparameter === 'string') {
        return 'string "' + anyparameter + '"';
    }
    if (typeof anyparameter === 'boolean') {
        return 'boolean ' + anyparameter.toString();
    }
    x = typeof anyparameter;
    window.alert(x);
    console.log('x', x);
    umtJSabort('typeof returned an undefined value');
}

// Actual music code starts here

function umtGetAudioContext() {
    "use strict";
    if (!window.AudioContext) {
        if (!window.webkitAudioContext) {
            window.alert("Your browser does not support the WebAudio API (HTML5).\nPlease use a compatible browser e.g. Google Chrome. If your WebAudio is disabled in Chrome, enable it in page about:flags");
            return;
        }
        window.AudioContext = window.webkitAudioContext;
    }
    var ctx = new window.AudioContext();
    return ctx;
}

function umtGetRando(seedNum) {
    "use strict";
    var mt1, initAry, x;
    mt1 = new MersenneTwister19937();
    initAry = [0x123, 0x234, 0x345, 0x456];
    mt1.initByArray(initAry, 4);
    for (x = 0; x < (seedNum * 32); x = x + 1) {
        mt1.genrandInt32();
    }
    return mt1;
}

function umtTestCheckForFloat(anyparameter) {
    "use strict";
    var hello;
    hello = typeof anyparameter;
    if (hello === "number") {
        return;
    }
    umtJSabort(hello);
}

function umtGenerateANoteSineWave(frequency, duration, amplitude) {
    "use strict";
    // consult https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
    var numSamples, theBuffer, bufData, i, fade, masterRescaler;
    masterRescaler = 0.9;
    numSamples = duration * gUmt.SAMPLERATE;
    theBuffer = gUmt.globalCtx.createBuffer(1, numSamples, gUmt.SAMPLERATE); // numberOfChannels, length, sampleRate
    bufData = theBuffer.getChannelData(0);
    for (i = 0; i < numSamples; i = i + 1) {
        fade = 1.0 - (i / numSamples);
        bufData[i] = Math.sin((gUmt.TAU * i * (frequency / gUmt.SAMPLERATE))) * (amplitude * fade * masterRescaler);
    }
    return theBuffer;
}

function umtGenerateANoteSquareWave(frequency, duration, amplitude) {
    "use strict";
    // consult https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
    var numSamples, theBuffer, bufData, i, fade, masterRescaler, sinePart, squarePart;
    masterRescaler = 0.9;
    numSamples = duration * gUmt.SAMPLERATE;
    theBuffer = gUmt.globalCtx.createBuffer(1, numSamples, gUmt.SAMPLERATE); // numberOfChannels, length, sampleRate
    bufData = theBuffer.getChannelData(0);
    for (i = 0; i < numSamples; i = i + 1) {
        fade = 1.0 - (i / numSamples);
        sinePart = Math.sin((gUmt.TAU * i * (frequency / gUmt.SAMPLERATE)));
        if (sinePart > 0) {
            squarePart =  1.0;
        } else {
            squarePart =  -1.0;
        }
        bufData[i] = squarePart * (amplitude * fade * masterRescaler);
    }
    return theBuffer;
}

function umtGenerateANoteSquareVar(frequency, duration, amplitude, threshold) {
    "use strict";
    // consult https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
    var numSamples, theBuffer, bufData, i, fade, masterRescaler, sinePart, squarePart;
    masterRescaler = 0.9;
    numSamples = duration * gUmt.SAMPLERATE;
    theBuffer = gUmt.globalCtx.createBuffer(1, numSamples, gUmt.SAMPLERATE); // numberOfChannels, length, sampleRate
    bufData = theBuffer.getChannelData(0);
    for (i = 0; i < numSamples; i = i + 1) {
        fade = 1.0 - (i / numSamples);
        sinePart = Math.sin((gUmt.TAU * i * (frequency / gUmt.SAMPLERATE)));
        if (sinePart > threshold) {
            squarePart =  1.0;
        } else {
            squarePart =  -1.0;
        }
        bufData[i] = squarePart * (amplitude * fade * masterRescaler);
    }
    return theBuffer;
}

function umtGenerateANoteNoise(frequency, duration, amplitude) {
    "use strict";
    // consult https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
    var numSamples, theBuffer, bufData, rng, i, fade, masterRescaler, noiseSample;
    noiseSample = frequency; // delete me -- just to pass camelCaseJSLint
    masterRescaler = 0.9;
    numSamples = duration * gUmt.SAMPLERATE;
    theBuffer = gUmt.globalCtx.createBuffer(1, numSamples, gUmt.SAMPLERATE); // numberOfChannels, length, sampleRate
    bufData = theBuffer.getChannelData(0);
    rng = umtGetRando(0);
    for (i = 0; i < numSamples; i = i + 1) {
        fade = 1.0 - (i / numSamples);
        noiseSample = (rng.genrandReal3() * 2.0) - 1.0;
        bufData[i] = noiseSample * (amplitude * fade * masterRescaler);
    }
    return theBuffer;
}

// Converted this to a test function rather than removing it -- want to keep a built in function (not part of any instrument) for making sounds but it should only be used for testing
function umtTestQueUpANoteSineWave(fromMoment, frequency, startTime, duration, amplitude, instSpecificParams) {
    "use strict";
    var idxname, theBuffer, node, ourStart, startMoment;
    idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
    idxname = "sinewave" + frequency + "x" + duration + "x" + amplitude;
    if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
        theBuffer = gUmt.cachedNotes[idxname];
    } else {
        theBuffer = umtGenerateANoteSineWave(frequency, duration, amplitude);
        gUmt.cachedNotes[idxname] = theBuffer;
    }
    node = gUmt.globalCtx.createBufferSource();
    node.buffer = theBuffer;
    node.connect(gUmt.globalCtx.destination);
    ourStart = Number(startTime);
    startMoment = fromMoment + ourStart;
    node.start(startMoment);
}

function InstantiateTuningForkObj() {
    "use strict";
    this.queUpANote = function (fromMoment, frequency, startTime, duration, amplitude, instSpecificParams) {
        var idxname, theBuffer, node, ourStart, startMoment;
        idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
        idxname = "sinewave" + frequency + "x" + duration + "x" + amplitude;
        if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
            theBuffer = gUmt.cachedNotes[idxname];
        } else {
            theBuffer = umtGenerateANoteSineWave(frequency, duration, amplitude);
            gUmt.cachedNotes[idxname] = theBuffer;
        }
        node = gUmt.globalCtx.createBufferSource();
        node.buffer = theBuffer;
        node.connect(gUmt.globalCtx.destination);
        ourStart = Number(startTime);
        startMoment = fromMoment + ourStart;
        node.start(startMoment);
    };
}

function InstantiateSquareWaveObj() {
    "use strict";
    this.queUpANote = function (fromMoment, frequency, startTime, duration, amplitude, instSpecificParams) {
        var idxname, theBuffer, node, ourStart, startMoment;
        idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
        idxname = "squarewave" + frequency + "x" + duration + "x" + amplitude;
        if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
            theBuffer = gUmt.cachedNotes[idxname];
        } else {
            theBuffer = umtGenerateANoteSquareWave(frequency, duration, amplitude);
            gUmt.cachedNotes[idxname] = theBuffer;
        }
        node = gUmt.globalCtx.createBufferSource();
        node.buffer = theBuffer;
        node.connect(gUmt.globalCtx.destination);
        ourStart = Number(startTime);
        startMoment = fromMoment + ourStart;
        node.start(startMoment);
    };
}

function InstantiateSquareVarObj() {
    "use strict";
    this.queUpANote = function (fromMoment, frequency, startTime, duration, amplitude, instSpecificParams) {
        var idxname, theBuffer, node, ourStart, startMoment, threshold;
        idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
        idxname = "squarevar" + frequency + "x" + duration + "x" + amplitude;
        if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
            theBuffer = gUmt.cachedNotes[idxname];
        } else {
            threshold = 0.9;
            theBuffer = umtGenerateANoteSquareVar(frequency, duration, amplitude, threshold);
            gUmt.cachedNotes[idxname] = theBuffer;
        }
        node = gUmt.globalCtx.createBufferSource();
        node.buffer = theBuffer;
        node.connect(gUmt.globalCtx.destination);
        ourStart = Number(startTime);
        startMoment = fromMoment + ourStart;
        node.start(startMoment);
    };
}

function InstantiateNoiseObj() {
    "use strict";
    this.queUpANote = function (fromMoment, frequency, startTime, duration, amplitude, instSpecificParams) {
        var idxname, theBuffer, node, ourStart, startMoment;
        idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
        idxname = "noise" + frequency + "x" + duration + "x" + amplitude;
        if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
            theBuffer = gUmt.cachedNotes[idxname];
        } else {
            theBuffer = umtGenerateANoteNoise(frequency, duration, amplitude);
            gUmt.cachedNotes[idxname] = theBuffer;
        }
        node = gUmt.globalCtx.createBufferSource();
        node.buffer = theBuffer;
        node.connect(gUmt.globalCtx.destination);
        ourStart = Number(startTime);
        startMoment = fromMoment + ourStart;
        node.start(startMoment);
    };
}

function umtCreateInstrumentBank() {
    "use strict";
    gUmt.instrumentBank = {
        tuningfork: new InstantiateTuningForkObj(),
        squarewave: new InstantiateSquareWaveObj(),
        squarevar: new InstantiateSquareVarObj(),
        noise: new InstantiateNoiseObj()
    };
}

function umtClearLoop(lpnum, xTempo, centerNote, xScale) {
    "use strict";
    gUmt.loop[lpnum] = { score: {tempo: xTempo, centernoteLog: (Math.log(centerNote) / gUmt.LOG2) - 5, scale: xScale, playbackTimeOffset: 0, songTab: [ { voice: [] } ] } };
}

function umtAddVoice(lpnum, idx, songNumber, rangeMin, rangeMax, instrumentName) {
    "use strict";
    gUmt.loop[lpnum].score.parts = idx + 1;
    gUmt.loop[lpnum].score.songTab[0].voice[idx] = { instrument: instrumentName, selection: 0, cursor: 0, nextStart: 0, rangeTop: rangeMax, rangeBottom: rangeMin, notes: [], randRhythm: umtGetRando(songNumber * 40), randPitch: umtGetRando(songNumber * 40 + 1), randAmp: umtGetRando(songNumber * 40 + 5), randRests: umtGetRando(songNumber * 40 + 2), randSyms: umtGetRando(songNumber * 40 + 3), randTrans: umtGetRando(songNumber * 40 + 4), randScale: umtGetRando(songNumber * 40 + 5), randTilt: umtGetRando(songNumber * 40 + 6), randScrollrhythm: umtGetRando(songNumber * 40 + 7), randScrollpitch: umtGetRando(songNumber * 40 + 8), randScrollboth: umtGetRando(songNumber * 40 + 9) };
}

function umtAddNote(lpnum, voicenum, rest, pitch, duration, amplitude, instParams) {
    "use strict";
    var idx, cursorval;
    idx = voicenum;
    cursorval = gUmt.loop[lpnum].score.songTab[0].voice[idx].cursor;
    gUmt.loop[lpnum].score.songTab[0].voice[idx].notes[cursorval] = { starttime: gUmt.loop[lpnum].score.songTab[0].voice[idx].nextStart, rest: rest, pitch: pitch, duration: duration, amplitude: amplitude, instParams: instParams, harmOctave: -1, harmNum: -1, harmDnom: -1 };
    cursorval = cursorval + 1;
    gUmt.loop[lpnum].score.songTab[0].voice[idx].cursor = cursorval;
    gUmt.loop[lpnum].score.songTab[0].voice[idx].nextStart += duration;
}

function umtTestPlayRawScore(lpnum) {
    "use strict";
    var fromMoment, center, tempoScalar, numVoices, voicenum, notenum, pitch, duration, amplitude, frequency, startTime, instSpecificParams;
    fromMoment = gUmt.globalCtx.currentTime + 1;
    center = gUmt.loop[lpnum].score.centernoteLog;
    tempoScalar = 60 / gUmt.loop[lpnum].score.tempo;
    numVoices = gUmt.loop[lpnum].score.parts;
    for (voicenum = 0; voicenum < numVoices; voicenum = voicenum + 1) {
        for (notenum = 0; notenum < gUmt.loop[lpnum].score.songTab[0].voice[voicenum].cursor; notenum = notenum + 1) {
            if (gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].rest === false) {
                pitch = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].pitch;
                duration = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].duration * tempoScalar;
                amplitude = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].amplitude;
                amplitude = amplitude / numVoices;
                instSpecificParams = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].instParams;
                frequency = Math.exp((pitch + center) * gUmt.LOG2);
                startTime = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].starttime * tempoScalar;
                umtTestQueUpANoteSineWave(fromMoment, frequency, startTime, duration, amplitude, instSpecificParams);
            }
        }
    }
}

function umtExecPlayRawScore() {
    "use strict";
    umtTestPlayRawScore(gUmt.currentlyPlayingLoop);
}

// cheat sheet for scales
// ratio  interval  example key of C  logarithm  nearest equal temperment (logarithm)
// 1/1    P1        C                 0.000      0.000
// 16/15  m2        C#                0.093      0.083
// 10/9   M2-alt    D-alt             0.152      0.166
// 9/8    M2-reg    D-reg             0.170      0.166
// 6/5    m3        Eb                0.263      0.250
// 5/4    M3        E                 0.322      0.333
// 4/3    P4        F                 0.415      0.417
// 3/2    P5        G                 0.585      0.583
// 8/5    m6        Ab                0.678      0.667
// 5/3    M6        A                 0.737      0.750
// 16/9   m7-alt    Bb-alt            0.830      0.833
// 9/5    m7-reg    Bb-reg            0.848      0.833
// 15/8   M7        B                 0.907      0.917
// 2/1    P8        C                 1.000      1.000

function umtGetScale13Chromatic() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 16, dnom: 15}, {num: 10, dnom: 9}, {num: 9, dnom: 8}, {num: 6, dnom: 5}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 5, dnom: 3}, {num: 16, dnom: 9}, {num: 9, dnom: 5}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale11ChromaticRegReg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 16, dnom: 15}, {num: 9, dnom: 8}, {num: 6, dnom: 5}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 5, dnom: 3}, {num: 9, dnom: 5}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale11ChromaticAltReg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 16, dnom: 15}, {num: 10, dnom: 9}, {num: 6, dnom: 5}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 5, dnom: 3}, {num: 16, dnom: 9}, {num: 9, dnom: 5}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale11ChromaticRegAlt() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 16, dnom: 15}, {num: 9, dnom: 8}, {num: 6, dnom: 5}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 5, dnom: 3}, {num: 16, dnom: 9}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale11ChromaticAltAlt() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 16, dnom: 15}, {num: 10, dnom: 9}, {num: 6, dnom: 5}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 5, dnom: 3}, {num: 16, dnom: 9}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale7MajorReg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 5, dnom: 3}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale7MajorAlt() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 10, dnom: 9}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 5, dnom: 3}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale7MinorNaturalRegReg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 9, dnom: 5} ];
    return scale;
}

function umtGetScale7MinorNaturalAltReg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 10, dnom: 9}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 9, dnom: 5} ];
    return scale;
}

function umtGetScale7MinorNaturalRegAlt() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 16, dnom: 9} ];
    return scale;
}

function umtGetScale7MinorNaturalAltAlt() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 10, dnom: 9}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 16, dnom: 9} ];
    return scale;
}

function umtGetScale7MinorHarmonicReg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale7MinorHarmonicAlt() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 10, dnom: 9}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale7MinorMelodicReg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 5, dnom: 3}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale7MinorMelodicAlt() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 10, dnom: 9}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 5, dnom: 3}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale7ArabicishMajor() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 16, dnom: 15}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 5, dnom: 3}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale7ArabicishMinor() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 16, dnom: 15}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale5Pentatonic23Reg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 5, dnom: 3} ];
    return scale;
}

function umtGetScale5Pentatonic23Alt() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 10, dnom: 9}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 5, dnom: 3} ];
    return scale;
}

function umtGetScale5Pentatonic32Reg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 5, dnom: 4}, {num: 3, dnom: 2}, {num: 5, dnom: 3} ];
    return scale;
}

function umtGetScale5Pentatonic32Alt() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 10, dnom: 9}, {num: 5, dnom: 4}, {num: 3, dnom: 2}, {num: 5, dnom: 3} ];
    return scale;
}

function umtGetScale4Quadtonic() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 5, dnom: 3} ];
    return scale;
}

function umtGetScale3Tritonic() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 4, dnom: 3}, {num: 3, dnom: 2} ];
    return scale;
}

function umtAddFloatsToScale(originalScale) {
    "use strict";
    var num, dnom, x, newScale, i;
    newScale = [];
    for (i = 0; i < originalScale.length; i = i + 1) {
        num = originalScale[i].num;
        dnom = originalScale[i].dnom;
        x = num / dnom;
        x = Math.log(x) / gUmt.LOG2;
        newScale[i] = {num: num, dnom: dnom, fpt: x};
    }
    return newScale;
}

function umtGaussGCD(a, b) {
    "use strict";
    // Gauss's GCD algorithm
    var c, d, e, r;
    c = a;
    d = b;
    r = 1;
    while (r !== 0) {
        if (d > c) {
            e = c;
            c = d;
            d = e;
        }
        r = (c % d);
        if (r !== 0) {
            c = d;
            d = r;
        }
    }
    return d;
}

// we are using Euclid's GCD algorithm because it should be faster for small numbers. Gauss's should be faster for large numbers
function umtEuclidGCD(a, b) {
    "use strict";
    // Euclid's GCD algorithm
    while (a !== b) {
        if (a > b) {
            a = a - b;
        } else {
            b = b - a;
        }
    }
    return a;
}

function umtReduceFraction(num, dnom) {
    "use strict";
    var g, rv;
    g = umtEuclidGCD(num, dnom);
    if (g !== 1) {
        num = num / g;
        dnom = dnom / g;
    }
    rv = {num: num, dnom: dnom};
    return rv;
}

function umtIsConsonant(lowNum, lowDnom, highNum, highDnom) {
    "use strict";
    var ratioNum, ratioDnom, red;
    ratioNum = highNum * lowDnom;
    ratioDnom = highDnom * lowNum;
    red = umtReduceFraction(ratioNum, ratioDnom);
    if (red.dnom > 6) {
        return false;
    }
    ratioNum = 2 * lowNum * highDnom;
    ratioDnom = lowDnom * highNum;
    red = umtReduceFraction(ratioNum, ratioDnom);
    if (red.dnom > 6) {
        return false;
    }
    return true;
}

function umtTestIsConsonant() {
    "use strict";
    var what;
    what = umtIsConsonant(6, 5, 7, 5);
    if (what !== false) {
        umtJSabort('dissonance test 1 failed');
    }
    what = umtIsConsonant(6, 5, 8, 5);
    if (what !== true) {
        umtJSabort('dissonance test 2 failed');
    }
    what = umtIsConsonant(6, 5, 9, 5);
    if (what !== true) {
        umtJSabort('dissonance test 3 failed');
    }
    what = umtIsConsonant(6, 5, 5, 4);
    if (what !== false) {
        umtJSabort('dissonance test 4 failed');
    }
    what = umtIsConsonant(6, 5, 7, 4);
    if (what !== false) {
        umtJSabort('dissonance test 5 failed');
    }
    what = umtIsConsonant(6, 5, 4, 3);
    if (what !== false) {
        umtJSabort('dissonance test 6 failed');
    }
    what = umtIsConsonant(6, 5, 5, 3);
    if (what !== false) {
        umtJSabort('dissonance test 7 failed');
    }
    what = umtIsConsonant(6, 5, 3, 2);
    if (what !== true) {
        umtJSabort('dissonance test 8 failed');
    }
    what = umtIsConsonant(5, 4, 4, 3);
    if (what !== false) {
        umtJSabort('dissonance test 9 failed');
    }
    what = umtIsConsonant(5, 4, 5, 3);
    if (what !== true) {
        umtJSabort('dissonance test 10 failed');
    }
    what = umtIsConsonant(5, 4, 3, 2);
    if (what !== true) {
        umtJSabort('dissonance test 11 failed');
    }
    what = umtIsConsonant(4, 3, 3, 2);
    if (what !== false) {
        umtJSabort('dissonance test 12 failed');
    }
    console.log('dissonance tests passed.');
}

function umtFractSubtract(firstNum, firstDnom, secondNum, secondDnom) {
    "use strict";
    // this function does not reduce the result!
    var g, s, xFNum, xFDnom, xSNum, xSDnom, rv;
    g = umtEuclidGCD(firstDnom, secondDnom);
    s = secondDnom / g;
    xFNum = firstNum * s;
    xFDnom = firstDnom * s;
    s = firstDnom / g;
    xSNum = secondNum * s;
    xSDnom = secondDnom * s;
    if (xFDnom !== xSDnom) {
        umtJSabort('denominators are not the same');
    }
    rv = { num: xFNum - xSNum, dnom: xFDnom };
    return rv;
}

function umtIsConsOrderInd(xnum, xdnom, ynum, ydnom) {
    "use strict";
    var diff;
    // is consonant? order independent
    diff = umtFractSubtract(xnum, xdnom, ynum, ydnom);
    if (diff.num < 0) {
        // y is bigger
        return umtIsConsonant(xnum, xdnom, ynum, ydnom);
    }
    // x is bigger
    return umtIsConsonant(ynum, ydnom, xnum, xdnom);
}

// need caching for this function -- recalculating dissonance every time is computationally expensive
function umtDetermineIfFits(num, dnom, listOfNotesAlreadyPlaying) {
    "use strict";
    var lx, i, diff, cacheidxname;
    cacheidxname = "udif" + num + "," + dnom;
    lx = listOfNotesAlreadyPlaying.length;
    for (i = 0; i < lx; i = i + 1) {
        cacheidxname = cacheidxname + "," + listOfNotesAlreadyPlaying[i].num + "," + listOfNotesAlreadyPlaying[i].dnom;
    }
    if (gUmt.cachedFittings.hasOwnProperty(cacheidxname)) {
        return gUmt.cachedFittings[cacheidxname];
    }
    for (i = 0; i < lx; i = i + 1) {
        diff = umtFractSubtract(num, dnom, listOfNotesAlreadyPlaying[i].num, listOfNotesAlreadyPlaying[i].dnom);
        if (diff.num < 0) {
            // already playing is bigger
            if (umtIsConsonant(num, dnom, listOfNotesAlreadyPlaying[i].num, listOfNotesAlreadyPlaying[i].dnom) === false) {
                gUmt.cachedFittings[cacheidxname] = false;
                return false;
            }
        } else {
            // num/dom is bigger
            if (umtIsConsonant(listOfNotesAlreadyPlaying[i].num, listOfNotesAlreadyPlaying[i].dnom, num, dnom) === false) {
                gUmt.cachedFittings[cacheidxname] = false;
                return false;
            }
        }
    }
    gUmt.cachedFittings[cacheidxname] = true;
    return true;
}

function umtFindMostHarmonicNote(pitch, scale, listOfNotesAlreadyPlaying) {
    "use strict";
    var octave, minIdx, minDist, i, dist, rv, originalFullPitch, numOfNotes, topPos, topOctave, bottomPos, bottomOctave, cycCount, topDist, bottomDist, currentPos, currentOctave;
    originalFullPitch = pitch;
    octave = Math.floor(pitch);
    pitch = pitch - octave;
    minIdx = -1;
    minDist = 1.0 - pitch;
    numOfNotes = scale.length;
    for (i = 0; i < numOfNotes; i = i + 1) {
        dist = Math.abs(scale[i].fpt - pitch);
        if (dist < minDist) {
            minIdx = i;
            minDist = dist;
        }
    }
    if (listOfNotesAlreadyPlaying.length === 0) {
        if (minIdx === -1) {
            octave = octave + 1;
            rv = {octave: octave, scalenote: 0, num: scale[0].num, dnom: scale[0].dnom, fpt: scale[0].fpt };
        } else {
            rv = {octave: octave, scalenote: minIdx, num: scale[minIdx].num, dnom: scale[minIdx].dnom, fpt: scale[minIdx].fpt };
        }
        return rv;
    }
    // there are other notes playing: so we can't simply return the best scale
    // match. so we have to find another note.

    // the idea here is to "fan out" -- take the "min" note found above, start
    // with the scale notes directly above and below, and test the closest one
    // to see if it harmonizes with the existing notes. if it doesn't, push it
    // up/down and go through the loop again. mathematically we should be
    // guaranteed to find a match, even if it's a P1 with an existing note.
    if (minIdx === -1) {
        minIdx = 0;
        octave = octave + 1;
    }
    topPos = minIdx;
    topOctave = octave;
    bottomPos = minIdx;
    bottomOctave = octave;
    cycCount = 0;
    while (true) {
        cycCount = cycCount + 1;
        if (cycCount === 100) {
            umtJSabort('crash because stuck in endless loop');
        }
        topDist = Math.abs((topOctave + scale[topPos].fpt) - originalFullPitch);
        bottomDist = Math.abs((bottomOctave + scale[bottomPos].fpt) - originalFullPitch);
        if (topDist < bottomDist) {
            currentPos = topPos;
            currentOctave = topOctave;
            topPos = topPos + 1;
            if (topPos === numOfNotes) {
                topOctave = topOctave + 1;
                topPos = 0;
            }
        } else {
            currentPos = bottomPos;
            currentOctave = bottomOctave;
            bottomPos = bottomPos - 1;
            if (bottomPos < 0) {
                bottomOctave = bottomOctave - 1;
                bottomPos = numOfNotes - 1;
            }
        }
        if (umtDetermineIfFits(scale[currentPos].num, scale[currentPos].dnom, listOfNotesAlreadyPlaying)) {
            rv = {octave: currentOctave, scalenote: currentPos, num: scale[currentPos].num, dnom: scale[currentPos].dnom, fpt: scale[currentPos].fpt };
            return rv;
        }
    }
}

function umtSanitTestEntireScore(lpnum, doOutput) {
    "use strict";
    var parts, currentTime, beyondAll, stillGoing, bustOutCount, playingNow, pncount, vcnum, notenum, partlen, i, x, y, result, xnum, ynum, xdnom, ydnom, xrest, yrest, descrip;
    parts = gUmt.loop[lpnum].score.parts;
    currentTime = 0;
    stillGoing = true;
    bustOutCount = 0;
    while (stillGoing) {
        bustOutCount = bustOutCount + 1;
        if (bustOutCount === 1024) {
            umtJSabort('ugh, we are stuck in an endless loop.');
        }
        beyondAll = true;
        playingNow = [];
        pncount = 0;
        for (vcnum = 0; vcnum < parts; vcnum = vcnum + 1) {
            partlen = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].cursor;
            for (i = 0; i < partlen; i = i + 1) {
                if (gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[i].harmDnom >= 0) {
                    if (gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[i].starttime <= currentTime) {
                        if (gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[i].starttime + gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[i].duration > currentTime) {
                            playingNow[pncount] = {voice: vcnum, note: i};
                            pncount = pncount + 1;
                            beyondAll = false;
                        }
                    }
                }
            }
        }
        if (doOutput) {
//            if (pncount > 0) {
//                playingNow[0].note = 1; /  * evil hack to force a dissonance for testing purposes
//            }
            descrip = '';
            for (i = 0; i < pncount; i = i + 1) {
                vcnum = playingNow[i].voice;
                notenum = playingNow[i].note;
                xnum = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[notenum].harmNum;
                xdnom = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[notenum].harmDnom;
                descrip = descrip + ' and ' + xnum + ' / ' + xdnom;
            }
        }
        for (x = 0; x < pncount - 1; x = x + 1) {
            for (y = x + 1; y < pncount; y = y + 1) {
                vcnum = playingNow[x].voice;
                notenum = playingNow[x].note;
                xnum = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[notenum].harmNum;
                xdnom = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[notenum].harmDnom;
                xrest = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[notenum].rest;
                vcnum = playingNow[y].voice;
                notenum = playingNow[y].note;
                ynum = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[notenum].harmNum;
                ydnom = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[notenum].harmDnom;
                yrest = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[notenum].rest;
                if ((xrest === false) && (yrest === false)) {
                    result = umtIsConsOrderInd(xnum, xdnom, ynum, ydnom);
                    if (result === false) {
                        umtJSabort('BANG!! we just ran into dissonance!');
                    }
                }
            }
        }
        if (beyondAll) {
            stillGoing = false;
        } else {
            currentTime = currentTime + 1;
        }
    }
}

function umtGetScaleByAbbrv(scaleAbbrv) {
    "use strict";
    switch (scaleAbbrv) {
    case 'chroma13':
        return umtGetScale13Chromatic();
    case 'chroma11regreg':
        return umtGetScale11ChromaticRegReg();
    case 'maj7reg':
        return umtGetScale7MajorReg();
    case 'minnat7regreg':
        return umtGetScale7MinorNaturalRegReg();
    case 'minharm7reg':
        return umtGetScale7MinorHarmonicReg(); // use this one
    case 'minmelo7reg':
        return umtGetScale7MinorMelodicReg();
    case 'arabicmaj7':
        return umtGetScale7ArabicishMajor();
    case 'arabicmin7':
        return umtGetScale7ArabicishMinor();
    case 'pentatonic23reg':
        return umtGetScale5Pentatonic23Reg();
    case 'pentatonic32reg':
        return umtGetScale5Pentatonic32Reg();
    case 'quad':
        return umtGetScale4Quadtonic();
    case 'tri':
        return umtGetScale3Tritonic();
    case 'chroma11altreg':
        return umtGetScale11ChromaticAltReg();
    case 'chroma11regalt':
        return umtGetScale11ChromaticRegAlt();
    case 'chroma11altalt':
        return umtGetScale11ChromaticAltAlt();
    case 'maj7alt':
        return umtGetScale7MajorAlt();
    case 'minnat7altreg':
        return umtGetScale7MinorNaturalAltReg();
    case 'minnat7regalt':
        return umtGetScale7MinorNaturalRegAlt();
    case 'minnat7altalt':
        return umtGetScale7MinorNaturalAltAlt();
    case 'minharm7alt':
        return umtGetScale7MinorHarmonicAlt();
    case 'minmelo7alt':
        return umtGetScale7MinorMelodicAlt();
    case 'pentatonic23alt':
        return umtGetScale5Pentatonic23Alt();
    case 'pentatonic32alt':
        return umtGetScale5Pentatonic32Alt();
    default:
        umtJSabort("unrecognized scale code: " + scaleAbbrv);
        break;
    }
}

function umtHarmonizeScore(lpnum) {
    "use strict";
    var theScale, parts, vcnum, notecount, i, currentTime, currentPosition, timeRemaining, offEnd, stillGoing, maxFound, cycleCount, stillUnfoundMaxes, cycleUnfoundCount, maxIdx, poz, listOfNotesAlreadyPlaying, harmonizedInfo, minIdx, dist, lonapCursr;
    theScale = umtAddFloatsToScale(umtGetScaleByAbbrv(gUmt.loop[lpnum].score.scale));
    // clear old data
    parts = gUmt.loop[lpnum].score.parts;
    for (vcnum = 0; vcnum < parts; vcnum = vcnum + 1) {
        notecount = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].cursor;
        for (i = 0; i < notecount; i = i + 1) {
            gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[i].harmOctave = -1;
            gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[i].harmNum = -1;
            gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[i].harmDnom = -1;
        }
    }
    // and off we go
    // this is a tricky function that absolutely relies on the position in the
    // notes array and the duration information being exactly right

    // the way it works is by setting current position to 0, and then advancing
    // the current position when time runs out, and setting the time remaining
    // to the duration of that note.

    // on each cycle, it subtracts the duraction of the shorted note from each
    // of the 'time remaining' values for every note

    // however, while it uses the shortest note (minIdx) for subtracting time
    // (and thereby virtually 'plays' the piece), it uses the longest note
    // (maxIdx) for setting the harmony first

    // maxIdx is actually the longest "unharmonized" note -- not necessarily
    // the longest note
    currentTime = 0;
    currentPosition = [];
    for (i = 0; i < parts; i = i + 1) {
        currentPosition[i] = 0;
    }
    timeRemaining = [];
    for (i = 0; i < parts; i = i + 1) {
        timeRemaining[i] = gUmt.loop[lpnum].score.songTab[0].voice[i].notes[currentPosition[i]].duration;
    }
    offEnd = [];
    for (i = 0; i < parts; i = i + 1) {
        if (currentPosition[i] === gUmt.loop[lpnum].score.songTab[0].voice[i].cursor) {
            offEnd[i] = true;
        } else {
            offEnd[i] = false;
        }
    }
    stillGoing = false;
    for (i = 0; i < parts; i = i + 1) {
        if (offEnd[i] === false) {
            stillGoing = true;
        }
    }
    maxFound = [];
    cycleCount = 0;
    while (stillGoing) {
        cycleCount = cycleCount + 1;
        if (cycleCount > 1000) {
            umtJSabort('caught in endless loop?  cycle count blew up.');
            return;
        }
        for (i = 0; i < parts; i = i + 1) {
            maxFound[i] = false;
        }
        stillUnfoundMaxes = false;
        for (i = 0; i < parts; i = i + 1) {
            if (offEnd[i] === false) {
                if (maxFound[i] === false) {
                    stillUnfoundMaxes = true;
                }
            }
        }
        cycleUnfoundCount = 0;
        while (stillUnfoundMaxes) {
            cycleUnfoundCount = cycleUnfoundCount + 1;
            if (cycleUnfoundCount > 100) {
                umtJSabort('kot in endless looooop?? cycle count unfound blew up.');
                return;
            }
            // find max
            maxIdx = -1;
            for (i = 0; i < parts; i = i + 1) {
                if (offEnd[i] === false) {
                    if (maxFound[i] === false) {
                        if (maxIdx === -1) {
                            maxIdx = i;
                        } else {
                            if (timeRemaining[i] > timeRemaining[maxIdx]) {
                                maxIdx = i;
                            }
                        }
                    }
                }
            }
            if (maxIdx === -1) {
                umtJSabort('maxIdx is -1 -- should be impossible');
                return;
            }
            maxFound[maxIdx] = true;
            // here is the actual "harmonization" code -- everything else is
            // just looping
            if (gUmt.loop[lpnum].score.songTab[0].voice[maxIdx].notes[currentPosition[maxIdx]].harmDnom === -1) {
                poz = currentPosition[maxIdx];
                // find all other notes that are turned on at the same time
                listOfNotesAlreadyPlaying = [];
                lonapCursr = 0;
                for (i = 0; i < parts; i = i + 1) {
                    if (currentPosition[i] < gUmt.loop[lpnum].score.songTab[0].voice[i].cursor) { // check that we're not off the end
                        if (gUmt.loop[lpnum].score.songTab[0].voice[i].notes[currentPosition[i]].harmDnom !== -1) {
                            // sanity check 2
                            if (currentTime < gUmt.loop[lpnum].score.songTab[0].voice[i].notes[currentPosition[i]].starttime) {
                                umtJSabort('START TIME IS AFTER CURRENT TIME! OH NO!');
                            }
                            if (currentTime >= (gUmt.loop[lpnum].score.songTab[0].voice[i].notes[currentPosition[i]].starttime + gUmt.loop[lpnum].score.songTab[0].voice[i].notes[currentPosition[i]].duration)) {
                                umtJSabort('START TIME + DURATION IS BEFORE CURRENT TIME!! OH NO!!');
                            }
                            if (gUmt.loop[lpnum].score.songTab[0].voice[i].notes[currentPosition[i]].rest === false) {
                                listOfNotesAlreadyPlaying[lonapCursr] = {octave: gUmt.loop[lpnum].score.songTab[0].voice[i].notes[currentPosition[i]].harmOctave, num: gUmt.loop[lpnum].score.songTab[0].voice[i].notes[currentPosition[i]].harmNum, dnom: gUmt.loop[lpnum].score.songTab[0].voice[i].notes[currentPosition[i]].harmDnom};
                                lonapCursr = lonapCursr + 1;
                            }
                        }
                    }
                }
                harmonizedInfo = umtFindMostHarmonicNote(gUmt.loop[lpnum].score.songTab[0].voice[maxIdx].notes[poz].pitch, theScale, listOfNotesAlreadyPlaying);
                // sanity check 1
                if (currentTime !== gUmt.loop[lpnum].score.songTab[0].voice[maxIdx].notes[currentPosition[maxIdx]].starttime) {
                    umtCx('START TIMES DO NOT MATCH! OH NO!');
                    umtCx('currentTime is ' + currentTime);
                    umtCx('gUmt.loop[lpnum].score.songTab[0].voice[maxIdx].notes[currentPosition[maxIdx]].starttime is ' + gUmt.loop[lpnum].score.songTab[0].voice[maxIdx].notes[currentPosition[maxIdx]].starttime);
                    umtCx('lpnum is ' + lpnum);
                    umtCx('maxIdx is ' + maxIdx);
                    umtCx('currentPosition[maxIdx] is ' + currentPosition[maxIdx]);
                    console.log('gUmt', gUmt);
                    umtJSabort('START TIMES DO NOT MATCH! OH NO!');
                }
                gUmt.loop[lpnum].score.songTab[0].voice[maxIdx].notes[currentPosition[maxIdx]].harmOctave = harmonizedInfo.octave;
                gUmt.loop[lpnum].score.songTab[0].voice[maxIdx].notes[currentPosition[maxIdx]].harmNum = harmonizedInfo.num;
                gUmt.loop[lpnum].score.songTab[0].voice[maxIdx].notes[currentPosition[maxIdx]].harmDnom = harmonizedInfo.dnom;
                // umtSanitTestEntireScore(lpnum, false);
            }
            // end of actual "harmonization" code"
            stillUnfoundMaxes = false; // this loop could no doubt be optimized
            for (i = 0; i < parts; i = i + 1) {
                if (offEnd[i] === false) {
                    if (maxFound[i] === false) {
                        stillUnfoundMaxes = true;
                    }
                }
            }
        }
        // find min
        minIdx = -1;
        for (i = 0; i < parts; i = i + 1) {
            if (offEnd[i] === false) {
                if (minIdx === -1) {
                    minIdx = i;
                } else {
                    if (timeRemaining[i] < timeRemaining[minIdx]) {
                        minIdx = i;
                    }
                }
            }
        }
        // subtract dist
        dist = timeRemaining[minIdx];
        currentTime += dist;
        for (i = 0; i < parts; i = i + 1) {
            if (offEnd[i] === false) {
                timeRemaining[i] -= dist;
            }
        }
        // advance positions
        for (i = 0; i < parts; i = i + 1) {
            if (offEnd[i] === false) {
                if (timeRemaining[i] === 0) {
                    currentPosition[i] = currentPosition[i] + 1;
                    if (currentPosition[i] === gUmt.loop[lpnum].score.songTab[0].voice[i].cursor) {
                        offEnd[i] = true;
                    } else {
                        timeRemaining[i] = gUmt.loop[lpnum].score.songTab[0].voice[i].notes[currentPosition[i]].duration;
                    }
                }
            }
        }
        for (i = 0; i < parts; i = i + 1) {
            if (currentPosition[i] === gUmt.loop[lpnum].score.songTab[0].voice[i].cursor) {
                offEnd[i] = true;
            }
        }
        stillGoing = false;
        for (i = 0; i < parts; i = i + 1) {
            if (offEnd[i] === false) {
                stillGoing = true;
            }
        }
    }
    umtSanitTestEntireScore(lpnum, true);
    umtCx('umtHarmonizeScore(lpnum) done');
}

function umtExecHarmonizeScore() {
    "use strict";
    umtHarmonizeScore(0);
}

function umtPlayHarmonized(lpnum) {
    "use strict";
    var fromMoment, center, tempoScalar, numVoices, voicenum, notenum, duration, amplitude, frequency, startTime, instSpecificParams, harmonizedOctave, harmonizedNum, harmonizedDnom, instrument;
    fromMoment = gUmt.globalCtx.currentTime + 1;
    center = gUmt.loop[lpnum].score.centernoteLog;
    tempoScalar = 60 / gUmt.loop[lpnum].score.tempo;
    numVoices = gUmt.loop[lpnum].score.parts;
    for (voicenum = 0; voicenum < numVoices; voicenum = voicenum + 1) {
        for (notenum = 0; notenum < gUmt.loop[lpnum].score.songTab[0].voice[voicenum].cursor; notenum = notenum + 1) {
            if (gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].rest === false) {
                harmonizedOctave = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].harmOctave;
                harmonizedNum = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].harmNum;
                harmonizedDnom = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].harmDnom;
                duration = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].duration * tempoScalar;
                amplitude = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].amplitude;
                amplitude = amplitude / numVoices;
                instSpecificParams = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].instParams;
                frequency = Math.exp((harmonizedOctave + center) * gUmt.LOG2);
                frequency = frequency * (harmonizedNum / harmonizedDnom);
                startTime = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].starttime * tempoScalar;
                instrument = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].instrument;
                umtCx("(1155) instrument: " + instrument);
                if (instrument === 0) {
                    umtTestQueUpANoteSineWave(fromMoment, frequency, startTime, duration, amplitude, instSpecificParams);
                } else {
                    umtTestQueUpANoteSineWave(fromMoment, frequency, startTime, duration, amplitude, instSpecificParams);
                }
            }
        }
    }
}

function umtDumpHarmonized(lpnum) {
    "use strict";
    var numVoices, voicenum, notenum, duration, amplitude, startTime, harmonizedOctave, harmonizedNum, harmonizedDnom;
    numVoices = gUmt.loop[lpnum].score.parts;
    umtCx('numVoices is ' + numVoices);
    for (voicenum = 0; voicenum < numVoices; voicenum = voicenum + 1) {
        umtCx('  voicenum is ' + voicenum);
        for (notenum = 0; notenum < gUmt.loop[lpnum].score.songTab[0].voice[voicenum].cursor; notenum = notenum + 1) {
            harmonizedOctave = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].harmOctave;
            harmonizedNum = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].harmNum;
            harmonizedDnom = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].harmDnom;
            duration = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].duration;
            amplitude = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].amplitude;
            amplitude = amplitude / numVoices;
            startTime = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].starttime;
            if (gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].rest) {
                umtCx('    note ' + notenum + ', start ' + startTime + ', duration ' + duration + ', rest');
            } else {
                umtCx('    note ' + notenum + ', start ' + startTime + ', duration ' + duration + ', octave ' + harmonizedOctave + ', num ' + harmonizedNum + ', dnom ' + harmonizedDnom + ', amplitude ' + amplitude);
            }
        }
    }
}

function umtExecPlayHarmonized() {
    "use strict";
    umtPlayHarmonized(0);
}

function umtExecRunTests() {
    "use strict";
    umtTestIsConsonant();
    window.alert('Tests passed.');
}

function umtExecDisonanceTest() {
    "use strict";
    var firstNum, firstDnom, secondNum, secondDnom, diff, result;
    firstNum = document.getElementById('firstNum').value;
    firstNum = parseInt(firstNum, 10);
    umtCx('firstNum is ' + firstNum);
    firstDnom = document.getElementById('firstDnom').value;
    firstDnom = parseInt(firstDnom, 10);
    umtCx('firstDnom is ' + firstDnom);
    secondNum = document.getElementById('secondNum').value;
    secondNum = parseInt(secondNum, 10);
    umtCx('secondNum is ' + secondNum);
    secondDnom = document.getElementById('secondDnom').value;
    secondDnom = parseInt(secondDnom, 10);
    umtCx('secondDnom is ' + secondDnom);
    umtCx('  so we got ' + firstNum + ' / ' + firstDnom + ', ' + secondNum + ' / ' + secondDnom);
    diff = umtFractSubtract(firstNum, firstDnom, secondNum, secondDnom);
    umtCx('diff is ' + diff.num + ' / ' + diff.dnom);
    if (diff.num < 0) {
        // second is bigger
        umtCx('second is bigger');
        result = umtIsConsonant(firstNum, firstDnom, secondNum, secondDnom);
    } else {
        // first is bigger
        umtCx('first is bigger');
        result = umtIsConsonant(secondNum, secondDnom, firstNum, firstDnom);
    }
    umtCx('result is ' + result);
    if (result) {
        window.alert('consonant');
    } else {
        window.alert('DISSONANT');
    }
}

function umtGenRhythmSubset(randomObj, minSize, chunkSize) {
    "use strict";
    var setSize, rv, currentTime, position, amountLeft, dur;
    setSize = chunkSize / minSize;
    rv = [];
    currentTime = 0;
    position = 0;
    while (currentTime < setSize) {
        amountLeft = setSize - currentTime;
        if (amountLeft === 1) {
            dur = 1;
        } else {
            dur = Math.floor(randomObj.genrandReal2() * amountLeft + 1);
        }
        rv[position] = dur * minSize;
        position = position + 1;
        currentTime = currentTime + dur;
    }
    return rv;
}

function umtGenerateRhythm(randomObj, minSize, chunkSize, totalLength) {
    "use strict";
    var rv, currentStart, chunkData, endPt, chunkLen, idx;
    if (chunkSize === totalLength) {
        return umtGenRhythmSubset(randomObj, minSize, chunkSize);
    }
    rv = [];
    for (currentStart = 0; currentStart < totalLength; currentStart = currentStart + chunkSize) {
        chunkData = umtGenRhythmSubset(randomObj, minSize, chunkSize);
        endPt = rv.length;
        chunkLen = chunkData.length;
        for (idx = 0; idx < chunkLen; idx = idx + 1) {
            rv[endPt + idx] = chunkData[idx];
        }
    }
    return rv;
}

function umtAddSymBaseToVoice(lpnum, vcnum, minSize, chunkSize, totalLength, centerOctave, restyness, noteDistance, ampVariation, volume) {
    "use strict";
    var rhythm, lenRhy, idx, duration, pitch, amplitude, volscalar;
    volscalar = 2.7;
    volume = Math.exp(volume * volscalar) / Math.exp(volscalar); // this is done to "logarithmize" the volume slider
    rhythm = umtGenerateRhythm(gUmt.loop[lpnum].score.songTab[0].voice[vcnum].randRhythm, minSize, chunkSize, totalLength);
    lenRhy = rhythm.length;
    for (idx = 0; idx < lenRhy; idx = idx + 1) {
        duration = rhythm[idx];
        pitch = (gUmt.loop[lpnum].score.songTab[0].voice[vcnum].randPitch.genrandReal2() * (2 * noteDistance)) - noteDistance;
        if (gUmt.loop[lpnum].score.songTab[0].voice[vcnum].randRests.genrandReal2() < restyness) {
            umtAddNote(lpnum, vcnum, true, centerOctave, duration, 1, null);
        } else {
            amplitude = (1.0 - (gUmt.loop[lpnum].score.songTab[0].voice[vcnum].randAmp.genrandReal2() * ampVariation)) * volume;
            if (idx === 0) {
                pitch = Math.floor(pitch + 0.5);
            }
            umtAddNote(lpnum, vcnum, false, centerOctave + pitch, duration, amplitude, null);
        }
    }
}

function umtSchedulePlayOfSegment() {
    "use strict";
    var lpnum, currentTime, ctxOffset, compositonlag, windowStart, windowStop, loopUnitLen, loopLen, fromMoment, center, tempoScalar, numVoices, voicenum, notenum, duration, amplitude, frequency, adjustedStartTime, startTime, instSpecificParams, harmonizedOctave, harmonizedNum, harmonizedDnom, anythingPlayed, instrument;
    lpnum = gUmt.currentlyPlayingLoop;
    if (gUmt.loop[lpnum].score.parts === 0) {
        return;
    }
    ctxOffset = 0; // gUmt.loop[lpnum].score.playbackTimeOffset;
    currentTime = gUmt.globalCtx.currentTime + ctxOffset;
    windowStart = currentTime;
    compositonlag = gUmt.compositionLag;
    if (compositonlag < 0.1) {
        compositonlag = 0.1;
    }
    windowStop = currentTime + (compositonlag * 3);
    if (windowStart < gUmt.playedUpTo) {
        windowStart = gUmt.playedUpTo;
    }
    anythingPlayed = false;
    if (gUmt.loop[gUmt.currentlyPlayingLoop].score.parts > 0) {
        loopUnitLen = gUmt.loop[lpnum].score.songTab[0].voice[0].nextStart;
        tempoScalar = 60 / gUmt.loop[lpnum].score.tempo;
        loopLen = loopUnitLen * tempoScalar;
        fromMoment = Math.floor(windowStart / loopLen) * loopLen;
        center = gUmt.loop[lpnum].score.centernoteLog;
        numVoices = gUmt.loop[lpnum].score.parts;
        for (voicenum = 0; voicenum < numVoices; voicenum = voicenum + 1) {
            for (notenum = 0; notenum < gUmt.loop[lpnum].score.songTab[0].voice[voicenum].cursor; notenum = notenum + 1) {
                adjustedStartTime = (gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].starttime * tempoScalar) + fromMoment;
                if (adjustedStartTime < windowStart) {
                    adjustedStartTime = adjustedStartTime + loopLen;
                }
                if (adjustedStartTime < windowStop) {
                    if (gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].rest === false) {
                        harmonizedOctave = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].harmOctave;
                        harmonizedNum = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].harmNum;
                        harmonizedDnom = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].harmDnom;
                        duration = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].duration * tempoScalar;
                        amplitude = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].amplitude;
                        if (numVoices === 1) {
                            amplitude = amplitude / 1.4142135623730951;
                        } else {
                            amplitude = amplitude / numVoices;
                        }
                        instSpecificParams = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].instParams;
                        frequency = Math.exp((harmonizedOctave + center) * gUmt.LOG2);
                        frequency = frequency * (harmonizedNum / harmonizedDnom);
                        startTime = adjustedStartTime - fromMoment; // gUmt.loop[lpnum].score.songTab[0].voice[voicenum].notes[notenum].starttime * tempoScalar;
                        instrument = gUmt.loop[lpnum].score.songTab[0].voice[voicenum].instrument;
                        umtCx("instrument" + instrument);
                        gUmt.instrumentBank[instrument].queUpANote(fromMoment - ctxOffset, frequency, startTime, duration, amplitude, instSpecificParams);
                        anythingPlayed = true;
                    }
                }
            }
        }
    }
    if (anythingPlayed) {
        gUmt.playedUpTo = windowStop;
    }
    if (gUmt.timerIsOn) {
        window.setTimeout(umtSchedulePlayOfSegment, compositonlag * 1000);
    }
}

function umtDoTimerPulse() {
    "use strict";
    umtSchedulePlayOfSegment();
}

function umtAutomaticStart(lpnum) {
    "use strict";
    gUmt.currentlyPlayingLoop = lpnum;
    if (!gUmt.timerIsOn) {
        window.setTimeout(umtDoTimerPulse, 500);
    }
    gUmt.timerIsOn = true;
}

function umtAutomaticStop() {
    "use strict";
    gUmt.timerIsOn = false;
}

function umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose) {
    "use strict";
    var segmentStart, ix, segmentEnd, tsRhCursor, tsPiCursor, minPitch, maxPitch, thisPitch, midpointPitch, rhythmCursor, pitchCursor, terminationCursor, rest, duration, amplitude, instParams, percent, bevelAmount, segmentLen, rangeTestStart, rangeTestEnd, rangeTestCursor, rangePitch, rangeMin, rangeMax, rangeScalar, rangeTranspose;
    // first find the start and end of the segment, and the starting point for the rhythm cursor (tsRhCursor) and pitch cursor (tsPiCursor) which can be different if there is rhythm or pitch scrolling
    segmentStart = -1;
    tsRhCursor = -1; // ts == "time scroll"; rh == "rhythm", pi == "pitch"
    tsPiCursor = -1;
    for (ix = 0; ix < gUmt.loop[lpnum].score.songTab[0].voice[vcnum].cursor; ix = ix + 1) {
        // yes, we search the whole voice -- this is ok because loops are short.
        // If the sytem is ever used for long compositions, this will need to
        // be replaced with interval halving
        if (segmentStart === -1) {
            if (gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[ix].starttime >= startTime) {
                segmentStart = ix;
                maxPitch = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[ix].pitch;
                minPitch = maxPitch;
            }
        }
        if (gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[ix].starttime < endTime) {
            segmentEnd = ix;
        }
        if (tsRhCursor === -1) {
            if (gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[ix].starttime >= (startTime + timeRhythmScroll)) {
                tsRhCursor = ix;
            }
        }
        if (tsPiCursor === -1) {
            if (gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[ix].starttime >= (startTime + timePitchScroll)) {
                tsPiCursor = ix;
            }
        }
        if ((gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[ix].starttime >= startTime) && (gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[ix].starttime < endTime)) {
            // if notes are "playing" get min and max
            // we need min and max for scrolling effect
            thisPitch = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[ix].pitch;
            if (thisPitch > maxPitch) {
                maxPitch = thisPitch;
            }
            if (thisPitch < minPitch) {
                minPitch = thisPitch;
            }
        }
    }
    segmentLen = segmentEnd - segmentStart + 1;
    midpointPitch = (minPitch + maxPitch) / 2;
    // time scroll cursors handle "horizontal" scrolling (pitch and rhythm as separate channels)
    rhythmCursor = tsRhCursor;
    pitchCursor = tsPiCursor;
    if (rhythmDirection === -1) {
        rhythmCursor = segmentEnd - (tsRhCursor - segmentStart);
    }
    if (pitchesDirection === -1) {
        pitchCursor = segmentEnd - (tsPiCursor - segmentStart);
    }
    terminationCursor = segmentStart;
    rangeTestStart = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].cursor;
    // execute the copy+transform
    while (terminationCursor <= segmentEnd) {
        rest = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[pitchCursor].rest;
        thisPitch = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[pitchCursor].pitch;
        duration = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[rhythmCursor].duration;
        amplitude = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[rhythmCursor].amplitude;
        instParams = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[rhythmCursor].instParams;
        // actual pitch scroll handles "vertical" scrolling
        if (actualPitchScroll !== 0) {
            thisPitch = thisPitch    + actualPitchScroll;
            if (thisPitch > maxPitch) {
                thisPitch = thisPitch - (maxPitch - minPitch);
            } else {
                if (thisPitch < minPitch) {
                    thisPitch = thisPitch + (maxPitch - minPitch);
                }
            }
        }
        if (pitchScale !== 1) {
            thisPitch = ((thisPitch - midpointPitch) * pitchScale) + midpointPitch;
        }
        // "bevel" bevels only towards the end note, but bevel combined with
        // transpose can bevel both ends; having an additional parameter to
        // bevel the front end would be redundant because it would just be
        // subtracted from transpose
        if (pitchBevel !== 0) {
            percent = (gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[terminationCursor].starttime - startTime) / (endTime - startTime);
            bevelAmount = pitchBevel * percent;
            thisPitch = thisPitch + bevelAmount;
        }
        if (pitchTranspose !== 0) {
            thisPitch = thisPitch + pitchTranspose;
        }
        umtAddNote(lpnum, vcnum, rest, thisPitch, duration, amplitude, instParams);
        rhythmCursor = rhythmCursor + rhythmDirection;
        if (rhythmCursor > segmentEnd) {
            rhythmCursor = rhythmCursor - segmentLen;
        }
        if (rhythmCursor < segmentStart) {
            rhythmCursor = pitchCursor + segmentLen;
        }
        pitchCursor = pitchCursor + pitchesDirection;
        if (pitchCursor > segmentEnd) {
            pitchCursor = pitchCursor - segmentLen;
        }
        if (pitchCursor < segmentStart) {
            pitchCursor = pitchCursor + segmentLen;
        }
        terminationCursor = terminationCursor + 1;
    }
    // see if we went out of range, and if so, transpose in direction of proper
    // range (allowing for slight overshoot)
    rangeTestEnd = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].cursor;
    minPitch = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[rangeTestStart].pitch;
    maxPitch = minPitch;
    for (rangeTestCursor = rangeTestStart; rangeTestCursor < rangeTestEnd; rangeTestCursor = rangeTestCursor + 1) {
        rangePitch = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[rangeTestCursor].pitch;
        if (rangePitch < minPitch) {
            minPitch = rangePitch;
        }
        if (rangePitch > maxPitch) {
            maxPitch = rangePitch;
        }
    }
    rangeMin = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].rangeBottom;
    rangeMax = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].rangeTop;
    if ((minPitch < rangeMin) && (maxPitch > rangeMax)) {
        umtJSabort('exceeded both min and max for range');
        // exceeded both min and max -- need to scale and transpose
        rangeScalar = (rangeMax - rangeMin) / (maxPitch - minPitch);
        rangeTranspose = ((maxPitch - minPitch) / 2) - ((rangeMax - rangeMin) / 2);
        for (ix = rangeTestStart; ix < rangeTestEnd; ix = ix + 1) {
            gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[ix].pitch = (gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[ix].pitch * rangeScalar) - rangeTranspose;
        }
    } else {
        if (minPitch < rangeMin) {
            rangeTranspose = (rangeMin - minPitch) / 2;
            for (ix = rangeTestStart; ix < rangeTestEnd; ix = ix + 1) {
                gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[ix].pitch = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[ix].pitch + rangeTranspose;
            }
        } else {
            if (maxPitch > rangeMax) {
                rangeTranspose = (maxPitch - rangeMax) / 2;
                for (ix = rangeTestStart; ix < rangeTestEnd; ix = ix + 1) {
                    gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[ix].pitch = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[ix].pitch - rangeTranspose;
                }
            }
        }
    }
}

function umtTestResetCopytransTestSequence() {
    "use strict";
    umtClearLoop(0, 400, 432, "maj7reg");
    umtAddVoice(0, 0, 0, 4, 6, "tuningfork");
    umtAddNote(0, 0, false, 5.0, 1, 0.99, false);
    umtAddNote(0, 0, false, 5.1, 1, 0.99, false);
    umtAddNote(0, 0, false, 5.2, 2, 0.99, false);
    umtAddNote(0, 0, false, 5.3, 4, 0.99, false);
    umtAddNote(0, 0, false, 5.4, 8, 0.99, false);
    umtAddNote(0, 0, false, 5.5, 16, 0.99, false);
}

function umtTestCheckCopytransPitches(pitchList, startingIndex, failMessage) {
    "use strict";
    var x, pt;
    umtCx("checking pitches/" + failMessage);
    x = startingIndex;
    for (pt in pitchList) {
        if (pitchList.hasOwnProperty(pt)) {
            if (gUmt.loop[0].score.songTab[0].voice[0].notes[x].pitch !== pitchList[pt]) {
                umtJSabort("test failed: pitches/" + failMessage);
            }
            x = x + 1;
        }
    }
}

function umtTestCheckCopytransDurations(durationList, startingIndex, failMessage) {
    "use strict";
    var x, dr;
    umtCx("checking durations/" + failMessage);
    x = startingIndex;
    for (dr in durationList) {
        if (durationList.hasOwnProperty(dr)) {
            if (gUmt.loop[0].score.songTab[0].voice[0].notes[x].duration !== durationList[dr]) {
                umtJSabort("test failed: durations/" + failMessage);
            }
            x = x + 1;
        }
    }
}

function umtTestSetupCopyTransTestSection() {
    "use strict";
    var lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose;

    // exact copy
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = 1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.0, 5.1, 5.2, 5.3, 5.4, 5.5], 6, "exact copy");
    umtTestCheckCopytransDurations([1, 1, 2, 4, 8, 16], 6, "exact copy");

    // transpose
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = 1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0.4;
    umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.4, 5.5, 5.6000000000000005, 5.7, 5.800000000000001, 5.9], 6, "transpose");
    umtTestCheckCopytransDurations([1, 1, 2, 4, 8, 16], 6, "transpose");

    // reverse-rhythm
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = -1;
    pitchesDirection = 1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.0, 5.1, 5.2, 5.3, 5.4, 5.5], 6, "reverse-rhythm");
    umtTestCheckCopytransDurations([16, 8, 4, 2, 1, 1], 6, "reverse-rhythm");

    // reverse-pitch
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = -1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.5, 5.4, 5.3, 5.2, 5.1, 5.0], 6, "reverse-pitch");
    umtTestCheckCopytransDurations([1, 1, 2, 4, 8, 16], 6, "reverse-pitch");

    // reverse-both
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = -1;
    pitchesDirection = -1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.5, 5.4, 5.3, 5.2, 5.1, 5.0], 6, "reverse-both");
    umtTestCheckCopytransDurations([16, 8, 4, 2, 1, 1], 6, "reverse-both");

    // scale-positive
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = 1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 0.5;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.125, 5.175, 5.225, 5.275, 5.325, 5.375], 6, "scale-positive");
    umtTestCheckCopytransDurations([1, 1, 2, 4, 8, 16], 6, "scale-positive");

    // scale-1
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = 1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = -1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.5, 5.4, 5.3, 5.2, 5.1, 5.0], 6, "scale-1");
    umtTestCheckCopytransDurations([1, 1, 2, 4, 8, 16], 6, "scale-1");

    // scale-negative
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = 1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = -0.5;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.375, 5.325, 5.275, 5.225, 5.175, 5.125], 6, "scale-negative");
    umtTestCheckCopytransDurations([1, 1, 2, 4, 8, 16], 6, "scale-negative");

    // tilt-ascending
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = 1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 1.0;
    pitchTranspose = -0.5;
    umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([4.5, 4.63125, 4.7625, 4.925, 5.15, 5.5], 6, "tilt-ascending");
    umtTestCheckCopytransDurations([1, 1, 2, 4, 8, 16], 6, "tilt-ascending");

    // tilt-descending
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = 1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = -1.0;
    pitchTranspose = 0.5;
    umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.5, 5.56875, 5.6375, 5.675, 5.65, 5.5], 6, "tilt-descending");
    umtTestCheckCopytransDurations([1, 1, 2, 4, 8, 16], 6, "tilt-descending");

    // scroll-rhythm
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = 1;
    timeRhythmScroll = 8;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.0, 5.1, 5.2, 5.3, 5.4, 5.5], 6, "scroll-rhythm");
    umtTestCheckCopytransDurations([8, 16, 1, 1, 2, 4], 6, "scroll-rhythm");

    // scroll-pitch
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = 1;
    timeRhythmScroll = 0;
    timePitchScroll = 8;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.4, 5.5, 5.0, 5.1, 5.2, 5.3], 6, "scroll-pitch");
    umtTestCheckCopytransDurations([1, 1, 2, 4, 8, 16], 6, "scroll-pitch");

    // scroll-both
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = 1;
    timeRhythmScroll = 8;
    timePitchScroll = 8;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.4, 5.5, 5.0, 5.1, 5.2, 5.3], 6, "scroll-both");
    umtTestCheckCopytransDurations([8, 16, 1, 1, 2, 4], 6, "scroll-both");

    // reverse-rhythm
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = -1;
    pitchesDirection = 1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.0, 5.1, 5.2, 5.3, 5.4, 5.5], 6, "reverse-rhythm");
    umtTestCheckCopytransDurations([16, 8, 4, 2, 1, 1], 6, "reverse-rhythm");

    // reverse-pitch
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = -1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.5, 5.4, 5.3, 5.2, 5.1, 5.0], 6, "reverse-pitch");
    umtTestCheckCopytransDurations([1, 1, 2, 4, 8, 16], 6, "reverse-pitch");

    //reverse-both
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = -1;
    pitchesDirection = -1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.5, 5.4, 5.3, 5.2, 5.1, 5.0], 6, "reverse-both");
    umtTestCheckCopytransDurations([16, 8, 4, 2, 1, 1], 6, "reverse-both");

    window.alert("Tests passed");
}

function umtExecTestCopyTrans(lpnum) {
    "use strict";
    var parts, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose, csrPos, csrStart, duration;
    parts = gUmt.loop[lpnum].score.parts;
    for (vcnum = 0; vcnum < parts; vcnum = vcnum + 1) {
        startTime = 0;
        csrPos = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].cursor;
        csrStart = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[csrPos - 1].starttime;
        duration = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[csrPos - 1].duration;
        endTime = csrStart + duration;
        rhythmDirection = 1;
        pitchesDirection = 1;
        timeRhythmScroll = 0;
        timePitchScroll = 0;
        actualPitchScroll = 0;
        pitchScale = 1.0;
        pitchBevel = 0;
        pitchTranspose = 0.5;
        umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
        csrPos = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].cursor;
        csrStart = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[csrPos - 1].starttime;
        duration = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[csrPos - 1].duration;
        endTime = csrStart + duration;
        pitchTranspose = 0.7;
        umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
        csrPos = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].cursor;
        csrStart = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[csrPos - 1].starttime;
        duration = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[csrPos - 1].duration;
        endTime = csrStart + duration;
        pitchTranspose = -1.33;
        pitchScale = 2.0;
        rhythmDirection = 1;
        pitchesDirection = -1;
        umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    }
    umtCx('umtExecTestCopyTrans() done');
}

function umtComposeSampleComposition(lpnum) {
    "use strict";
    umtJSabort("old function called for composition.");
    umtClearLoop(lpnum, gUmt.UIParams.tempo, gUmt.UIParams.centernote, gUmt.UIParams.scale);
    umtAddVoice(lpnum, 0, 0, 4, 6, "tuningfork"); // 5 - 1, 5 + 1
    umtAddSymBaseToVoice(lpnum, 0, 1, 8, 32, 5, 0, 0.5);
    umtAddVoice(lpnum, 1, 1, 2, 4, "tuningfork");
    umtAddSymBaseToVoice(lpnum, 1, 4, 8, 32, 3, 10, 0.5);
    umtAddVoice(lpnum, 2, 2, 1, 3, "tuningfork");
    umtAddSymBaseToVoice(lpnum, 2, 16, 16, 32, 2, 20, 0.5);
    umtAddVoice(lpnum, 3, 3, 7, 9, "tuningfork");
    umtAddSymBaseToVoice(lpnum, 3, 1, 2, 32, 8, 30, 0.5);
    umtAddVoice(lpnum, 4, 4, 6, 8, "tuningfork");
    umtAddSymBaseToVoice(lpnum, 4, 1, 2, 32, 7, 40, 0.5);
    umtAddVoice(lpnum, 5, 5, 5, 7, "tuningfork");
    umtAddSymBaseToVoice(lpnum, 5, 1, 8, 32, 6, 50, 0.5);
    umtExecTestCopyTrans(lpnum);
    umtHarmonizeScore(lpnum);
}

function umtUIIsPartInUI(ptnum) {
    "use strict";
    if (document.getElementById("voice_row_" + ptnum)) {
        return true;
    }
    return false;
}

function umtComposeRealComposition(lpnum) {
    "use strict";
    var compositionVoice, UIVoice, songNumber, octave, rangeMin, rangeMax, instrumentName, minSize, chunkSize, totalLength, centerOctave, restyness, ampVariation, volume, noteDistance, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose, symmetryPattern, csrPos, csrStart, duration, loopDuration, vcnum;
    if (gUmt.idemAddingVoice) {
        umtJSabort("umtComposeRealComposition called during add voice");
    }
    umtClearLoop(lpnum, gUmt.UIParams.tempo, gUmt.UIParams.centernote, gUmt.UIParams.scale);
    compositionVoice = 0;
    UIVoice = 0;
    loopDuration = gUmt.UIParams.loopDuration;
    while (umtUIIsPartInUI(UIVoice)) {
        if (gUmt.UIParams.songTab[0].voice[UIVoice].playing) {
            songNumber = gUmt.UIParams.songTab[0].voice[UIVoice].songNumber;
            octave = gUmt.UIParams.songTab[0].voice[UIVoice].octave;
            rangeMin = octave - 1.25;
            rangeMax = octave + 1.25;
            instrumentName = gUmt.UIParams.songTab[0].voice[UIVoice].instrument;
            umtAddVoice(lpnum, compositionVoice, songNumber, rangeMin, rangeMax, instrumentName);
            minSize = gUmt.UIParams.songTab[0].voice[UIVoice].minNote;
            chunkSize = gUmt.UIParams.songTab[0].voice[UIVoice].chunkSize;
            totalLength = gUmt.UIParams.songTab[0].voice[UIVoice].frameSize;
            centerOctave = octave;
            restyness = gUmt.UIParams.songTab[0].voice[UIVoice].restyness;
            ampVariation = gUmt.UIParams.songTab[0].voice[UIVoice].ampVariation;
            noteDistance = gUmt.UIParams.songTab[0].voice[UIVoice].noteDistance;
            volume = gUmt.UIParams.songTab[0].voice[UIVoice].volume;
            umtAddSymBaseToVoice(lpnum, compositionVoice, minSize, chunkSize, totalLength, centerOctave, restyness, noteDistance, ampVariation, volume);
            // we have voices and base rhythms; now need symmetry
            startTime = 0;
            csrPos = gUmt.loop[lpnum].score.songTab[0].voice[compositionVoice].cursor;
            csrStart = gUmt.loop[lpnum].score.songTab[0].voice[compositionVoice].notes[csrPos - 1].starttime; // can eliminate intermediaries
            duration = gUmt.loop[lpnum].score.songTab[0].voice[compositionVoice].notes[csrPos - 1].duration;
            endTime = csrStart + duration;
            while (endTime < loopDuration) {
                // set default parameters, then modify defaults according to UI
                rhythmDirection = 1;
                pitchesDirection = 1;
                timeRhythmScroll = 0;
                timePitchScroll = 0;
                actualPitchScroll = 0;
                pitchScale = 1.0;
                pitchBevel = 0;
                pitchTranspose = 0;
                symmetryPattern = gUmt.UIParams.songTab[0].voice[UIVoice].symmetry[endTime].pattern;
                switch (symmetryPattern) {
                case 'trans':
                    pitchTranspose = (2 * gUmt.UIParams.songTab[0].voice[UIVoice].symmetry[endTime].transParam) * (gUmt.loop[lpnum].score.songTab[0].voice[compositionVoice].randTrans.genrandReal1() - 0.5);
                    break;
                case 'invert':
                    pitchScale = -1.0;
                    break;
                case 'scale':
                    pitchScale = gUmt.UIParams.songTab[0].voice[UIVoice].symmetry[endTime].scaleParam * gUmt.loop[lpnum].score.songTab[0].voice[compositionVoice].randScale.genrandReal1();
                    break;
                case 'tilt':
                    pitchBevel = gUmt.UIParams.songTab[0].voice[UIVoice].symmetry[endTime].tiltParam * gUmt.loop[lpnum].score.songTab[0].voice[compositionVoice].randTilt.genrandReal1();
                    pitchTranspose = -(pitchBevel / 2);
                    break;
                case 'reverserhythm':
                    rhythmDirection = -1;
                    break;
                case 'reversepitch':
                    pitchesDirection = -1;
                    break;
                case 'reverseboth':
                    rhythmDirection = -1;
                    pitchesDirection = -1;
                    break;
                case 'scrollrhythm':
                    timeRhythmScroll = (gUmt.UIParams.songTab[0].voice[UIVoice].symmetry[endTime].scrollbothParam * gUmt.loop[lpnum].score.songTab[0].voice[compositionVoice].randTilt.genrandReal1()) * (endTime - startTime);
                    break;
                case 'scrollpitch':
                    timePitchScroll = (gUmt.UIParams.songTab[0].voice[UIVoice].symmetry[endTime].scrollbothParam * gUmt.loop[lpnum].score.songTab[0].voice[compositionVoice].randTilt.genrandReal1()) * (endTime - startTime);
                    break;
                case 'scrollboth':
                    timeRhythmScroll = (gUmt.UIParams.songTab[0].voice[UIVoice].symmetry[endTime].scrollbothParam * gUmt.loop[lpnum].score.songTab[0].voice[compositionVoice].randTilt.genrandReal1()) * (endTime - startTime);
                    timePitchScroll = timeRhythmScroll;
                    break;
                default:
                    umtJSabort("unrecognized symmetry pattern in composition: " + symmetryPattern);
                    break;
                }
                vcnum = compositionVoice;
                umtCopyAndTransform(lpnum, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
                startTime = 0;
                csrPos = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].cursor;
                csrStart = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[csrPos - 1].starttime;
                duration = gUmt.loop[lpnum].score.songTab[0].voice[vcnum].notes[csrPos - 1].duration;
                endTime = csrStart + duration;
            }
            compositionVoice = compositionVoice + 1;
        }
        UIVoice = UIVoice + 1;
    }
    umtHarmonizeScore(lpnum);
}

// composition algorithm demarcation

function umtExecTimerPulse() {
    "use strict";
    umtDoTimerPulse();
}

function umtExecAutomaticStart() {
    "use strict";
    if (gUmt.idemCompose === false) {
        umtComposeRealComposition(1);
        gUmt.idemCompose = true;
    }
    umtAutomaticStart(1);
}

function umtExecAutomaticStop() {
    "use strict";
    console.log(gUmt);
    umtAutomaticStop();
}

function umtDisableUI() {
    "use strict";
    window.document.getElementById("start_automatic").disabled = true;
    window.document.getElementById("stop_automatic").disabled = true;
}

function umtEnableUI() {
    "use strict";
    window.document.getElementById("start_automatic").disabled = false;
    window.document.getElementById("stop_automatic").disabled = false;
}

function umtAutomaticallyRecomposeLoopFromUIParams() {
    "use strict";
    var oldLoop, newLoop, startTime, stopTime, diffTime;
    if (gUmt.timerIsOn) {
        oldLoop = gUmt.currentlyPlayingLoop;
        newLoop = 1 - oldLoop;
        // old_tempoScalar = 60 / gUmt.loop[oldLoop].score.tempo;
        // old_offset = gUmt.loop[oldLoop].score.playbackTimeOffset;
    } else {
        return;
    }
    startTime = gUmt.globalCtx.currentTime;
    umtDisableUI();
    umtComposeRealComposition(newLoop);
    // new_tempoScalar = 60 / gUmt.loop[newLoop].score.tempo;
    // currentTime = gUmt.globalCtx.currentTime + old_offset;
    // current_units = currentTime / old_tempoScalar;
    // virtual_new_time = current_units * new_tempoScalar;
    // offset_difference = currentTime - virtual_new_time;
    // loopUnitLen = gUmt.loop[newLoop].score.songTab[0].voice[0].nextStart;
    // loopLen = loopUnitLen * new_tempoScalar;
    // offset_difference = offset_difference - (Math.floor(offset_difference / loopLen) * loopLen);  // modulo
    // gUmt.loop[newLoop].score.playbackTimeOffset = offset_difference;
    // gUmt.loop[newLoop].score.playbackTimeOffset = 0;
    umtAutomaticStart(newLoop);
    umtEnableUI();
    stopTime = gUmt.globalCtx.currentTime;
    diffTime = stopTime - startTime;
    gUmt.compositionLag = (gUmt.compositionLag + diffTime) / 2;
    window.document.getElementById("test_composition_time").value = diffTime;
    // umtCx("gUmt.compositionLag = " + umtCtstr(gUmt.compositionLag));
    // umtCx("gUmt.compositionLag = " + umtCtstr(gUmt.compositionLag));
}

function umtExecScaleChange() {
    "use strict";
    var listbox, scaleparam;
    listbox = window.document.getElementById("lb_scale");
    scaleparam = listbox.options[listbox.selectedIndex].value;
    gUmt.UIParams.scale = scaleparam;
    if (gUmt.idemAddingVoice === false) {
        umtAutomaticallyRecomposeLoopFromUIParams();
    }
}

function umtExecPlayVoiceChange(event) {
    "use strict";
    var elemid, UIVoiceNum, checkd;
    elemid = event.target.id;
    UIVoiceNum = Number(elemid.substring(9));
    checkd = document.getElementById(elemid).checked;
    gUmt.UIParams.songTab[0].voice[UIVoiceNum].playing = checkd;
    if (gUmt.idemAddingVoice === false) {
        umtAutomaticallyRecomposeLoopFromUIParams();
    }
    // document.getElementById("start_automatic").disabled = false;
    // document.getElementById("stop_automatic").disabled = false;
}

function umtExecSongNumberChange(event) {
    "use strict";
    var elemid, UIVoiceNum, listbox;
    elemid = event.target.id;
    UIVoiceNum = Number(elemid.substring(10));
    listbox = window.document.getElementById("songnumber" + UIVoiceNum);
    gUmt.UIParams.songTab[0].voice[UIVoiceNum].songNumber = Number(listbox.options[listbox.selectedIndex].value);
    if (gUmt.idemAddingVoice === false) {
        umtAutomaticallyRecomposeLoopFromUIParams();
    }
}

function umtUICreateClosureFunctionsForSymmetrySlidersOutsideALoop(voiceNumber, patternSize) {
    "use strict";
    jQuery("#slider_symmetry_transParam" + voiceNumber + "_" + patternSize).slider({min: 0, max: 10, step: 1, value: 10, orientation: "horizontal", change: function (event, ui) {
        var newvalue, patternDuration;
        // patternDuration and patternSize are two names for the same thing
        // but we have to use two different names so they will refer to
        // different variables and the closure will work
        patternDuration = patternSize;
        if (gUmt.idemAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value / 10;
                window.document.getElementById("display_symmetry_transParam" + voiceNumber + "_" + patternDuration).innerHTML = (newvalue * 100) + "%";
                gUmt.UIParams.songTab[0].voice[voiceNumber].symmetry[patternDuration].transParam = newvalue;
                if (gUmt.UIParams.songTab[0].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    jQuery("#slider_symmetry_scaleParam" + voiceNumber + "_" + patternSize).slider({min: 0, max: 24, step: 1, value: 12, orientation: "horizontal", change: function (event, ui) {
        var newvalue, patternDuration;
        patternDuration = patternSize;
        if (gUmt.idemAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = (ui.value - 12) / 10;
                window.document.getElementById("display_symmetry_scaleParam" + voiceNumber + "_" + patternDuration).innerHTML = (newvalue * 100) + "%";
                gUmt.UIParams.songTab[0].voice[voiceNumber].symmetry[patternDuration].scaleParam = newvalue;
                if (gUmt.UIParams.songTab[0].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    jQuery("#slider_symmetry_tiltParam" + voiceNumber + "_" + patternSize).slider({min: 0, max: 24, step: 1, value: 12, orientation: "horizontal", change: function (event, ui) {
        var newvalue, patternDuration;
        patternDuration = patternSize;
        if (gUmt.idemAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = (ui.value - 12) / 10;
                window.document.getElementById("display_symmetry_tiltParam" + voiceNumber + "_" + patternDuration).innerHTML = (newvalue * 100) + "%";
                gUmt.UIParams.songTab[0].voice[voiceNumber].symmetry[patternDuration].tiltParam = newvalue;
                if (gUmt.UIParams.songTab[0].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    jQuery("#slider_symmetry_scrollrhythmParam" + voiceNumber + "_" + patternSize).slider({min: 0, max: 10, step: 1, value: 10, orientation: "horizontal", change: function (event, ui) {
        var newvalue, patternDuration;
        patternDuration = patternSize;
        if (gUmt.idemAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value / 10;
                window.document.getElementById("display_symmetry_scrollrhythmParam" + voiceNumber + "_" + patternDuration).innerHTML = (newvalue * 100) + "%";
                gUmt.UIParams.songTab[0].voice[voiceNumber].symmetry[patternDuration].scrollrhythmParam = newvalue;
                if (gUmt.UIParams.songTab[0].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    jQuery("#slider_symmetry_scrollpitchParam" + voiceNumber + "_" + patternSize).slider({min: 0, max: 10, step: 1, value: 10, orientation: "horizontal", change: function (event, ui) {
        var newvalue, patternDuration;
        patternDuration = patternSize;
        if (gUmt.idemAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value / 10;
                window.document.getElementById("display_symmetry_scrollpitchParam" + voiceNumber + "_" + patternDuration).innerHTML = (newvalue * 100) + "%";
                gUmt.UIParams.songTab[0].voice[voiceNumber].symmetry[patternDuration].scrollpitchParam = newvalue;
                if (gUmt.UIParams.songTab[0].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    jQuery("#slider_symmetry_scrollbothParam" + voiceNumber + "_" + patternSize).slider({min: 0, max: 10, step: 1, value: 10, orientation: "horizontal", change: function (event, ui) {
        var newvalue, patternDuration;
        patternDuration = patternSize;
        if (gUmt.idemAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value / 10;
                window.document.getElementById("display_symmetry_scrollbothParam" + voiceNumber + "_" + patternDuration).innerHTML = (newvalue * 100) + "%";
                gUmt.UIParams.songTab[0].voice[voiceNumber].symmetry[patternDuration].scrollbothParam = newvalue;
                if (gUmt.UIParams.songTab[0].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
}

function umtUIShowOrHideAppropriateSymmetrySliders(symmetrySelected, suffix) {
    "use strict";
    var displayTrans, displayScale, displayTilt, displayScrollrhythm, displayScrollpitch, displayScrollboth;
    displayTrans = "none";
    displayScale = "none";
    displayTilt = "none";
    displayScrollrhythm = "none";
    displayScrollpitch = "none";
    displayScrollboth = "none";
    switch (symmetrySelected) {
    case 'trans':
        displayTrans = "block";
        break;
    case 'invert':
        break;
    case 'scale':
        displayScale = "block";
        break;
    case 'tilt':
        displayTilt = "block";
        break;
    case 'reverserhythm':
        break;
    case 'reversepitch':
        break;
    case 'reverseboth':
        break;
    case 'scrollrhythm':
        displayScrollrhythm = "block";
        break;
    case 'scrollpitch':
        displayScrollpitch = "block";
        break;
    case 'scrollboth':
        displayScrollboth = "block";
        break;
    default:
        umtJSabort("unrecognized symmetry selected: " + symmetrySelected);
        break;
    }
    window.document.getElementById("slider_symmetry_transParam" + suffix).style.display = displayTrans;
    window.document.getElementById("display_symmetry_transParam" + suffix).style.display = displayTrans;
    window.document.getElementById("slider_symmetry_scaleParam" + suffix).style.display = displayScale;
    window.document.getElementById("display_symmetry_scaleParam" + suffix).style.display = displayScale;
    window.document.getElementById("slider_symmetry_tiltParam" + suffix).style.display = displayTilt;
    window.document.getElementById("display_symmetry_tiltParam" + suffix).style.display = displayTilt;
    window.document.getElementById("slider_symmetry_scrollrhythmParam" + suffix).style.display = displayScrollrhythm;
    window.document.getElementById("display_symmetry_scrollrhythmParam" + suffix).style.display = displayScrollrhythm;
    window.document.getElementById("slider_symmetry_scrollpitchParam" + suffix).style.display = displayScrollpitch;
    window.document.getElementById("display_symmetry_scrollpitchParam" + suffix).style.display = displayScrollpitch;
    window.document.getElementById("slider_symmetry_scrollbothParam" + suffix).style.display = displayScrollboth;
    window.document.getElementById("display_symmetry_scrollbothParam" + suffix).style.display = displayScrollboth;
}

function umtExecPervoiceSymmetryChange(event) {
    "use strict";
    var elemid, listbox, selectedvalue, i, voiceNumber, symSize, symmetryPattern;
    elemid = event.target.id;
    listbox = event.target;
    selectedvalue = listbox.options[listbox.selectedIndex].value;
    elemid = elemid.substring(12);
    umtUIShowOrHideAppropriateSymmetrySliders(selectedvalue, elemid);
    i = elemid.indexOf("_");
    voiceNumber = elemid.substring(0, i);
    symSize = elemid.substring(i + 1);
    symmetryPattern = selectedvalue;
    gUmt.UIParams.songTab[0].voice[voiceNumber].symmetry[symSize].pattern = symmetryPattern;
    if (gUmt.UIParams.songTab[0].voice[voiceNumber].playing) {
        umtAutomaticallyRecomposeLoopFromUIParams();
    }
}

function umtUiTurnOnSymmetryPatterns(row, patternLabel, isOn) {
    "use strict";
    var suffix, block, inline;
    suffix = row + "_" + patternLabel;
    if (isOn) {
        block = "block";
        inline = "inline";
    } else {
        block = "none";
        inline = "none";
    }
    window.document.getElementById("display_symmetrylevel" + suffix).style.display = inline;
    window.document.getElementById("display_symmetrylevel" + suffix).innerHTML = patternLabel;
    window.document.getElementById("sel_symmetry" + suffix).style.display = inline;
    window.document.getElementById("slider_symmetry_transParam" + suffix).style.display = block;
    window.document.getElementById("display_symmetry_transParam" + suffix).style.display = block;
    window.document.getElementById("slider_symmetry_scaleParam" + suffix).style.display = block;
    window.document.getElementById("display_symmetry_scaleParam" + suffix).style.display = block;
    window.document.getElementById("slider_symmetry_tiltParam" + suffix).style.display = block;
    window.document.getElementById("display_symmetry_tiltParam" + suffix).style.display = block;
    window.document.getElementById("slider_symmetry_scrollrhythmParam" + suffix).style.display = block;
    window.document.getElementById("display_symmetry_scrollrhythmParam" + suffix).style.display = block;
    window.document.getElementById("slider_symmetry_scrollpitchParam" + suffix).style.display = block;
    window.document.getElementById("display_symmetry_scrollpitchParam" + suffix).style.display = block;
    window.document.getElementById("slider_symmetry_scrollbothParam" + suffix).style.display = block;
    window.document.getElementById("display_symmetry_scrollbothParam" + suffix).style.display = block;
}

function umtUiSetSymmetryListboxAndSlider(row, patternDuration) {
    "use strict";
    var suffix, absvalue, slidervalue;
    suffix = row + "_" + patternDuration;
    window.document.getElementById("sel_symmetry" + suffix).value = gUmt.UIParams.songTab[0].voice[row].symmetry[patternDuration].pattern;
    // trans param
    absvalue = gUmt.UIParams.songTab[0].voice[row].symmetry[patternDuration].transParam;
    slidervalue = absvalue * 10;
    window.document.getElementById("display_symmetry_transParam" + suffix).innerHTML = (absvalue * 100) + "%";
    jQuery("#slider_symmetry_transParam" + suffix).slider({ value: slidervalue });
    // scale param
    absvalue = gUmt.UIParams.songTab[0].voice[row].symmetry[patternDuration].scaleParam;
    slidervalue = (absvalue * 10) + 12;
    window.document.getElementById("display_symmetry_scaleParam" + suffix).innerHTML = (absvalue * 100) + "%";
    jQuery("#slider_symmetry_scaleParam" + suffix).slider({ value: slidervalue });
    // tilt param
    absvalue = gUmt.UIParams.songTab[0].voice[row].symmetry[patternDuration].tiltParam;
    slidervalue = (absvalue * 10) + 12;
    window.document.getElementById("display_symmetry_tiltParam" + suffix).innerHTML = (absvalue * 100) + "%";
    jQuery("#slider_symmetry_tiltParam" + suffix).slider({ value: slidervalue });
    // scrollrhythm param
    absvalue = gUmt.UIParams.songTab[0].voice[row].symmetry[patternDuration].scrollrhythmParam;
    slidervalue = absvalue * 10;
    window.document.getElementById("display_symmetry_scrollrhythmParam" + suffix).innerHTML = (absvalue * 100) + "%";
    jQuery("#slider_symmetry_scrollrhythmParam" + suffix).slider({ value: slidervalue });
    // scrollpitch param
    absvalue = gUmt.UIParams.songTab[0].voice[row].symmetry[patternDuration].scrollpitchParam;
    slidervalue = absvalue * 10;
    window.document.getElementById("display_symmetry_scrollpitchParam" + suffix).innerHTML = (absvalue * 100) + "%";
    jQuery("#slider_symmetry_scrollpitchParam" + suffix).slider({ value: slidervalue });
    // scrollboth param
    absvalue = gUmt.UIParams.songTab[0].voice[row].symmetry[patternDuration].scrollbothParam;
    slidervalue = absvalue * 10;
    window.document.getElementById("display_symmetry_scrollbothParam" + suffix).innerHTML = (absvalue * 100) + "%";
    jQuery("#slider_symmetry_scrollbothParam" + suffix).slider({ value: slidervalue });
}

var umtUiCascadeFrameSizeChanges, umtUiCascadeChunkSizeChanges, umtUiCascadeMinNoteChanges;

umtUiCascadeFrameSizeChanges = function (voiceNumber, newvalue) {
    "use strict";
    var chunkSize, loopDuration, symSize, slidervalue, symmetryPattern;
    chunkSize = gUmt.UIParams.songTab[0].voice[voiceNumber].chunkSize;
    if (newvalue < chunkSize) {
        chunkSize = newvalue;
        slidervalue = Math.floor((Math.log(chunkSize) / Math.log(2)) + 0.01);
        jQuery("#slider_chunksize" + voiceNumber).slider({ value: slidervalue });
        window.document.getElementById("display_chunksize" + voiceNumber).innerHTML = newvalue;
        gUmt.UIParams.songTab[0].voice[voiceNumber].chunkSize = chunkSize;
        // umtCx("voiceNumber" + umtCtstr(voiceNumber) + " chunkSize" + umtCtstr(chunkSize));
        umtUiCascadeChunkSizeChanges(voiceNumber, chunkSize);
    }
    loopDuration = gUmt.UIParams.loopDuration;
    symSize = 1;
    while (symSize < loopDuration) {
        if (symSize < newvalue) {
            umtUiTurnOnSymmetryPatterns(voiceNumber, symSize, false);
        } else {
            umtUiSetSymmetryListboxAndSlider(voiceNumber, symSize);
            umtUiTurnOnSymmetryPatterns(voiceNumber, symSize, true);
            symmetryPattern = gUmt.UIParams.songTab[0].voice[voiceNumber].symmetry[symSize].pattern;
            umtUIShowOrHideAppropriateSymmetrySliders(symmetryPattern, voiceNumber + "_" + symSize);
        }
        symSize = symSize * 2;
    }
};

umtUiCascadeChunkSizeChanges = function (voiceNumber, newvalue) {
    "use strict";
    var minNote, frameSize, slidervalue;
    minNote = gUmt.UIParams.songTab[0].voice[voiceNumber].minNote;
    if (newvalue < minNote) {
        minNote = newvalue;
        slidervalue = Math.floor((Math.log(minNote) / Math.log(2)) + 0.01);
        jQuery("#slider_minnote" + voiceNumber).slider({ value: slidervalue });
        window.document.getElementById("display_minnote" + voiceNumber).innerHTML = newvalue;
        gUmt.UIParams.songTab[0].voice[voiceNumber].minNote = minNote;
        umtUiCascadeMinNoteChanges(voiceNumber, minNote);
    }
    frameSize = gUmt.UIParams.songTab[0].voice[voiceNumber].frameSize;
    if (newvalue > frameSize) {
        frameSize = newvalue;
        slidervalue = Math.floor((Math.log(frameSize) / Math.log(2)) + 0.01);
        jQuery("#slider_framesize" + voiceNumber).slider({ value: slidervalue });
        window.document.getElementById("display_framesize" + voiceNumber).innerHTML = newvalue;
        gUmt.UIParams.songTab[0].voice[voiceNumber].frameSize = frameSize;
        umtUiCascadeFrameSizeChanges(voiceNumber, frameSize);
    }
};

umtUiCascadeMinNoteChanges = function (voiceNumber, newvalue) {
    "use strict";
    var chunkSize, slidervalue;
    chunkSize = gUmt.UIParams.songTab[0].voice[voiceNumber].chunkSize;
    if (newvalue > chunkSize) {
        chunkSize = newvalue;
        slidervalue = Math.floor((Math.log(chunkSize) / Math.log(2)) + 0.01);
        jQuery("#slider_chunksize" + voiceNumber).slider({ value: slidervalue });
        window.document.getElementById("display_chunksize" + voiceNumber).innerHTML = newvalue;
        gUmt.UIParams.songTab[0].voice[voiceNumber].chunkSize = chunkSize;
        umtUiCascadeChunkSizeChanges(voiceNumber, chunkSize);
    }
};

function umtExecInstrumentChange() {
    "use strict";
    var elemid, UIVoiceNum, listbox;
    elemid = event.target.id;
    UIVoiceNum = Number(elemid.substring(10));
    listbox = window.document.getElementById("instrument" + UIVoiceNum);
    gUmt.UIParams.songTab[0].voice[UIVoiceNum].instrument = listbox.options[listbox.selectedIndex].value;
    if (gUmt.idemAddingVoice === false) {
        umtAutomaticallyRecomposeLoopFromUIParams();
    }
}

function umtUiAddRow(voiceNumber) {
    "use strict";
    var text, i, displayNumber, columnidlist, idx, cellidname, j, rowcontent, y, yyy, currentrowhtml, listenElement;
    jQuery('#voices_table > tbody:last').append('<tr id="voice_row_' + voiceNumber + '"><td id="voicedescriptcell' + voiceNumber + '" valign="top"> Voice Description Cell ' + voiceNumber + '</td></td><td id="voiceplaycell' + voiceNumber + '" valign="top"></td></td><td id="voiceinstrumentcell' + voiceNumber + '" valign="top"><td id="voicevolumecell' + voiceNumber + '" valign="top"></td><td id="voicesongnumcell' + voiceNumber + '" valign="top" align="center"></td><td id="voiceoctavecell' + voiceNumber + '" valign="top" align="center"></td><td id="voicenotedistcell' + voiceNumber + '" valign="top" align="center"></td><td id="voicerestynesscell' + voiceNumber + '" valign="top" align="center"></td><td id="voiceampvariationcell' + voiceNumber + '" valign="top" align="center"></td><td id="voiceminnotecell' + voiceNumber + '" valign="top" align="center"></td><td id="voicechunksizecell' + voiceNumber + '" valign="top" align="center"></td><td id="voiceframesizecell' + voiceNumber + '" valign="top" align="center"></td><td id="voicesymmetriescell' + voiceNumber + '" valign="top" align="center"></td></tr>');
    text = document.getElementById("voicedescriptcellxx").innerHTML;
    displayNumber = voiceNumber + 1;
    i = text.indexOf("XX");
    text = text.substring(0, i) + displayNumber + text.substring(i + 2);
    document.getElementById("voicedescriptcell" + voiceNumber).innerHTML = text;
    columnidlist = ["voiceplaycell", "voiceinstrumentcell", "voicevolumecell", "voicesongnumcell", "voiceoctavecell", "voicenotedistcell", "voicerestynesscell", "voiceampvariationcell", "voiceminnotecell", "voicechunksizecell", "voiceframesizecell", "voicesymmetriescell"];
    for (idx in columnidlist) {
        if (columnidlist.hasOwnProperty(idx)) {
            cellidname = columnidlist[idx];
            text = document.getElementById(cellidname + "xx").innerHTML;
            i = text.indexOf("xx");
            while (i >= 0) {
                text = text.substring(0, i) + voiceNumber + text.substring(i + 2);
                i = text.indexOf("xx");
            }
            if (cellidname === "voicesymmetriescell") {
                i = text.indexOf("<tr>");
                j = text.indexOf("</tr>");
                rowcontent = text.substring(i, j + 6);
                text = text.substring(0, i) + text.substring(j + 5); // cut
                for (y = 0; y < 10; y = y + 1) {
                    currentrowhtml = rowcontent;
                    i = currentrowhtml.indexOf("yyy");
                    while (i >= 0) {
                        yyy = Math.pow(2, y);
                        currentrowhtml = currentrowhtml.substring(0, i) + yyy + currentrowhtml.substring(i + 3);
                        i = currentrowhtml.indexOf("yyy");
                    }
                    i = text.indexOf("<!-- insertion_point -->");
                    text = text.substring(0, i) + currentrowhtml + text.substring(i); // paste
                }
            }
            document.getElementById(cellidname + voiceNumber).innerHTML = text;
        }
    }
    listenElement = document.getElementById("playvoice" + voiceNumber);
    listenElement.addEventListener("change", umtExecPlayVoiceChange, true);
    listenElement = document.getElementById("instrument" + voiceNumber);
    listenElement.addEventListener("change", umtExecInstrumentChange, true);
    listenElement = document.getElementById("songnumber" + voiceNumber);
    listenElement.addEventListener("change", umtExecSongNumberChange, true);
    jQuery("#slider_volume" + voiceNumber).slider({min: 0, max: 10, step: 1, value: 5, orientation: "vertical", change: function (event, ui) {
        var newvalue, absvalue, aspercentage;
        if (gUmt.idemAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                absvalue = newvalue / 10;
                aspercentage = newvalue * 10;
                window.document.getElementById("display_volume" + voiceNumber).innerHTML = aspercentage + "%";
                gUmt.UIParams.songTab[0].voice[voiceNumber].volume = absvalue;
                if (gUmt.UIParams.songTab[0].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    jQuery("#slider_octave" + voiceNumber).slider({min: 0, max: 9, step: 1, value: 5, orientation: "vertical", change: function (event, ui) {
        var newvalue;
        if (gUmt.idemAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                window.document.getElementById("display_octave" + voiceNumber).innerHTML = newvalue;
                gUmt.UIParams.songTab[0].voice[voiceNumber].octave = newvalue;
                if (gUmt.UIParams.songTab[0].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    jQuery("#slider_notedistance" + voiceNumber).slider({min: 0, max: 10, step: 1, value: 5, orientation: "vertical", change: function (event, ui) {
        var newvalue, absvalue, aspercentage;
        if (gUmt.idemAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                absvalue = newvalue / 10;
                aspercentage = newvalue * 10;
                window.document.getElementById("display_notedistance" + voiceNumber).innerHTML = aspercentage + "%";
                gUmt.UIParams.songTab[0].voice[voiceNumber].noteDistance = absvalue;
                if (gUmt.UIParams.songTab[0].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    jQuery("#slider_restyness" + voiceNumber).slider({min: 0, max: 10, step: 1, value: 0, orientation: "vertical", change: function (event, ui) {
        var newvalue, absvalue, aspercentage;
        if (gUmt.idemAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                absvalue = newvalue / 10;
                aspercentage = newvalue * 10;
                window.document.getElementById("display_restyness" + voiceNumber).innerHTML = aspercentage + "%";
                gUmt.UIParams.songTab[0].voice[voiceNumber].restyness = absvalue;
                if (gUmt.UIParams.songTab[0].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    jQuery("#slider_ampvariation" + voiceNumber).slider({min: 0, max: 10, step: 1, value: 0, orientation: "vertical", change: function (event, ui) {
        var newvalue, absvalue, aspercentage;
        if (gUmt.idemAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                absvalue = newvalue / 10;
                aspercentage = newvalue * 10;
                window.document.getElementById("display_ampvariation" + voiceNumber).innerHTML = aspercentage + "%";
                gUmt.UIParams.songTab[0].voice[voiceNumber].ampVariation = absvalue;
                if (gUmt.UIParams.songTab[0].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    jQuery("#slider_minnote" + voiceNumber).slider({min: 0, max: 7, step: 1, value: 3, orientation: "vertical", change: function (event, ui) {
        var newvalue;
        if (gUmt.idemAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                newvalue = Math.pow(2, newvalue);
                window.document.getElementById("display_minnote" + voiceNumber).innerHTML = newvalue;
                gUmt.UIParams.songTab[0].voice[voiceNumber].minNote = newvalue;
                gUmt.idemAddingVoice = true;
                umtUiCascadeMinNoteChanges(voiceNumber, newvalue);
                gUmt.idemAddingVoice = false;
                if (gUmt.UIParams.songTab[0].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    jQuery("#slider_chunksize" + voiceNumber).slider({min: 0, max: 7, step: 1, value: 3, orientation: "vertical", change: function (event, ui) {
        var newvalue;
        if (gUmt.idemAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                newvalue = Math.pow(2, newvalue);
                window.document.getElementById("display_chunksize" + voiceNumber).innerHTML = newvalue;
                gUmt.UIParams.songTab[0].voice[voiceNumber].chunkSize = newvalue;
                gUmt.idemAddingVoice = true;
                umtUiCascadeChunkSizeChanges(voiceNumber, newvalue);
                gUmt.idemAddingVoice = false;
                if (gUmt.UIParams.songTab[0].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    jQuery("#slider_framesize" + voiceNumber).slider({min: 0, max: 7, step: 1, value: 3, orientation: "vertical", change: function (event, ui) {
        // BUGBUG: Important -- the max value needs to me MANUALLY sync'd with the loop size -- this needs to be fixed to be computed!
        var newvalue;
        if (gUmt.idemAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                newvalue = Math.pow(2, newvalue);
                window.document.getElementById("display_framesize" + voiceNumber).innerHTML = newvalue;
                gUmt.UIParams.songTab[0].voice[voiceNumber].frameSize = newvalue;
                gUmt.idemAddingVoice = true;
                umtUiCascadeFrameSizeChanges(voiceNumber, newvalue);
                gUmt.idemAddingVoice = false;
                if (gUmt.UIParams.songTab[0].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    for (y = 0; y < 10; y = y + 1) {
        yyy = Math.pow(2, y);
        listenElement = document.getElementById("sel_symmetry" + voiceNumber + "_" + yyy);
        listenElement.addEventListener("change", umtExecPervoiceSymmetryChange, true);
        umtUICreateClosureFunctionsForSymmetrySlidersOutsideALoop(voiceNumber, yyy);
    }
}

function umtUiSetListboxByValue(listbox, value) {
    "use strict";
    var options, i, valstr;
    options = listbox.options;
    valstr = value.toString();
    for (i = 0; i < options.length; i = i + 1) {
        if (options[i].value === valstr) {
            options[i].selected = true;
        }
    }
}

function umtUiCopyUiParamsToActualUi() {
    "use strict";
    var parts, i, absvalue, slidervalue, loopDuration, j, k, howeverMany, symSize, symNum, symmetryPattern;
    gUmt.idemAddingVoice = true;
    parts = gUmt.UIParams.parts;
    for (i = 0; i < parts; i = i + 1) {
        if (!umtUIIsPartInUI(i)) {
            umtUiAddRow(i);
        }
        if (i > gUmt.UIParams.maxPartsEver) {
            gUmt.UIParams.maxPartsEver = i;
        }
    }
    for (i = parts; i <= gUmt.UIParams.maxPartsEver; i = i + 1) {
        if (umtUIIsPartInUI(i)) {
            jQuery("#the_part").remove();
        }
    }
    loopDuration = gUmt.UIParams.loopDuration;
    for (i = 0; i < parts; i = i + 1) {
        // checkbox
        if (gUmt.UIParams.songTab[0].voice[i].playing) {
            document.getElementById("playvoice" + i).checked = true;
        } else {
            document.getElementById("playvoice" + i).checked = false;
        }
        // instrument
        umtUiSetListboxByValue(document.getElementById("instrument" + i), gUmt.UIParams.songTab[0].voice[i].instrument);
        // song number
        umtUiSetListboxByValue(document.getElementById("songnumber" + i), gUmt.UIParams.songTab[0].voice[i].songNumber);
        // volume
        absvalue = gUmt.UIParams.songTab[0].voice[i].volume;
        window.document.getElementById("display_volume" + i).innerHTML = (absvalue * 100) + "%";
        slidervalue = absvalue * 10;
        jQuery("#slider_volume" + i).slider({ value: slidervalue });
        // octave
        absvalue = gUmt.UIParams.songTab[0].voice[i].octave;
        window.document.getElementById("display_octave" + i).innerHTML = absvalue;
        slidervalue = absvalue;
        jQuery("#slider_octave" + i).slider({ value: slidervalue });
        // note distance
        absvalue = gUmt.UIParams.songTab[0].voice[i].noteDistance;
        window.document.getElementById("display_notedistance" + i).innerHTML = (absvalue * 100) + "%";
        slidervalue = absvalue * 10;
        jQuery("#slider_notedistance" + i).slider({ value: slidervalue });
        // restyness
        absvalue = gUmt.UIParams.songTab[0].voice[i].restyness;
        window.document.getElementById("display_restyness" + i).innerHTML = (absvalue * 100) + "%";
        slidervalue = absvalue * 10;
        jQuery("#slider_restyness" + i).slider({ value: slidervalue });
        // amplitude variation
        absvalue = gUmt.UIParams.songTab[0].voice[i].ampVariation;
        window.document.getElementById("display_ampvariation" + i).innerHTML = (absvalue * 100) + "%";
        slidervalue = absvalue * 10;
        jQuery("#slider_ampvariation" + i).slider({ value: slidervalue });
        // min note
        absvalue = gUmt.UIParams.songTab[0].voice[i].minNote;
        window.document.getElementById("display_minnote" + i).innerHTML = absvalue;
        slidervalue = Math.floor((Math.log(absvalue) / Math.log(2)) + 0.01);
        jQuery("#slider_minnote" + i).slider({ value: slidervalue });
        // chunk size
        absvalue = gUmt.UIParams.songTab[0].voice[i].chunkSize;
        window.document.getElementById("display_chunksize" + i).innerHTML = absvalue;
        slidervalue = Math.floor((Math.log(absvalue) / Math.log(2)) + 0.01);
        jQuery("#slider_chunksize" + i).slider({ value: slidervalue });
        // frame size
        absvalue = gUmt.UIParams.songTab[0].voice[i].frameSize;
        window.document.getElementById("display_framesize" + i).innerHTML = absvalue;
        slidervalue = Math.floor((Math.log(absvalue) / Math.log(2)) + 0.01);
        jQuery("#slider_framesize" + i).slider({ value: slidervalue });
        // symmetry patterns and parameters
        howeverMany = Math.floor((Math.log(loopDuration) / Math.log(2)) + 0.01);
        k = 1;
        for (j = 0; j < howeverMany; j = j + 1) {
            umtUiTurnOnSymmetryPatterns(i, k, false);
            k = k * 2;
        }
        symSize = gUmt.UIParams.songTab[0].voice[i].frameSize;
        symNum = Math.floor((Math.log(symSize) / Math.log(2)) + 0.01);
        while (symSize < loopDuration) {
            umtUiTurnOnSymmetryPatterns(i, symSize, true);
            umtUiSetSymmetryListboxAndSlider(i, symSize);
            symmetryPattern = gUmt.UIParams.songTab[0].voice[i].symmetry[symSize].pattern;
            // symmetry listbox
            umtUiSetListboxByValue(document.getElementById("sel_symmetry" + i + "_" + symSize), symmetryPattern);
            umtUIShowOrHideAppropriateSymmetrySliders(symmetryPattern, i + "_" + symSize);
            symSize = symSize * 2;
            symNum = symNum + 1;
        }
    }
    gUmt.idemAddingVoice = false;
}

function umtExecAddVoice() {
    "use strict";
    var voiceNum, songnum;
    voiceNum = gUmt.UIParams.parts;
    songnum = voiceNum + 1;
    gUmt.UIParams.songTab[0].voice[voiceNum] = {playing: false, instrument: "tuningfork", volume: 1.0, songNumber: songnum, octave: 5, noteDistance: 0.3, restyness: 0.0, ampVariation: 0.9, minNote: 4, chunkSize: 4, frameSize: 32, symmetry: { 1: {pattern: "trans", transParam: 0, scaleParam: 0, tiltParam: 0, scrollrhythmParam: 0, scrollpitchParam: 0, scrollbothParam: 0}, 2: {pattern: "trans", transParam: 0, scaleParam: 0, tiltParam: 0, scrollrhythmParam: 0, scrollpitchParam: 0, scrollbothParam: 0}, 4: {pattern: "trans", transParam: 0, scaleParam: 0, tiltParam: 0, scrollrhythmParam: 0, scrollpitchParam: 0, scrollbothParam: 0}, 8: {pattern: "trans", transParam: 0, scaleParam: 0, tiltParam: 0, scrollrhythmParam: 0, scrollpitchParam: 0, scrollbothParam: 0}, 16: {pattern: "trans", transParam: 0, scaleParam: 0, tiltParam: 0, scrollrhythmParam: 0, scrollpitchParam: 0, scrollbothParam: 0}, 32: {pattern: "trans", transParam: 0, scaleParam: 0, tiltParam: 0, scrollrhythmParam: 0, scrollpitchParam: 0, scrollbothParam: 0}, 64: {pattern: "trans", transParam: 0, scaleParam: 0, tiltParam: 0, scrollrhythmParam: 0, scrollpitchParam: 0, scrollbothParam: 0}, 128: {pattern: "trans", transParam: 0, scaleParam: 0, tiltParam: 0, scrollrhythmParam: 0, scrollpitchParam: 0, scrollbothParam: 0}, 256: {pattern: "trans", transParam: 0, scaleParam: 0, tiltParam: 0, scrollrhythmParam: 0, scrollpitchParam: 0, scrollbothParam: 0}, 512: {pattern: "trans", transParam: 0, scaleParam: 0, tiltParam: 0, scrollrhythmParam: 0, scrollpitchParam: 0, scrollbothParam: 0}, 1024: {pattern: "trans", transParam: 0, scaleParam: 0, tiltParam: 0, scrollrhythmParam: 0, scrollpitchParam: 0, scrollbothParam: 0} } };
    gUmt.UIParams.parts = gUmt.UIParams.parts + 1;
    if (gUmt.UIParams.parts > gUmt.UIParams.maxPartsEver) {
        gUmt.UIParams.maxPartsEver = gUmt.UIParams.parts;
    }
    umtUiCopyUiParamsToActualUi();
}

function umtExecTestDumtGmt() {
    "use strict";
    // umtCx("gUmt = " + ctstr(gUmt));
    console.log(gUmt);
}

function umtExecReSeed() {
    "use strict";
    console.log("called umtExecReSeed");
}

// main

gUmt = {SAMPLERATE: 44100, TAU: Math.PI * 2, LOG2: Math.log(2), globalCtx: umtGetAudioContext(), globalRng: umtGetRando(0), cachedNotes: {}, instrumentBank: {}, cachedFittings: {}, loop: [ { score: {tempo: 700, centernoteLog: (Math.log(432) / Math.log(2)) - 5, songTab: [ { voice: [] } ] } } ], playedUpTo: 0, timerIsOn: false, currentlyPlayingLoop: 0, compositionLag: 0, idemCompose: false, idemAddingVoice: false, UIParams: { tempo: 360, scale: 'maj7reg', centernote: 432, parts: 0, songTab: [ { voice: [] } ], loopDuration: 128 }, maxPartsEver: 4 };

console.log(gUmt);

jQuery(function () {
    "use strict";
    jQuery("#slider_tempo").slider({min: 60, max: 960, step: 30, value: 360, orientation: "horizontal", change: function (event, ui) {
        var newvalue;
        if (gUmt.idemAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                window.document.getElementById("display_tempo_value").innerHTML = newvalue;
                gUmt.UIParams.tempo = newvalue;
                umtAutomaticallyRecomposeLoopFromUIParams();
            }
        }
    }
         });
    jQuery("#slider_centernote").slider({min: 1, max: 9, step: 1, value: 5, orientation: "horizontal", change: function (event, ui) {
        var newvalue;
        if (gUmt.idemAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                newvalue = Math.pow(2, (newvalue - 5) / 12) * 432;
                window.document.getElementById("display_centernote_value").innerHTML = newvalue;
                gUmt.UIParams.centernote = newvalue;
                umtAutomaticallyRecomposeLoopFromUIParams();
            }
        }
    }
         });
    umtCreateInstrumentBank();
    umtExecAddVoice();
    document.getElementById("playvoice0").checked = true;
    gUmt.UIParams.songTab[0].voice[0].playing = true;
    umtExecAutomaticStart();
});

</script>

</head>
<body>
  <section>
    <h1>UMT: The Ultimate Music Toy</h1>

<hr />

<p> Stuff that applies to whole score </p>

<p>
    <input type="button" id="start_automatic" value="Start Music" />
    <input type="button" id="stop_automatic" value="Stop Music" />
    <input type="button" id="test_play_raw" value="Test Play Raw" />
    <input type="button" id="test_dump_gumt" value="Test Dump gUmt" />
    <input type="button" id="test_symmetry_system" value="Test Symmetry System" />
    Composition time (RA) <input type="text" id="test_composition_time" value="0" />
</p>

<p> Scale:

<select id="lb_scale">
    <option value="chroma13">Chromatic 13 (alt)</option>
    <option value="chroma11regreg">Chromatic 11</option>
    <option value="minharm7reg">Minor Harmonic 7</option>
    <option value="minnat7regreg">Minor Natural 7</option>
    <option value="maj7reg" selected="selected">Major 7</option>
    <option value="pentatonic32reg">Pentatonic 5 (3+2)</option>
    <option value="pentatonic23reg">Pentatonic 5 (2+3 standard)</option>
    <option value="quad">Quadtonic 4</option>
    <option value="tri">Tritonic 3</option>
</select>

</p>

<p> Tempo: 

<div id="slider_tempo" class="ddrg" style="width:200px;"></div>

<div id="display_tempo_value">360</div>

</p>

<p> Center note (tonic/key):

<div id="slider_centernote" class="ddrg" style="width:200px;"></div>

<div id="display_centernote_value">432</div>

</p>

<input type="button" id="reseed" value="Re-randomize" />

<hr />

<div id="voice_template" style="display:none;" >
	<p><b>This is the template row</b></p>
	<table border="0">
		<tr>
			<td id="voicedescriptcellxx" valign="top">
				Voice #XX
			</td><td id="voiceplaycellxx" valign="top">
				Play
				<br />
				<input type="checkbox" name="playvoicexx" id="playvoicexx">
			</td><td id="voicevolumecellxx" valign="top" align="center">
				Volume: <br />
				<div id="slider_volumexx" class="ddrg" style="height:100px;"></div> <br />
				<div id="display_volumexx"></div>
			</td><td id="voiceinstrumentcellxx" valign="top" align="center">
				Instrument: <br />
				<select name="instrumentxx" id="instrumentxx">
					<option value="tuningfork">Sine wave</option>
					<option value="squarewave">Square wave</option>
					<option value="squarevar">Var square wave</option>
					<option value="noise">Noise</option>
				</select>
			</td><td id="voicesongnumcellxx" valign="top" align="center">
				Song Number: <br />
				<select name="songnumberxx" id="songnumberxx">
					<option value="1">1</option>
					<option value="2">2</option>
					<option value="3">3</option>
					<option value="4">4</option>
					<option value="5">5</option>
					<option value="6">6</option>
					<option value="7">7</option>
					<option value="8">8</option>
					<option value="9">9</option>
					<option value="10">10</option>
					<option value="11">11</option>
					<option value="12">12</option>
					<option value="13">13</option>
					<option value="14">14</option>
					<option value="15">15</option>
					<option value="16">16</option>
					<option value="17">17</option>
					<option value="18">18</option>
					<option value="19">19</option>
					<option value="20">20</option>
					<option value="21">21</option>
					<option value="22">22</option>
					<option value="23">23</option>
					<option value="24">24</option>
					<option value="25">25</option>
					<option value="26">26</option>
					<option value="27">27</option>
					<option value="28">28</option>
					<option value="29">29</option>
					<option value="30">30</option>
					<option value="31">31</option>
					<option value="32">32</option>
					<option value="33">33</option>
					<option value="34">34</option>
					<option value="35">35</option>
					<option value="36">36</option>
					<option value="37">37</option>
					<option value="38">38</option>
					<option value="39">39</option>
					<option value="40">40</option>
					<option value="41">41</option>
					<option value="42">42</option>
					<option value="43">43</option>
					<option value="44">44</option>
					<option value="45">45</option>
					<option value="46">46</option>
					<option value="47">47</option>
					<option value="48">48</option>
					<option value="49">49</option>
					<option value="50">50</option>
				</select>
			</td><td id="voiceoctavecellxx" valign="top" align="center">
				Octave: <br />
				<div id="slider_octavexx" class="ddrg" style="height:100px;"></div> <br />
				<div id="display_octavexx"></div>
			</td><td id="voicenotedistcellxx" valign="top" align="center">
				Note Distance:<br />
				<div id="slider_notedistancexx" class="ddrg" style="height:100px;"></div> <br />
				<div id="display_notedistancexx"></div>
			</td><td id="voicerestynesscellxx" valign="top" align="center">
				Restyness:<br />
				<div id="slider_restynessxx" class="ddrg" style="height:100px;"></div> <br />
				<div id="display_restynessxx"></div>
			</td><td id="voiceampvariationcellxx" valign="top" align="center">
				Ampl. Var.:<br />
				<div id="slider_ampvariationxx" class="ddrg" style="height:100px;"></div> <br />
				<div id="display_ampvariationxx"></div>
			</td><td id="voiceminnotecellxx" valign="top" align="center">
				Min Note:<br />
				<div id="slider_minnotexx" class="ddrg" style="height:100px;"></div> <br />
				<div id="display_minnotexx"></div>
			</td><td id="voicechunksizecellxx" valign="top" align="center">
				Max Note:<br />
				<div id="slider_chunksizexx" class="ddrg" style="height:100px;"></div> <br />
				<div id="display_chunksizexx"></div>
			</td><td id="voiceframesizecellxx" valign="top" align="center">
				Frame Size:<br />
				<div id="slider_framesizexx" class="ddrg" style="height:100px;"></div> <br />
				<div id="display_framesizexx"></div>
			</td><td id="voicesymmetriescellxx" valign="top" align="center">
				Symmetry Patterns: <br />
				<table border="0">
					<tr>
						<td valign="center" align="right">
							<span id="display_symmetrylevelxx_yyy" style="display:none;">1</span>
						</td><td valign="top">
							<select name="sel_symmetryxx_yyy" id="sel_symmetryxx_yyy" style="display:none;">
								<option value="trans">Transpose</option>
								<option value="invert">Invert</option>
								<option value="scale">Scale</option>
								<option value="tilt">Tilt</option>
								<option value="reverseboth">Reverse</option>
								<option value="reverserhythm">Reverse-rhythm</option>
								<option value="reversepitch">Reverse-pitch</option>
								<option value="scrollboth">Scroll</option>
								<option value="scrollrhythm">Scroll-rhythm</option>
								<option value="scrollpitch">Scroll-pitch</option>
							</select>
						</td><td valign="top" align="center">
							<div id="slider_symmetry_transParamxx_yyy" class="ddrg" style="width:100px;display:none;"></div>
							<span id="display_symmetry_transParamxx_yyy" style="display:none;">readout</span>
							<div id="slider_symmetry_scaleParamxx_yyy" class="ddrg" style="width:100px;display:none;"></div>
							<span id="display_symmetry_scaleParamxx_yyy" style="display:none;">readout</span>
							<div id="slider_symmetry_tiltParamxx_yyy" class="ddrg" style="width:100px;display:none;"></div>
							<span id="display_symmetry_tiltParamxx_yyy" style="display:none;">readout</span>
							<div id="slider_symmetry_scrollrhythmParamxx_yyy" class="ddrg" style="width:100px;display:none;"></div>
							<span id="display_symmetry_scrollrhythmParamxx_yyy" style="display:none;">readout</span>
							<div id="slider_symmetry_scrollpitchParamxx_yyy" class="ddrg" style="width:100px;display:none;"></div>
							<span id="display_symmetry_scrollpitchParamxx_yyy" style="display:none;">readout</span>
							<div id="slider_symmetry_scrollbothParamxx_yyy" class="ddrg" style="width:100px;display:none;"></div>
							<span id="display_symmetry_scrollbothParamxx_yyy" style="display:none;">readout</span>
						</td>
					</tr>
					<!-- insertion_point -->
				</table>
			</td>
		</tr>
	</table>
</div>

<div id="voices_section">
	<table id="voices_table" border="0">
		<tbody>
		</tbody>
	</table>
</div>

<input id="add_voice" type="button" value="Add a voice" />

<div id="darkLayer" class="darkClass" style="display:none"></div>

  </section>
<script>

var umtListenElement = document.getElementById("start_automatic");
umtListenElement.addEventListener("click", umtExecAutomaticStart, true);

umtListenElement = document.getElementById("stop_automatic");
umtListenElement.addEventListener("click", umtExecAutomaticStop, true);

umtListenElement = document.getElementById("lb_scale");
umtListenElement.addEventListener("change", umtExecScaleChange, true);

var umtListenElement = document.getElementById("reseed");
umtListenElement.addEventListener("click", umtExecReSeed, true);

umtListenElement = document.getElementById("add_voice");
umtListenElement.addEventListener("click", umtExecAddVoice, true);

umtListenElement = document.getElementById("test_play_raw");
umtListenElement.addEventListener("click", umtExecPlayRawScore, true);

umtListenElement = document.getElementById("test_dump_gumt");
umtListenElement.addEventListener("click", umtExecTestDumtGmt, true);

umtListenElement = document.getElementById("test_symmetry_system");
umtListenElement.addEventListener("click", umtTestSetupCopyTransTestSection, true);

</script>

</body>
</html>
