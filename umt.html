<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8 />
<title>Ultimate Music Toy</title>
<link rel="stylesheet" href="jquery-ui.css" />
<script src="jquery-1.10.2.js"></script>
<script src="jquery-ui.js"></script>
<link rel="stylesheet" href="style.css" />
  <style>
  #dialog label, #dialog input { display:block; }
  #dialog label { margin-top: 0.5em; }
  #dialog input, #dialog textarea { width: 95%; }
  #tabs { margin-top: 1em; }
  #tabs li .ui-icon-close { float: left; margin: 0.4em 0.2em 0 0; cursor: pointer; }
  #add_tab { cursor: pointer; }
  </style>

<script src="mt19937class.js" ></script>
<script>

// (C) 2011-2015 Wayne Radinsky

/*jslint browser: true, devel: true, passfail: true */
/*global MersenneTwister19937 */
/*global jQuery */
/*global Wad */

var globalAudioContext;
var gUmt;

// notes about terminology:
// lpnum -- loop number
// vcnum -- voice number
// "cursor" -- various cursors point to the end of an array + 1
//             (point where new notes will be added)
// instParams -- instrument parameters -- not used yet but will hold
//                instrument-specific parameters
// fpt -- "floating-point" -- floating point value of pitches for scale notes
//        (notes are expressed as both a ratio, num/dnom, and a floating-point
//        value where 2^fpt is proportional to the pitch
//        pitch values in gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].pitch
//        are RAW pitches and in floating-point format.

//    jsabort, cx, and ctstr are debugging functions that will be
//    REMOVED from the final product (assuming there is ever any such thing as a
//    final product :P )
//
//    Anything that starts with umt_test is test code and will be removed
//    (or at least shoved aside into some other file).
//
//    Actual music code starts with the function umtGetAudioContext


function jsabort(msg) {
    "use strict";
    window.alert(msg);
    throw new Error('Aborting javascript: ' + msg);
}

function cx(stringparameter) {
    "use strict";
    // this function exists just so I don't have to type 'console.log' over
    // plus prevents output from changing!
    console.log(stringparameter);
}

function ctstr(anyparameter) {
    "use strict";
    // a supposedly simple function to make a string from a var for debug
    //dumps, that has gotten way complicated over time...
    var x, rv, z, name, isArr;
    if (typeof anyparameter === 'object') {
        if (anyparameter === null) {
            return 'null';
        }
        name = '';
        isArr = false;
        if (anyparameter.constructor !== undefined) {
            name = anyparameter.constructor.toString();
        }
        if (name === 'function Object() { [native code] }') {
            name = '';
        }
        if (name === 'function Array() { [native code] }') {
            name = '';
            isArr = true;
        }
        if (name === 'function AudioContext() { [native code] }') {
            return 'object AudioContext';
        }
        if (name === '') {
            rv = '';
            for (z in anyparameter) {
                if (anyparameter.hasOwnProperty(z)) {
                    rv = rv + ', ' + z + ': ' + ctstr(anyparameter[z]);
                }
            }
            if (isArr) {
                return 'array [ ' + rv.substring(2) + ' ]';
            }
            return 'object { ' + rv.substring(2) + ' }';
        }
        return '{[Code Object]}';
    }
    if (typeof anyparameter === 'number') {
        return 'number ' + anyparameter.toString();
    }
    if (typeof anyparameter === 'string') {
        return 'string "' + anyparameter + '"';
    }
    if (typeof anyparameter === 'boolean') {
        return 'boolean ' + anyparameter.toString();
    }
    x = typeof anyparameter;
    window.alert(x);
    console.log('x', x);
    jsabort('typeof returned an undefined value');
}

// Actual music code starts here

function umtGetAudioContext() {
    "use strict";
    if (!window.AudioContext) {
        if (!window.webkitAudioContext) {
            window.alert("Your browser does not support the WebAudio API (HTML5).\nPlease use a compatible browser e.g. Google Chrome. If your WebAudio is disabled in Chrome, enable it in page about:flags");
            return;
        }
        window.AudioContext = window.webkitAudioContext;
    }
    var ctx = new window.AudioContext();
    return ctx;
}

// WAD has been modified to detect this global variable, and if it exists, use it instead of instantiating its own audio context
globalAudioContext = umtGetAudioContext();

</script>
<script src="wad.js"></script>
<script>

function umtGetRando(seedNum) {
    "use strict";
    var mt1, initAry, x;
    mt1 = new MersenneTwister19937();
    initAry = [0x123, 0x234, 0x345, 0x456];
    mt1.initByArray(initAry, 4);
    for (x = 0; x < (seedNum * 32); x = x + 1) {
        mt1.genrandInt32();
    }
    return mt1;
}

function umtTestCheckForFloat(anyparameter) {
    "use strict";
    var hello;
    hello = typeof anyparameter;
    if (hello === "number") {
        return;
    }
    jsabort(hello);
}

// For all these "FM" building block functions, "revs" actually stands for "revolutions" -- i.e the number of times through the cycle
// The integer part is the number of complete revolutions so far and the fractional part is how far into the current revolution we are

function umtFMSine(revs) {
    "use strict";
    return Math.sin(gUmt.TAU * revs);
}

function umtFMSquare(revs) {
    "use strict";
    var skip;
    skip = Math.floor(revs);
    revs = revs - skip;
    if (revs > 0.5) {
        return 1.0;
    }
    return -1.0;
}

function umtFMVarSquare(revs, variance) {
    "use strict";
    var skip;
    // variance == range 0.5 to 1.0
    skip = Math.floor(revs);
    revs = revs - skip;
    if (revs > variance) {
        return 1.0;
    }
    return -1.0;
}

function umtFMTriangle(revs) {
    "use strict";
    var skip;
    skip = Math.floor(revs);
    revs = revs - skip;
    if (revs > 0.5) {
        return 1.0 - ((revs - 0.5) * 4.0);
    }
    return (revs * 4.0) - 1.0;
}

function umtFMVarTriangle(revs, variance) {
    "use strict";
    var skip;
    // for variance, 0.5 == center == triangle
    skip = Math.floor(revs);
    revs = revs - skip;
    if (revs > variance) {
        return 1.0 - (((revs - variance) / (1.0 - variance)) * 2.0);
    }
    return ((revs / variance) * 2.0) - 1.0;
}

function umtFMSawtooth(revs) {
    "use strict";
    var skip;
    skip = Math.floor(revs);
    revs = revs - skip;
    return (revs - 0.5) * 2.0;
}

function umtGenerateANoteSineWave(frequency, duration, amplitude) {
    "use strict";
    // consult https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
    var numSamples, theBuffer, bufData, i, fade, sampleRate;
    sampleRate = gUmt.globalCtx.sampleRate;
    numSamples = duration * sampleRate;
    theBuffer = gUmt.globalCtx.createBuffer(1, numSamples, sampleRate); // numberOfChannels, length, sampleRate
    bufData = theBuffer.getChannelData(0);
    for (i = 0; i < numSamples; i = i + 1) {
        fade = 1.0 - (i / numSamples);
        bufData[i] = umtFMSine(i * (frequency / sampleRate)) * (amplitude * fade);
    }
    return theBuffer;
}

function umtGenerateANoteSquareWave(frequency, duration, amplitude) {
    "use strict";
    // consult https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
    var numSamples, theBuffer, bufData, i, fade;
    numSamples = duration * gUmt.globalCtx.sampleRate;
    theBuffer = gUmt.globalCtx.createBuffer(1, numSamples, gUmt.globalCtx.sampleRate); // numberOfChannels, length, sampleRate
    bufData = theBuffer.getChannelData(0);
    for (i = 0; i < numSamples; i = i + 1) {
        fade = 1.0 - (i / numSamples);
        bufData[i] = umtFMSquare(i * (frequency / gUmt.globalCtx.sampleRate)) * (amplitude * fade);
    }
    return theBuffer;
}

function umtGenerateANoteSquareVar(frequency, duration, amplitude, threshold) {
    "use strict";
    // consult https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
    var numSamples, theBuffer, bufData, i, fade;
    threshold = (threshold / 2.0) + 0.5;
    numSamples = duration * gUmt.globalCtx.sampleRate;
    theBuffer = gUmt.globalCtx.createBuffer(1, numSamples, gUmt.globalCtx.sampleRate); // numberOfChannels, length, sampleRate
    bufData = theBuffer.getChannelData(0);
    for (i = 0; i < numSamples; i = i + 1) {
        fade = 1.0 - (i / numSamples);
        bufData[i] = umtFMVarSquare(i * (frequency / gUmt.globalCtx.sampleRate), threshold) * (amplitude * fade);
    }
    return theBuffer;
}

function umtGenerateANoteSquareRisingPitch(frequency, duration, amplitude, threshold, riseRate) {
    "use strict";
    // consult https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
    var numSamples, theBuffer, bufData, i, fade, pctThere, expAdjustedFreq;
    threshold = (threshold / 2.0) + 0.5;
    numSamples = duration * gUmt.globalCtx.sampleRate;
    theBuffer = gUmt.globalCtx.createBuffer(1, numSamples, gUmt.globalCtx.sampleRate); // numberOfChannels, length, sampleRate
    bufData = theBuffer.getChannelData(0);
    for (i = 0; i < numSamples; i = i + 1) {
        pctThere = i / numSamples;
        fade = 1.0 - pctThere;
        expAdjustedFreq = frequency * (((i / gUmt.globalCtx.sampleRate)  * riseRate) + 1);
        bufData[i] = umtFMVarSquare(i * (expAdjustedFreq / gUmt.globalCtx.sampleRate), threshold) * (amplitude * fade);
    }
    return theBuffer;
}

function umtGenerateANoteSquareStartStopVar(frequency, duration, amplitude, startThreshold, stopThreshold) {
    "use strict";
    // consult https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
    var numSamples, theBuffer, bufData, i, fade, thresGap, pctThere, currentThreshold;
    startThreshold = (startThreshold / 2.0) + 0.5;
    stopThreshold = (stopThreshold / 2.0) + 0.5;
    numSamples = duration * gUmt.globalCtx.sampleRate;
    theBuffer = gUmt.globalCtx.createBuffer(1, numSamples, gUmt.globalCtx.sampleRate); // numberOfChannels, length, sampleRate
    bufData = theBuffer.getChannelData(0);
    thresGap = stopThreshold - startThreshold;
    for (i = 0; i < numSamples; i = i + 1) {
        pctThere = i / numSamples;
        fade = 1.0 - pctThere;
        currentThreshold = (thresGap * pctThere) + startThreshold;
        bufData[i] = umtFMVarSquare(i * (frequency / gUmt.globalCtx.sampleRate), currentThreshold) * (amplitude * fade);
    }
    return theBuffer;
}

function umtGenerateANoteTriangleWave(frequency, duration, amplitude) {
    "use strict";
    // consult https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
    var numSamples, theBuffer, bufData, i, fade;
    numSamples = duration * gUmt.globalCtx.sampleRate;
    theBuffer = gUmt.globalCtx.createBuffer(1, numSamples, gUmt.globalCtx.sampleRate); // numberOfChannels, length, sampleRate
    bufData = theBuffer.getChannelData(0);
    for (i = 0; i < numSamples; i = i + 1) {
        fade = 1.0 - (i / numSamples);
        bufData[i] = umtFMTriangle(i * (frequency / gUmt.globalCtx.sampleRate)) * (amplitude * fade);
    }
    return theBuffer;
}

function umtGenerateANoteTriangleVar(frequency, duration, amplitude, variance) {
    "use strict";
    // consult https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
    var numSamples, theBuffer, bufData, i, fade;
    numSamples = duration * gUmt.globalCtx.sampleRate;
    theBuffer = gUmt.globalCtx.createBuffer(1, numSamples, gUmt.globalCtx.sampleRate); // numberOfChannels, length, sampleRate
    bufData = theBuffer.getChannelData(0);
    variance = variance + 0.5; // move origin to center point
    if (variance > 1.0) {
        variance = variance - 1.0;
    }
    for (i = 0; i < numSamples; i = i + 1) {
        fade = 1.0 - (i / numSamples);
        bufData[i] = umtFMVarTriangle(i * (frequency / gUmt.globalCtx.sampleRate), variance) * (amplitude * fade);
    }
    return theBuffer;
}

function umtGenerateANoteSawtoothWave(frequency, duration, amplitude) {
    "use strict";
    // consult https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
    var numSamples, theBuffer, bufData, i, fade;
    numSamples = duration * gUmt.globalCtx.sampleRate;
    theBuffer = gUmt.globalCtx.createBuffer(1, numSamples, gUmt.globalCtx.sampleRate); // numberOfChannels, length, sampleRate
    bufData = theBuffer.getChannelData(0);
    for (i = 0; i < numSamples; i = i + 1) {
        fade = 1.0 - (i / numSamples);
        bufData[i] = umtFMSawtooth(i * (frequency / gUmt.globalCtx.sampleRate)) * (amplitude * fade);
    }
    return theBuffer;
}

function umtGenerateANoteSawtoothVar(frequency, duration, amplitude, variance) {
    "use strict";
    // consult https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
    var numSamples, theBuffer, bufData, i, fade;
    numSamples = duration * gUmt.globalCtx.sampleRate;
    theBuffer = gUmt.globalCtx.createBuffer(1, numSamples, gUmt.globalCtx.sampleRate); // numberOfChannels, length, sampleRate
    bufData = theBuffer.getChannelData(0);
    // same as triange wave, except we DON'T move the origin to the center point, so we get sawtooth waves by default
    variance = variance / 5.0; // re-size to get more sawtooth wave
    for (i = 0; i < numSamples; i = i + 1) {
        fade = 1.0 - (i / numSamples);
        bufData[i] = umtFMVarTriangle(i * (frequency / gUmt.globalCtx.sampleRate), variance) * (amplitude * fade);
    }
    return theBuffer;
}

function umtGenerateANoteNoise(frequency, duration, amplitude) {
    "use strict";
    // consult https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
    var numSamples, theBuffer, bufData, rng, i, fade, noiseSample;
    noiseSample = frequency; // delete me -- just to pass camelCaseJSLint
    numSamples = duration * gUmt.globalCtx.sampleRate;
    theBuffer = gUmt.globalCtx.createBuffer(1, numSamples, gUmt.globalCtx.sampleRate); // numberOfChannels, length, sampleRate
    bufData = theBuffer.getChannelData(0);
    rng = umtGetRando(0);
    for (i = 0; i < numSamples; i = i + 1) {
        fade = 1.0 - (i / numSamples);
        noiseSample = (rng.genrandReal3() * 2.0) - 1.0;
        bufData[i] = noiseSample * (amplitude * fade);
    }
    return theBuffer;
}

function umtGenerateANoteBackwardsNoise(frequency, duration, amplitude) {
    "use strict";
    // consult https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
    var numSamples, theBuffer, bufData, rng, i, fade, noiseSample;
    noiseSample = frequency; // delete me -- just to pass camelCaseJSLint
    numSamples = duration * gUmt.globalCtx.sampleRate;
    theBuffer = gUmt.globalCtx.createBuffer(1, numSamples, gUmt.globalCtx.sampleRate); // numberOfChannels, length, sampleRate
    bufData = theBuffer.getChannelData(0);
    rng = umtGetRando(0);
    for (i = 0; i < numSamples; i = i + 1) {
        fade = i / numSamples;
        noiseSample = (rng.genrandReal3() * 2.0) - 1.0;
        bufData[i] = noiseSample * (amplitude * fade);
    }
    return theBuffer;
}

function umtGenerateANoteSteamPop(frequency, duration, amplitude) {
    "use strict";
    // consult https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
    var numSamples, theBuffer, bufData, rng, i, fadeLin, fadeRecip, fadeActual, noiseSample;
    noiseSample = frequency; // delete me -- just to pass camelCaseJSLint
    numSamples = duration * gUmt.globalCtx.sampleRate;
    theBuffer = gUmt.globalCtx.createBuffer(1, numSamples, gUmt.globalCtx.sampleRate); // numberOfChannels, length, sampleRate
    bufData = theBuffer.getChannelData(0);
    rng = umtGetRando(0);
    for (i = 0; i < numSamples; i = i + 1) {
        fadeLin = 1.0 - (i / numSamples);
        // fadeRecip = 1.0 / (100.0 * (i / numSamples) + 1.0);
        fadeRecip = 1.0 / ((i / 20.0) + 1.0);
        if (fadeLin < fadeRecip) {
            fadeActual = fadeLin;
        } else {
            fadeActual = fadeRecip;
        }
        noiseSample = (rng.genrandReal3() * 2.0) - 1.0;
        bufData[i] = noiseSample * (amplitude * fadeActual);
    }
    return theBuffer;
}

function umtGenerateANoteFMSynthOriginal(frequency, duration, amplitude) {
    "use strict";
    // consult https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
    var numSamples, theBuffer, bufData, i, fade, sinePart, subFrequency, modulatorFreq, beta;
    numSamples = duration * gUmt.globalCtx.sampleRate;
    theBuffer = gUmt.globalCtx.createBuffer(1, numSamples, gUmt.globalCtx.sampleRate); // numberOfChannels, length, sampleRate
    bufData = theBuffer.getChannelData(0);
    modulatorFreq = frequency * (3.0 / 2.0);
    // 1/1    P1        C                 0.000      0.000
    // 16/15  m2        C#                0.093      0.083
    // 10/9   M2-alt    D-alt             0.152      0.166
    // 9/8    M2-reg    D-reg             0.170      0.166
    // 6/5    m3        Eb                0.263      0.250
    // 5/4    M3        E                 0.322      0.333
    // 4/3    P4        F                 0.415      0.417
    // 3/2    P5        G                 0.585      0.583
    // 8/5    m6        Ab                0.678      0.667
    // 5/3    M6        A                 0.737      0.750
    // 16/9   m7-alt    Bb-alt            0.830      0.833
    // 9/5    m7-reg    Bb-reg            0.848      0.833
    // 15/8   M7        B                 0.907      0.917
    // 2/1    P8        C                 1.000      1.000
    beta = 10.0;
    for (i = 0; i < numSamples; i = i + 1) {
        fade = 1.0 - (i / numSamples);
        subFrequency = frequency + beta * ((Math.sin((gUmt.TAU * i * (modulatorFreq / gUmt.globalCtx.sampleRate)))));
        sinePart = Math.sin((gUmt.TAU * i * (subFrequency / gUmt.globalCtx.sampleRate)));
        bufData[i] = sinePart * (amplitude * fade);
    }
    return theBuffer;
}

function umtGenerateANoteFMSynthVar(frequency, duration, amplitude, modulator, beta) {
    "use strict";
    // consult https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
    var numSamples, theBuffer, bufData, i, fade, sinePart, subFrequency, modList, modNum, modDnom, modulatorFreq;
    numSamples = duration * gUmt.globalCtx.sampleRate;
    theBuffer = gUmt.globalCtx.createBuffer(1, numSamples, gUmt.globalCtx.sampleRate); // numberOfChannels, length, sampleRate
    bufData = theBuffer.getChannelData(0);
    // 1      1/1    2/1    P1        C                 0.000      0.000
    // 1      2/1    1/1    P8        C                 1.000      1.000
    // 3      3/2    4/3    P5        G                 0.585      0.583
    // 3      4/3    3/2    P4        F                 0.415      0.417
    // 5      5/3    6/5    M6        A                 0.737      0.750
    // 5      6/5    5/3    m3        Eb                0.263      0.250
    // 5      5/4    8/5    M3        E                 0.322      0.333
    // 5      8/5    5/4    m6        Ab                0.678      0.667
    // 9      9/5    10/9   m7-reg    Bb-reg            0.848      0.833
    // 9      10/9   9/5    M2-alt    D-alt             0.152      0.166
    // 9      9/8    16/9   M2-reg    D-reg             0.170      0.166
    // 9      16/9   9/8    m7-alt    Bb-alt            0.830      0.833
    // 15     16/15  15/8   m2        C#                0.093      0.083
    // 15     15/8   16/15  M7        B                 0.907      0.917
    // modList = [ {num: 1, dnom: 1}, {num: 2, dnom: 1}, {num: 3, dnom: 2}, {num: 4, dnom: 3}, {num: 5, dnom: 3}, {num: 6, dnom: 5}, {num: 5, dnom: 4}, {num: 8, dnom: 5}, {num: 9, dnom: 5}, {num: 10, dnom: 9}, {num: 9, dnom: 8}, {num: 16, dnom: 9}, {num: 16, dnom: 15}, {num: 15, dnom: 8} ];
    // without the octives:
    modList = [ {num: 3, dnom: 2}, {num: 4, dnom: 3}, {num: 5, dnom: 3}, {num: 6, dnom: 5}, {num: 5, dnom: 4}, {num: 8, dnom: 5}, {num: 9, dnom: 5}, {num: 10, dnom: 9}, {num: 9, dnom: 8}, {num: 16, dnom: 9}, {num: 16, dnom: 15}, {num: 15, dnom: 8} ];
    modulator = Math.floor(modulator * (modList.length - 1));
    modNum = modList[modulator].num;
    modDnom = modList[modulator].dnom;
    modulatorFreq = frequency * (modNum / modDnom);
    beta = (beta * 5.0);
    for (i = 0; i < numSamples; i = i + 1) {
        fade = 1.0 - (i / numSamples);
        subFrequency = frequency + beta * ((Math.sin((gUmt.TAU * i * (modulatorFreq / gUmt.globalCtx.sampleRate)))));
        sinePart = Math.sin((gUmt.TAU * i * (subFrequency / gUmt.globalCtx.sampleRate)));
        bufData[i] = sinePart * (amplitude * fade);
    }
    return theBuffer;
}

function umtGenerateANoteFMSynthStartStop(frequency, duration, amplitude, startModulator, startBeta, stopModulator, stopBeta) {
    "use strict";
    // consult https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
    var numSamples, theBuffer, bufData, i, fade, sinePart, subFrequency, modList, startModNum, startModDnom, startModulatorFreq, stopModNum, stopModDnom, stopModulatorFreq, pctThere, modulatorDiff, betaDiff, currentModulatorFreq, currentBeta;
    numSamples = duration * gUmt.globalCtx.sampleRate;
    theBuffer = gUmt.globalCtx.createBuffer(1, numSamples, gUmt.globalCtx.sampleRate); // numberOfChannels, length, sampleRate
    bufData = theBuffer.getChannelData(0);
    // 1      1/1    2/1    P1        C                 0.000      0.000
    // 1      2/1    1/1    P8        C                 1.000      1.000
    // 3      3/2    4/3    P5        G                 0.585      0.583
    // 3      4/3    3/2    P4        F                 0.415      0.417
    // 5      5/3    6/5    M6        A                 0.737      0.750
    // 5      6/5    5/3    m3        Eb                0.263      0.250
    // 5      5/4    8/5    M3        E                 0.322      0.333
    // 5      8/5    5/4    m6        Ab                0.678      0.667
    // 9      9/5    10/9   m7-reg    Bb-reg            0.848      0.833
    // 9      10/9   9/5    M2-alt    D-alt             0.152      0.166
    // 9      9/8    16/9   M2-reg    D-reg             0.170      0.166
    // 9      16/9   9/8    m7-alt    Bb-alt            0.830      0.833
    // 15     16/15  15/8   m2        C#                0.093      0.083
    // 15     15/8   16/15  M7        B                 0.907      0.917
    // modList = [ {num: 1, dnom: 1}, {num: 2, dnom: 1}, {num: 3, dnom: 2}, {num: 4, dnom: 3}, {num: 5, dnom: 3}, {num: 6, dnom: 5}, {num: 5, dnom: 4}, {num: 8, dnom: 5}, {num: 9, dnom: 5}, {num: 10, dnom: 9}, {num: 9, dnom: 8}, {num: 16, dnom: 9}, {num: 16, dnom: 15}, {num: 15, dnom: 8} ];
    // without the octives:
    modList = [ {num: 3, dnom: 2}, {num: 4, dnom: 3}, {num: 5, dnom: 3}, {num: 6, dnom: 5}, {num: 5, dnom: 4}, {num: 8, dnom: 5}, {num: 9, dnom: 5}, {num: 10, dnom: 9}, {num: 9, dnom: 8}, {num: 16, dnom: 9}, {num: 16, dnom: 15}, {num: 15, dnom: 8} ];
    startModulator = Math.floor(startModulator * (modList.length - 1));
    startModNum = modList[startModulator].num;
    startModDnom = modList[startModulator].dnom;
    startModulatorFreq = frequency * (startModNum / startModDnom);
    stopModulator = Math.floor(stopModulator * (modList.length - 1));
    stopModNum = modList[stopModulator].num;
    stopModDnom = modList[stopModulator].dnom;
    stopModulatorFreq = frequency * (stopModNum / stopModDnom);
    startBeta = (startBeta * 5.0);
    stopBeta = (stopBeta * 5.0);
    modulatorDiff = stopModulatorFreq - startModulatorFreq;
    betaDiff = stopBeta - startBeta;
    for (i = 0; i < numSamples; i = i + 1) {
        pctThere = (i / numSamples);
        fade = 1.0 - pctThere;
        currentModulatorFreq = (modulatorDiff * pctThere) + startModulatorFreq;
        currentBeta = (betaDiff * pctThere) + startBeta;
        subFrequency = frequency + currentBeta * ((Math.sin((gUmt.TAU * i * (currentModulatorFreq / gUmt.globalCtx.sampleRate)))));
        sinePart = Math.sin((gUmt.TAU * i * (subFrequency / gUmt.globalCtx.sampleRate)));
        bufData[i] = sinePart * (amplitude * fade);
    }
    return theBuffer;
}

function umtGenerateANoteFMSynthSquare(frequency, duration, amplitude, startThreshold, stopThreshold, startModulator, startBeta, stopModulator, stopBeta) {
    "use strict";
    // consult https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html
    var numSamples, theBuffer, bufData, i, fade, squarePart, subFrequency, modList, startModNum, startModDnom, startModulatorFreq, stopModNum, stopModDnom, stopModulatorFreq, pctThere, thresDiff, modulatorDiff, betaDiff, currentThreshold, currentModulatorFreq, currentBeta;
    numSamples = duration * gUmt.globalCtx.sampleRate;
    theBuffer = gUmt.globalCtx.createBuffer(1, numSamples, gUmt.globalCtx.sampleRate); // numberOfChannels, length, sampleRate
    bufData = theBuffer.getChannelData(0);
    startThreshold = (startThreshold / 2.0) + 0.5;
    stopThreshold = (stopThreshold / 2.0) + 0.5;
    // 1      1/1    2/1    P1        C                 0.000      0.000
    // 1      2/1    1/1    P8        C                 1.000      1.000
    // 3      3/2    4/3    P5        G                 0.585      0.583
    // 3      4/3    3/2    P4        F                 0.415      0.417
    // 5      5/3    6/5    M6        A                 0.737      0.750
    // 5      6/5    5/3    m3        Eb                0.263      0.250
    // 5      5/4    8/5    M3        E                 0.322      0.333
    // 5      8/5    5/4    m6        Ab                0.678      0.667
    // 9      9/5    10/9   m7-reg    Bb-reg            0.848      0.833
    // 9      10/9   9/5    M2-alt    D-alt             0.152      0.166
    // 9      9/8    16/9   M2-reg    D-reg             0.170      0.166
    // 9      16/9   9/8    m7-alt    Bb-alt            0.830      0.833
    // 15     16/15  15/8   m2        C#                0.093      0.083
    // 15     15/8   16/15  M7        B                 0.907      0.917
    // modList = [ {num: 1, dnom: 1}, {num: 2, dnom: 1}, {num: 3, dnom: 2}, {num: 4, dnom: 3}, {num: 5, dnom: 3}, {num: 6, dnom: 5}, {num: 5, dnom: 4}, {num: 8, dnom: 5}, {num: 9, dnom: 5}, {num: 10, dnom: 9}, {num: 9, dnom: 8}, {num: 16, dnom: 9}, {num: 16, dnom: 15}, {num: 15, dnom: 8} ];
    // without the octives:
    modList = [ {num: 3, dnom: 2}, {num: 4, dnom: 3}, {num: 5, dnom: 3}, {num: 6, dnom: 5}, {num: 5, dnom: 4}, {num: 8, dnom: 5}, {num: 9, dnom: 5}, {num: 10, dnom: 9}, {num: 9, dnom: 8}, {num: 16, dnom: 9}, {num: 16, dnom: 15}, {num: 15, dnom: 8} ];
    startModulator = Math.floor(startModulator * (modList.length - 1));
    startModNum = modList[startModulator].num;
    startModDnom = modList[startModulator].dnom;
    startModulatorFreq = frequency * (startModNum / startModDnom);
    stopModulator = Math.floor(stopModulator * (modList.length - 1));
    stopModNum = modList[stopModulator].num;
    stopModDnom = modList[stopModulator].dnom;
    stopModulatorFreq = frequency * (stopModNum / stopModDnom);
    startBeta = (startBeta * 5.0);
    stopBeta = (stopBeta * 5.0);
    thresDiff = stopThreshold - startThreshold;
    modulatorDiff = stopModulatorFreq - startModulatorFreq;
    betaDiff = stopBeta - startBeta;
    for (i = 0; i < numSamples; i = i + 1) {
        pctThere = (i / numSamples);
        fade = 1.0 - pctThere;
        currentModulatorFreq = (modulatorDiff * pctThere) + startModulatorFreq;
        currentBeta = (betaDiff * pctThere) + startBeta;
        subFrequency = frequency + currentBeta * ((Math.sin((gUmt.TAU * i * (currentModulatorFreq / gUmt.globalCtx.sampleRate)))));
        // sinePart = Math.sin((gUmt.TAU * i * (subFrequency / gUmt.globalCtx.sampleRate)));
        // squarePart = umtFMSquare(i * (subFrequency / gUmt.globalCtx.sampleRate));
        currentThreshold = (thresDiff * pctThere) + startThreshold;
        squarePart = umtFMVarSquare(i * (subFrequency / gUmt.globalCtx.sampleRate), currentThreshold);
        bufData[i] = squarePart * (amplitude * fade);
    }
    return theBuffer;
}

// Converted this to a test function rather than removing it -- want to keep a built in function (not part of any instrument) for making sounds but it should only be used for testing
function umtTestQueUpANoteSineWave(fromMoment, frequency, startTime, duration, amplitude, instSpecificParams) {
    "use strict";
    var idxname, theBuffer, node, ourStart, startMoment;
    idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
    idxname = "sinewave" + frequency + "x" + duration + "x" + amplitude;
    if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
        theBuffer = gUmt.cachedNotes[idxname];
    } else {
        theBuffer = umtGenerateANoteSineWave(frequency, duration, amplitude);
        gUmt.cachedNotes[idxname] = theBuffer;
    }
    node = gUmt.globalCtx.createBufferSource();
    node.buffer = theBuffer;
    node.connect(gUmt.globalCtx.destination);
    ourStart = Number(startTime);
    startMoment = fromMoment + ourStart;
    node.start(startMoment);
}

function InstantiateTuningForkObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: false, parameters: [] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var idxname, theBuffer, node;
        idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
        idxname = "sinewave" + frequency + "x" + duration + "x" + amplitude;
        if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
            theBuffer = gUmt.cachedNotes[idxname];
        } else {
            theBuffer = umtGenerateANoteSineWave(frequency, duration, amplitude);
            gUmt.cachedNotes[idxname] = theBuffer;
        }
        node = gUmt.globalCtx.createBufferSource();
        node.buffer = theBuffer;
        node.connect(gUmt.globalCtx.destination);
        node.start(startMoment);
    };
}

function InstantiateSquareWaveObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: false, parameters: [] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var idxname, theBuffer, node;
        idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
        idxname = "squarewave" + frequency + "x" + duration + "x" + amplitude;
        if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
            theBuffer = gUmt.cachedNotes[idxname];
        } else {
            theBuffer = umtGenerateANoteSquareWave(frequency, duration, amplitude);
            gUmt.cachedNotes[idxname] = theBuffer;
        }
        node = gUmt.globalCtx.createBufferSource();
        node.buffer = theBuffer;
        node.connect(gUmt.globalCtx.destination);
        node.start(startMoment);
    };
}

function InstantiateSquareVarObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: false, parameters: [ { name: "unsquareness", display: "Un-square-ness" } ] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var idxname, theBuffer, node, threshold;
        threshold = instSpecificParams.unsquareness;
        idxname = "squarevar" + frequency + "x" + duration + "x" + amplitude + "x" + threshold;
        if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
            theBuffer = gUmt.cachedNotes[idxname];
        } else {
            theBuffer = umtGenerateANoteSquareVar(frequency, duration, amplitude, threshold * 0.96);
            gUmt.cachedNotes[idxname] = theBuffer;
        }
        node = gUmt.globalCtx.createBufferSource();
        node.buffer = theBuffer;
        node.connect(gUmt.globalCtx.destination);
        node.start(startMoment);
    };
}

function InstantiateSquareRisingPitchObj() {
    "use strict";
    this.getParams = function () {
        return {
            percussion: false,
            parameters: [
                { name: "unsquareness", display: "Un-square-ness" },
                { name: "riserate", display: "Pitch rise rate" }
            ]
        };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var idxname, theBuffer, node, threshold, riserate;
        threshold = instSpecificParams.unsquareness;
        riserate = instSpecificParams.riserate;
        riserate = riserate * 4;
        idxname = "squarerise" + frequency + "x" + duration + "x" + amplitude + "x" + threshold + "x" + riserate;
        if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
            theBuffer = gUmt.cachedNotes[idxname];
        } else {
            theBuffer = umtGenerateANoteSquareRisingPitch(frequency, duration, amplitude, threshold * 0.96, riserate);
            gUmt.cachedNotes[idxname] = theBuffer;
        }
        node = gUmt.globalCtx.createBufferSource();
        node.buffer = theBuffer;
        node.connect(gUmt.globalCtx.destination);
        node.start(startMoment);
    };
}

function InstantiateSquareStartStopObj() {
    "use strict";
    this.getParams = function () {
        return {
            percussion: false,
            parameters: [
                { name: "startunsquareness", display: "Start un-square-ness" },
                { name: "stopunsquareness", display: "Stop un-square-ness" }
            ]
        };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var idxname, theBuffer, node, startThreshold, stopThreshold;
        startThreshold = instSpecificParams.startunsquareness;
        stopThreshold = instSpecificParams.stopunsquareness;
        idxname = "squaredblvar" + frequency + "x" + duration + "x" + amplitude + "x" + startThreshold + "x" + stopThreshold;
        if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
            theBuffer = gUmt.cachedNotes[idxname];
        } else {
            theBuffer = umtGenerateANoteSquareStartStopVar(frequency, duration, amplitude, startThreshold * 0.96, stopThreshold * 0.96);
            gUmt.cachedNotes[idxname] = theBuffer;
        }
        node = gUmt.globalCtx.createBufferSource();
        node.buffer = theBuffer;
        node.connect(gUmt.globalCtx.destination);
        node.start(startMoment);
    };
}

function InstantiateTriangleWaveObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: false, parameters: [] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var idxname, theBuffer, node;
        idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
        idxname = "triangle" + frequency + "x" + duration + "x" + amplitude;
        if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
            theBuffer = gUmt.cachedNotes[idxname];
        } else {
            theBuffer = umtGenerateANoteTriangleWave(frequency, duration, amplitude);
            gUmt.cachedNotes[idxname] = theBuffer;
        }
        node = gUmt.globalCtx.createBufferSource();
        node.buffer = theBuffer;
        node.connect(gUmt.globalCtx.destination);
        node.start(startMoment);
    };
}

function InstantiateTriangleVarObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: false, parameters: [ { name: "untriangleness", display: "Un-Triangleness" } ] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var variance, idxname, theBuffer, node;
        variance = instSpecificParams.untriangleness;
        idxname = "triangle" + frequency + "x" + duration + "x" + amplitude + "x" + variance;
        if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
            theBuffer = gUmt.cachedNotes[idxname];
        } else {
            theBuffer = umtGenerateANoteTriangleVar(frequency, duration, amplitude, variance);
            gUmt.cachedNotes[idxname] = theBuffer;
        }
        node = gUmt.globalCtx.createBufferSource();
        node.buffer = theBuffer;
        node.connect(gUmt.globalCtx.destination);
        node.start(startMoment);
    };
}

function InstantiateSawtoothWaveObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: false, parameters: [] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var idxname, theBuffer, node;
        idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
        idxname = "sawtooth" + frequency + "x" + duration + "x" + amplitude;
        if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
            theBuffer = gUmt.cachedNotes[idxname];
        } else {
            theBuffer = umtGenerateANoteSawtoothWave(frequency, duration, amplitude);
            gUmt.cachedNotes[idxname] = theBuffer;
        }
        node = gUmt.globalCtx.createBufferSource();
        node.buffer = theBuffer;
        node.connect(gUmt.globalCtx.destination);
        node.start(startMoment);
    };
}

function InstantiateSawtoothVarObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: false, parameters: [ { name: "unsawtoothness", display: "Un-Sawtoothness" } ] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var variance, idxname, theBuffer, node;
        variance = instSpecificParams.unsawtoothness;
        idxname = "sawtoothvar" + frequency + "x" + duration + "x" + amplitude + "x" + variance;
        if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
            theBuffer = gUmt.cachedNotes[idxname];
        } else {
            theBuffer = umtGenerateANoteSawtoothVar(frequency, duration, amplitude, variance);
            gUmt.cachedNotes[idxname] = theBuffer;
        }
        node = gUmt.globalCtx.createBufferSource();
        node.buffer = theBuffer;
        node.connect(gUmt.globalCtx.destination);
        node.start(startMoment);
    };
}

function InstantiateNoiseObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: true, parameters: [] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var idxname, theBuffer, node;
        idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
        idxname = "forwardsnoise" + frequency + "x" + duration + "x" + amplitude;
        if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
            theBuffer = gUmt.cachedNotes[idxname];
        } else {
            theBuffer = umtGenerateANoteNoise(frequency, duration, amplitude);
            gUmt.cachedNotes[idxname] = theBuffer;
        }
        node = gUmt.globalCtx.createBufferSource();
        node.buffer = theBuffer;
        node.connect(gUmt.globalCtx.destination);
        node.start(startMoment);
    };
}

function InstantiateBackwardsNoiseObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: true, parameters: [] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var idxname, theBuffer, node;
        idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
        idxname = "backwardsnoise" + frequency + "x" + duration + "x" + amplitude;
        if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
            theBuffer = gUmt.cachedNotes[idxname];
        } else {
            theBuffer = umtGenerateANoteBackwardsNoise(frequency, duration, amplitude);
            gUmt.cachedNotes[idxname] = theBuffer;
        }
        node = gUmt.globalCtx.createBufferSource();
        node.buffer = theBuffer;
        node.connect(gUmt.globalCtx.destination);
        node.start(startMoment);
    };
}

function InstantiateSteamPopObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: true, parameters: [] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var idxname, theBuffer, node;
        idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
        idxname = "steampop" + frequency + "x" + duration + "x" + amplitude;
        if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
            theBuffer = gUmt.cachedNotes[idxname];
        } else {
            theBuffer = umtGenerateANoteSteamPop(frequency, duration, amplitude);
            gUmt.cachedNotes[idxname] = theBuffer;
        }
        node = gUmt.globalCtx.createBufferSource();
        node.buffer = theBuffer;
        node.connect(gUmt.globalCtx.destination);
        node.start(startMoment);
    };
}

function InstantiateFMSynthOriginalObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: false, parameters: [] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var idxname, theBuffer, node;
        idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
        idxname = "fmsynthoriginal" + frequency + "x" + duration + "x" + amplitude;
        if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
            theBuffer = gUmt.cachedNotes[idxname];
        } else {
            theBuffer = umtGenerateANoteFMSynthOriginal(frequency, duration, amplitude);
            gUmt.cachedNotes[idxname] = theBuffer;
        }
        node = gUmt.globalCtx.createBufferSource();
        node.buffer = theBuffer;
        node.connect(gUmt.globalCtx.destination);
        node.start(startMoment);
    };
}

function InstantiateFMSynthVarObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: false, parameters: [
            { name: "modulator", display: "Modulator" },
            { name: "beta", display: "Beta" }
        ] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var modulator, beta, idxname, theBuffer, node;
        modulator = instSpecificParams.modulator;
        beta = instSpecificParams.beta;
        idxname = "fmsynthvar" + frequency + "x" + duration + "x" + amplitude + "x" + modulator + "x" + beta;
        if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
            theBuffer = gUmt.cachedNotes[idxname];
        } else {
            theBuffer = umtGenerateANoteFMSynthVar(frequency, duration, amplitude, modulator, beta);
            gUmt.cachedNotes[idxname] = theBuffer;
        }
        node = gUmt.globalCtx.createBufferSource();
        node.buffer = theBuffer;
        node.connect(gUmt.globalCtx.destination);
        node.start(startMoment);
    };
}

function InstantiateFMSynthStartStopObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: false, parameters: [
            { name: "startmodulator", display: "Start modulator" },
            { name: "startbeta", display: "Start beta" },
            { name: "stopmodulator", display: "Stop modulator" },
            { name: "stopbeta", display: "Stop beta" }
        ] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var startmodulator, startbeta, stopmodulator, stopbeta, idxname, theBuffer, node;
        startmodulator = instSpecificParams.startmodulator;
        startbeta = instSpecificParams.startbeta;
        stopmodulator = instSpecificParams.stopmodulator;
        stopbeta = instSpecificParams.stopbeta;
        idxname = "fmsynthstartstop" + frequency + "x" + duration + "x" + amplitude + "x" + startmodulator + "x" + startbeta + "x" + stopmodulator + "x" + stopbeta;
        if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
            theBuffer = gUmt.cachedNotes[idxname];
        } else {
            theBuffer = umtGenerateANoteFMSynthStartStop(frequency, duration, amplitude, startmodulator, startbeta, stopmodulator, stopbeta);
            gUmt.cachedNotes[idxname] = theBuffer;
        }
        node = gUmt.globalCtx.createBufferSource();
        node.buffer = theBuffer;
        node.connect(gUmt.globalCtx.destination);
        node.start(startMoment);
    };
}

function InstantiateFMSynthSquareObj() {
    "use strict";
    this.getParams = function () {
        return {
            percussion: false,
            parameters: [
                { name: "startunsquareness", display: "Start un-square-ness" },
                { name: "startmodulator", display: "Start modulator" },
                { name: "startbeta", display: "Start beta" },
                { name: "stopunsquareness", display: "Stop un-square-ness" },
                { name: "stopmodulator", display: "Stop modulator" },
                { name: "stopbeta", display: "Stop beta" }
            ]
        };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var startThreshold, stopThreshold, startModulator, startBeta, stopModulator, stopBeta, idxname, theBuffer, node;
        startThreshold = instSpecificParams.startunsquareness;
        stopThreshold = instSpecificParams.stopunsquareness;
        startModulator = instSpecificParams.startmodulator;
        startBeta = instSpecificParams.startbeta;
        stopModulator = instSpecificParams.stopmodulator;
        stopBeta = instSpecificParams.stopbeta;
        idxname = "square" + frequency + "x" + duration + "x" + amplitude + "x" + startThreshold + "X" + stopThreshold + "x" + startModulator + "x" + startBeta + "x" + stopModulator + "x" + stopBeta;
        if (gUmt.cachedNotes.hasOwnProperty(idxname)) {
            theBuffer = gUmt.cachedNotes[idxname];
        } else {
            theBuffer = umtGenerateANoteFMSynthSquare(frequency, duration, amplitude, startThreshold * 0.96, stopThreshold * 0.96, startModulator, startBeta, stopModulator, stopBeta);
            gUmt.cachedNotes[idxname] = theBuffer;
        }
        node = gUmt.globalCtx.createBufferSource();
        node.buffer = theBuffer;
        node.connect(gUmt.globalCtx.destination);
        node.start(startMoment);
    };
}

function InstantiateWadSinObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: false, parameters: [] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var idxname, theWad;
        idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
        idxname = "wadsin";
        if (gUmt.cachedWads.hasOwnProperty(idxname)) {
            theWad = gUmt.cachedWads[idxname];
        } else {
            theWad = new Wad({ source: 'sine', volume: amplitude, env: { attack: 0.0, decay: 0.1, sustain: 1.0, hold: duration, release: 0 } });
            gUmt.cachedWads[idxname] = theWad;
        }
        theWad.play({ exactTime: startMoment, pitch: frequency, volume: amplitude, env: {hold: duration} });
    };
}

function InstantiateWadKickObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: true, parameters: [] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var idxname, theWad;
        idxname = duration; // delete me -- just to pass camelCaseJSLint
        idxname = amplitude; // delete me -- just to pass camelCaseJSLint
        idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
        idxname = "wadkick";
        if (gUmt.cachedWads.hasOwnProperty(idxname)) {
            theWad = gUmt.cachedWads[idxname];
        } else {
            theWad = new Wad({ source: 'http://www.codecur.io/us/sendaudio/kick.mp3' });
            gUmt.cachedWads[idxname] = theWad;
        }
        theWad.play({ exactTime: startMoment, pitch: frequency });
    };
}

function InstantiateWadBassObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: false, parameters: [] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var idxname, theWad;
        idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
        idxname = "wadbass";
        if (gUmt.cachedWads.hasOwnProperty(idxname)) {
            theWad = gUmt.cachedWads[idxname];
        } else {
            theWad = new Wad({ source: 'sine', volume: amplitude, globalReverb: true, env: { attack: 0.02, decay: 0.1, sustain: 0.9, hold: duration, release: 0.1 } });
            gUmt.cachedWads[idxname] = theWad;
        }
        theWad.play({ exactTime: startMoment, pitch: frequency, volume: amplitude, env: {hold: duration} });
    };
}

function InstantiateWadSnareObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: true, parameters: [] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var idxname, theWad;
        idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
        idxname = "wadsnare";
        if (gUmt.cachedWads.hasOwnProperty(idxname)) {
            theWad = gUmt.cachedWads[idxname];
        } else {
            theWad = new Wad(Wad.presets.snare);
            theWad.globalReverb = true;
            gUmt.cachedWads[idxname] = theWad;
        }
        theWad.play({ exactTime: startMoment, pitch: frequency, volume: amplitude, env: {hold: duration} });
    };
}

function InstantiateWadHihatOpenObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: false, parameters: [] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var idxname, theWad;
        idxname = duration; // delete me -- just to pass camelCaseJSLint
        idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
        // idxname = "wadhihats" + frequency + "x" + duration + "x" + amplitude;
        idxname = "wadhihatopen";
        if (gUmt.cachedWads.hasOwnProperty(idxname)) {
            theWad = gUmt.cachedWads[idxname];
        } else {
            theWad = new Wad(Wad.presets.hiHatOpen);
            theWad.globalReverb = true;
            gUmt.cachedWads[idxname] = theWad;
        }
        theWad.play({ exactTime: startMoment, pitch: frequency, volume: amplitude });
    };
}

function InstantiateWadHihatClosedObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: false, parameters: [] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var idxname, theWad;
        idxname = duration; // delete me -- just to pass camelCaseJSLint
        idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
        // idxname = "wadhihats" + frequency + "x" + duration + "x" + amplitude;
        idxname = "wadhihatclosed";
        if (gUmt.cachedWads.hasOwnProperty(idxname)) {
            theWad = gUmt.cachedWads[idxname];
        } else {
            theWad = new Wad(Wad.presets.hiHatClosed);
            theWad.globalReverb = true;
            gUmt.cachedWads[idxname] = theWad;
        }
        theWad.play({ exactTime: startMoment, pitch: frequency, volume: amplitude });
    };
}

function InstantiateWadFluteObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: false, parameters: [] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var idxname, theWad;
        idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
        // idxname = "wadflute" + frequency + "x" + duration + "x" + amplitude;
        idxname = "wadflute";
        if (gUmt.cachedWads.hasOwnProperty(idxname)) {
            theWad = gUmt.cachedWads[idxname];
        } else {
            theWad = new Wad(Wad.presets.ghost);
            // Wad.setGlobalReverb({ impulse: 'http://www.codecur.io/us/sendaudio/longhall.wav', wet : 0.5 });
            gUmt.cachedWads[idxname] = theWad;
        }
        theWad.play({ exactTime: startMoment, pitch: frequency, volume: amplitude, env: {hold: duration} });
    };
}

function InstantiateWadPianoObj() {
    "use strict";
    this.getParams = function () {
        return { percussion: false, parameters: [] };
    };
    this.queUpANote = function (startMoment, frequency, duration, amplitude, instSpecificParams) {
        var idxname, theWad;
        idxname = instSpecificParams; // delete me -- just to pass camelCaseJSLint
        // idxname = "wadpiano" + frequency + "x" + duration + "x" + amplitude;
        idxname = "wadpiano";
        if (gUmt.cachedWads.hasOwnProperty(idxname)) {
            theWad = gUmt.cachedWads[idxname];
        } else {
            theWad = new Wad({source: 'square', volume: amplitude, env: { attack: 0.01, decay: 0.005, sustain: 0.2, hold: duration, release: 0.3}, filter: { type: 'lowpass', frequency: 1200, q: 8.5, env: { attack: 0.2, frequency: 600 } } });
            theWad.globalReverb = true;
            gUmt.cachedWads[idxname] = theWad;
        }
        theWad.play({ exactTime: startMoment, pitch: frequency, volume: amplitude, env: {hold: duration} });
    };
}

function umtCreateInstrumentBank() {
    "use strict";
    var instrumentName;
    gUmt.instrumentBank = {
        tuningfork: new InstantiateTuningForkObj(),
        squarewave: new InstantiateSquareWaveObj(),
        squarevar: new InstantiateSquareVarObj(),
        squarerisingpitch: new InstantiateSquareRisingPitchObj(),
        squarestartstop: new InstantiateSquareStartStopObj(),
        trianglewave: new InstantiateTriangleWaveObj(),
        sawtoothwave: new InstantiateSawtoothWaveObj(),
        forwardsnoise: new InstantiateNoiseObj(),
        backwardsnoise: new InstantiateBackwardsNoiseObj(),
        steampop: new InstantiateSteamPopObj(),
        fmsynthoriginal: new InstantiateFMSynthOriginalObj(),
        trianglevar: new InstantiateTriangleVarObj(),
        sawtoothvar: new InstantiateSawtoothVarObj(),
        fmsynthvar: new InstantiateFMSynthVarObj(),
        fmsynthstartstop: new InstantiateFMSynthStartStopObj(),
        fmsynthsquare: new InstantiateFMSynthSquareObj(),
        wadsin: new InstantiateWadSinObj(),
        wadkick: new InstantiateWadKickObj(),
        wadbass: new InstantiateWadBassObj(),
        wadsnare: new InstantiateWadSnareObj(),
        wadhihatopen: new InstantiateWadHihatOpenObj(),
        wadhihatclosed: new InstantiateWadHihatClosedObj(),
        wadflute: new InstantiateWadFluteObj(),
        wadpiano: new InstantiateWadPianoObj()
    };
    gUmt.instrumentParams = {};
    for (instrumentName in gUmt.instrumentBank) {
        if (gUmt.instrumentBank.hasOwnProperty(instrumentName)) {
            gUmt.instrumentParams[instrumentName] = gUmt.instrumentBank[instrumentName].getParams();
        }
    }
}

function umtClearLoop(lpnum, tab, xTempo, centerNote, xScale, xChord) {
    "use strict";
    if (!gUmt.loop.hasOwnProperty(lpnum)) {
        gUmt.loop[lpnum] = {
            score: {
                tempo: xTempo,
                playbackTimeOffset: 0,
                songTab: []
            }
        };
    } else {
        gUmt.loop[lpnum].score.tempo = xTempo;
    }
    gUmt.loop[lpnum].score.songTab[tab] = {
        centernoteLog: (Math.log(centerNote) / gUmt.LOG2) - 5,
        scale: xScale,
        chord: xChord,
        parts: 0,
        voice: []
    };
}

function umtAddVoice(lpnum, tab, idx, songNumber, rangeMin, rangeMax, instrumentName, xPercussion) {
    "use strict";
    gUmt.loop[lpnum].score.songTab[tab].parts = idx + 1;
    gUmt.loop[lpnum].score.songTab[tab].voice[idx] = {
        instrument: instrumentName,
        selection: 0,
        cursor: 0,
        nextStart: 0,
        rangeTop: rangeMax,
        rangeBottom: rangeMin,
        percussion: xPercussion,
        notes: [],
        randRhythm: umtGetRando(songNumber * 40),
        randPitch: umtGetRando(songNumber * 40 + 1),
        randAmp: umtGetRando(songNumber * 40 + 5),
        randRests: umtGetRando(songNumber * 40 + 2),
        randSyms: umtGetRando(songNumber * 40 + 3),
        randTrans: umtGetRando(songNumber * 40 + 4),
        randScale: umtGetRando(songNumber * 40 + 5),
        randTilt: umtGetRando(songNumber * 40 + 6),
        randScrollrhythm: umtGetRando(songNumber * 40 + 7),
        randScrollpitch: umtGetRando(songNumber * 40 + 8),
        randScrollboth: umtGetRando(songNumber * 40 + 9),
        randInstPat: umtGetRando(songNumber * 40 + 10),
        randInstSymVars: umtGetRando(songNumber * 40 + 11)
    };
}

function umtAddNote(lpnum, tab, voicenum, rest, pitch, duration, amplitude, instParams) {
    "use strict";
    var idx, cursorval;
    idx = voicenum;
    cursorval = gUmt.loop[lpnum].score.songTab[tab].voice[idx].cursor;
    gUmt.loop[lpnum].score.songTab[tab].voice[idx].notes[cursorval] = {
        starttime: gUmt.loop[lpnum].score.songTab[tab].voice[idx].nextStart,
        rest: rest,
        pitch: pitch,
        duration: duration,
        amplitude: amplitude,
        instParams: instParams,
        harmOctave: -1,
        harmNum: -1,
        harmDnom: -1
    };
    cursorval = cursorval + 1;
    gUmt.loop[lpnum].score.songTab[tab].voice[idx].cursor = cursorval;
    gUmt.loop[lpnum].score.songTab[tab].voice[idx].nextStart += duration;
}

function umtTestPlayRawScore(lpnum) {
    "use strict";
    var tab, fromMoment, center, tempoScalar, numVoices, voicenum, notenum, pitch, duration, amplitude, frequency, startTime, instSpecificParams;
    tab = gUmt.UIParams.currentTab;
    fromMoment = gUmt.globalCtx.currentTime + 1;
    center = gUmt.loop[lpnum].score.songTab[tab].centernoteLog;
    tempoScalar = 60 / gUmt.loop[lpnum].score.tempo;
    numVoices = gUmt.loop[lpnum].score.songTab[tab].parts;
    for (voicenum = 0; voicenum < numVoices; voicenum = voicenum + 1) {
        for (notenum = 0; notenum < gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].cursor; notenum = notenum + 1) {
            if (gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].rest === false) {
                pitch = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].pitch;
                duration = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].duration * tempoScalar;
                amplitude = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].amplitude;
                amplitude = amplitude / numVoices;
                instSpecificParams = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].instParams;
                frequency = Math.exp((pitch + center) * gUmt.LOG2);
                startTime = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].starttime * tempoScalar;
                umtTestQueUpANoteSineWave(fromMoment, frequency, startTime, duration, amplitude, instSpecificParams);
            }
        }
    }
}

function umtExecPlayRawScore() {
    "use strict";
    umtTestPlayRawScore(gUmt.currentlyPlayingLoop);
}

// cheat sheet for scales
// ratio  interval  example key of C  logarithm  nearest equal temperment (logarithm)  difference
// 1/1    P1        C                 0.000      0.000      0.000
// 16/15  m2        C#                0.093      0.083      0.010
// 10/9   M2-alt    D-alt             0.152      0.166      0.015
// 9/8    M2-reg    D-reg             0.170      0.166      0.003
// 6/5    m3        Eb                0.263      0.250      0.013
// 5/4    M3        E                 0.322      0.333      0.011
// 4/3    P4        F                 0.415      0.417      0.002
// 25/18  A4-reg    F#                0.474      0.500      0.026
// 36/25  A4-alt    F#                0.526      0.500      0.026
// 3/2    P5        G                 0.585      0.583      0.002
// 8/5    m6        Ab                0.678      0.667      0.011
// 5/3    M6        A                 0.737      0.750      0.013
// 16/9   m7-reg    Bb-reg            0.830      0.833      0.003
// 9/5    m7-alt    Bb-alt            0.848      0.833      0.015
// 15/8   M7        B                 0.907      0.917      0.010
// 2/1    P8        C                 1.000      1.000      0.000

function umtGetScale15ChromaticTT() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 16, dnom: 15}, {num: 10, dnom: 9}, {num: 9, dnom: 8}, {num: 6, dnom: 5}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 25, dnom: 18}, {num: 36, dnom: 25}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 5, dnom: 3}, {num: 16, dnom: 9}, {num: 9, dnom: 5}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale13Chromatic() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 16, dnom: 15}, {num: 10, dnom: 9}, {num: 9, dnom: 8}, {num: 6, dnom: 5}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 5, dnom: 3}, {num: 16, dnom: 9}, {num: 9, dnom: 5}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale12ChromaticRegRegTT() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 16, dnom: 15}, {num: 9, dnom: 8}, {num: 6, dnom: 5}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 25, dnom: 18}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 5, dnom: 3}, {num: 16, dnom: 9}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale11ChromaticRegReg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 16, dnom: 15}, {num: 9, dnom: 8}, {num: 6, dnom: 5}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 5, dnom: 3}, {num: 16, dnom: 9}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale11ChromaticAltReg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 16, dnom: 15}, {num: 10, dnom: 9}, {num: 6, dnom: 5}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 5, dnom: 3}, {num: 16, dnom: 9}, {num: 9, dnom: 5}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale11ChromaticRegAlt() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 16, dnom: 15}, {num: 9, dnom: 8}, {num: 6, dnom: 5}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 5, dnom: 3}, {num: 16, dnom: 9}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale11ChromaticAltAlt() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 16, dnom: 15}, {num: 10, dnom: 9}, {num: 6, dnom: 5}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 5, dnom: 3}, {num: 16, dnom: 9}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale7MajorReg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 5, dnom: 3}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale7MajorAlt() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 10, dnom: 9}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 5, dnom: 3}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale7MinorNaturalRegReg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 16, dnom: 9} ];
    return scale;
}

function umtGetScale7MinorNaturalAltReg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 10, dnom: 9}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 16, dnom: 9} ];
    return scale;
}

function umtGetScale7MinorNaturalRegAlt() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 16, dnom: 9} ];
    return scale;
}

function umtGetScale7MinorNaturalAltAlt() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 10, dnom: 9}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 16, dnom: 9} ];
    return scale;
}

function umtGetScale7MinorHarmonicReg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale7MinorHarmonicAlt() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 10, dnom: 9}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale7MinorMelodicReg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 5, dnom: 3}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale7MinorMelodicAlt() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 10, dnom: 9}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 5, dnom: 3}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale7ArabicishMajor() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 16, dnom: 15}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 5, dnom: 3}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale7ArabicishMinor() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 16, dnom: 15}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale5Pentatonic23Reg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 5, dnom: 3} ];
    return scale;
}

function umtGetScale5Pentatonic23Alt() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 10, dnom: 9}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 5, dnom: 3} ];
    return scale;
}

function umtGetScale5Pentatonic131Reg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 16, dnom: 9} ];
    return scale;
}

function umtGetScale5Pentatonic32Reg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 5, dnom: 4}, {num: 3, dnom: 2}, {num: 5, dnom: 3} ];
    return scale;
}

function umtGetScale5Pentatonic32Alt() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 10, dnom: 9}, {num: 5, dnom: 4}, {num: 3, dnom: 2}, {num: 5, dnom: 3} ];
    return scale;
}

function umtGetScale5Pentatonic221Reg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 16, dnom: 9} ];
    return scale;
}

function umtGetScale5Pentatonic122Reg() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 8, dnom: 5}, {num: 16, dnom: 9} ];
    return scale;
}

function umtGetScale4Quadtonic() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 5, dnom: 3} ];
    return scale;
}

function umtGetScale3Tritonic() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 4, dnom: 3}, {num: 3, dnom: 2} ];
    return scale;
}

function umtGetScale2TritoneTest() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 25, dnom: 18} ];
    return scale;
}

function umtGetScale7ModeIonian() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 5, dnom: 3}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale7ModeDorian() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 5, dnom: 3}, {num: 16, dnom: 9} ];
    return scale;
}

function umtGetScale7ModePhrygian() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 16, dnom: 15}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 16, dnom: 9} ];
    return scale;
}

function umtGetScale7ModeLydianTT() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 5, dnom: 4}, {num: 25, dnom: 18}, {num: 3, dnom: 2}, {num: 5, dnom: 3}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale7ModeMixolydian() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 5, dnom: 3}, {num: 16, dnom: 9} ];
    return scale;
}

function umtGetScale7ModeAeolian() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 16, dnom: 9} ];
    return scale;
}

function umtGetScale7ModeLocrianTT() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 16, dnom: 15}, {num: 6, dnom: 5}, {num: 4, dnom: 3}, {num: 25, dnom: 18}, {num: 8, dnom: 5}, {num: 16, dnom: 9} ];
    return scale;
}

function umtGetScale7HungarianRegRegTT() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 6, dnom: 5}, {num: 25, dnom: 18}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale7Arabic() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 16, dnom: 15}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 15, dnom: 8} ];
    return scale;
}

function umtGetScale7FreygishPhrygianDominant() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 16, dnom: 15}, {num: 5, dnom: 4}, {num: 4, dnom: 3}, {num: 3, dnom: 2}, {num: 8, dnom: 5}, {num: 16, dnom: 9} ];
    return scale;
}

function umtGetScale7UkranianDorian() {
    "use strict";
    var scale = [ {num: 1, dnom: 1}, {num: 9, dnom: 8}, {num: 6, dnom: 5}, {num: 25, dnom: 18}, {num: 3, dnom: 2}, {num: 5, dnom: 3}, {num: 16, dnom: 9} ];
    return scale;
}

function umtAddFloatsToScale(originalScale) {
    "use strict";
    var num, dnom, x, newScale, i;
    newScale = [];
    for (i = 0; i < originalScale.length; i = i + 1) {
        num = originalScale[i].num;
        dnom = originalScale[i].dnom;
        x = num / dnom;
        x = Math.log(x) / gUmt.LOG2;
        newScale[i] = {num: num, dnom: dnom, fpt: x};
    }
    return newScale;
}

function umtGaussGCD(a, b) {
    "use strict";
    // Gauss's GCD algorithm
    var c, d, e, r;
    c = a;
    d = b;
    r = 1;
    while (r !== 0) {
        if (d > c) {
            e = c;
            c = d;
            d = e;
        }
        r = (c % d);
        if (r !== 0) {
            c = d;
            d = r;
        }
    }
    return d;
}

// we are using Euclid's GCD algorithm because it should be faster for small numbers. Gauss's should be faster for large numbers
function umtEuclidGCD(a, b) {
    "use strict";
    // Euclid's GCD algorithm
    while (a !== b) {
        if (a > b) {
            a = a - b;
        } else {
            b = b - a;
        }
    }
    return a;
}

function umtReduceFraction(num, dnom) {
    "use strict";
    var g, rv;
    g = umtEuclidGCD(num, dnom);
    if (g !== 1) {
        num = num / g;
        dnom = dnom / g;
    }
    rv = {num: num, dnom: dnom};
    return rv;
}

function umtIsConsonant(lowNum, lowDnom, highNum, highDnom, chord) {
    "use strict";
    var ratioNum, ratioDnom, red;
    if (chord === "any") {
        return true;
    }
    ratioNum = highNum * lowDnom;
    ratioDnom = highDnom * lowNum;
    red = umtReduceFraction(ratioNum, ratioDnom);
    if (red.dnom > 3) {
        if (chord === "perfect") {
            return false;
        }
        if (red.dnom > 5) {
            if (chord === "major") {
                return false;
            }
        }
    }
    if (red.dnom > 6) {
        if (chord === "reg") {
            if ((red.dnom !== 9) && (red.dnom !== 15) && (red.dnom !== 18) && (red.dnom !== 25)) {
                return false;
            }
        } else {
            if (chord === "alt") {
                if ((red.dnom !== 8) && (red.dnom !== 9) && (red.dnom !== 15) && (red.dnom !== 16) && (red.dnom !== 18) && (red.dnom !== 25) && (red.dnom !== 27) && (red.dnom !== 32) && (red.dnom !== 45)) {
                    return false;
                }
            } else {
                return false;
            }
        }
    }
    ratioNum = 2 * lowNum * highDnom;
    ratioDnom = lowDnom * highNum;
    red = umtReduceFraction(ratioNum, ratioDnom);
    if (red.dnom > 3) {
        if (chord === "perfect") {
            return false;
        }
        if (red.dnom > 5) {
            if (chord === "major") {
                return false;
            }
        }
    }
    if (red.dnom > 6) {
        if (chord === "reg") {
            if ((red.dnom !== 9) && (red.dnom !== 15) && (red.dnom !== 18) && (red.dnom !== 25)) {
                return false;
            }
        } else {
            if (chord === "alt") {
                if ((red.dnom !== 8) && (red.dnom !== 9) && (red.dnom !== 15) && (red.dnom !== 16) && (red.dnom !== 18) && (red.dnom !== 25) && (red.dnom !== 27) && (red.dnom !== 32) && (red.dnom !== 45)) {
                    return false;
                }
            } else {
                return false;
            }
        }
    }
    return true;
}

function umtTestIsConsonant() {
    "use strict";
    var what;
    // BUGBUG umtIsConsonant() was modified to allow 7th chords, but this test function does not test for the 7th chords
    what = umtIsConsonant(6, 5, 7, 5, false);
    if (what !== false) {
        jsabort('dissonance test 1 failed');
    }
    what = umtIsConsonant(6, 5, 8, 5, "no");
    if (what !== true) {
        jsabort('dissonance test 2 failed');
    }
    what = umtIsConsonant(6, 5, 9, 5, "no");
    if (what !== true) {
        jsabort('dissonance test 3 failed');
    }
    what = umtIsConsonant(6, 5, 5, 4, "no");
    if (what !== false) {
        jsabort('dissonance test 4 failed');
    }
    what = umtIsConsonant(6, 5, 7, 4, "no");
    if (what !== false) {
        jsabort('dissonance test 5 failed');
    }
    what = umtIsConsonant(6, 5, 4, 3, "no");
    if (what !== false) {
        jsabort('dissonance test 6 failed');
    }
    what = umtIsConsonant(6, 5, 5, 3, "no");
    if (what !== false) {
        jsabort('dissonance test 7 failed');
    }
    what = umtIsConsonant(6, 5, 3, 2, "no");
    if (what !== true) {
        jsabort('dissonance test 8 failed');
    }
    what = umtIsConsonant(5, 4, 4, 3, "no");
    if (what !== false) {
        jsabort('dissonance test 9 failed');
    }
    what = umtIsConsonant(5, 4, 5, 3, "no");
    if (what !== true) {
        jsabort('dissonance test 10 failed');
    }
    what = umtIsConsonant(5, 4, 3, 2, "no");
    if (what !== true) {
        jsabort('dissonance test 11 failed');
    }
    what = umtIsConsonant(4, 3, 3, 2, "no");
    if (what !== false) {
        jsabort('dissonance test 12 failed');
    }
    console.log('dissonance tests passed.');
}

function umtFractSubtract(firstNum, firstDnom, secondNum, secondDnom) {
    "use strict";
    // this function does not reduce the result!
    var g, s, xFNum, xFDnom, xSNum, xSDnom, rv;
    g = umtEuclidGCD(firstDnom, secondDnom);
    s = secondDnom / g;
    xFNum = firstNum * s;
    xFDnom = firstDnom * s;
    s = firstDnom / g;
    xSNum = secondNum * s;
    xSDnom = secondDnom * s;
    if (xFDnom !== xSDnom) {
        jsabort('denominators are not the same');
    }
    rv = { num: xFNum - xSNum, dnom: xFDnom };
    return rv;
}

function umtIsConsOrderInd(xnum, xdnom, ynum, ydnom, chord) {
    "use strict";
    var diff;
    // is consonant? order independent
    diff = umtFractSubtract(xnum, xdnom, ynum, ydnom);
    if (diff.num < 0) {
        // y is bigger
        return umtIsConsonant(xnum, xdnom, ynum, ydnom, chord);
    }
    // x is bigger
    return umtIsConsonant(ynum, ydnom, xnum, xdnom, chord);
}

// need caching for this function -- recalculating dissonance every time is computationally expensive
function umtDetermineIfFits(num, dnom, listOfNotesAlreadyPlaying, chord) {
    "use strict";
    var lx, i, diff, cacheidxname;
    cacheidxname = "udif" + num + "," + dnom + "," + chord;
    lx = listOfNotesAlreadyPlaying.length;
    for (i = 0; i < lx; i = i + 1) {
        cacheidxname = cacheidxname + "," + listOfNotesAlreadyPlaying[i].num + "," + listOfNotesAlreadyPlaying[i].dnom;
    }
    if (gUmt.cachedFittings.hasOwnProperty(cacheidxname)) {
        return gUmt.cachedFittings[cacheidxname];
    }
    for (i = 0; i < lx; i = i + 1) {
        diff = umtFractSubtract(num, dnom, listOfNotesAlreadyPlaying[i].num, listOfNotesAlreadyPlaying[i].dnom);
        if (diff.num < 0) {
            // already playing is bigger
            if (umtIsConsonant(num, dnom, listOfNotesAlreadyPlaying[i].num, listOfNotesAlreadyPlaying[i].dnom, chord) === false) {
                gUmt.cachedFittings[cacheidxname] = false;
                return false;
            }
        } else {
            // num/dom is bigger
            if (umtIsConsonant(listOfNotesAlreadyPlaying[i].num, listOfNotesAlreadyPlaying[i].dnom, num, dnom, chord) === false) {
                gUmt.cachedFittings[cacheidxname] = false;
                return false;
            }
        }
    }
    gUmt.cachedFittings[cacheidxname] = true;
    return true;
}

function umtFindMostHarmonicNote(pitch, scale, listOfNotesAlreadyPlaying, chord) {
    "use strict";
    var octave, minIdx, minDist, i, dist, rv, originalFullPitch, numOfNotes, topPos, topOctave, bottomPos, bottomOctave, cycCount, topDist, bottomDist, currentPos, currentOctave;
    originalFullPitch = pitch;
    octave = Math.floor(pitch);
    pitch = pitch - octave;
    minIdx = -1;
    minDist = 1.0 - pitch;
    numOfNotes = scale.length;
    for (i = 0; i < numOfNotes; i = i + 1) {
        dist = Math.abs(scale[i].fpt - pitch);
        if (dist < minDist) {
            minIdx = i;
            minDist = dist;
        }
    }
    if (listOfNotesAlreadyPlaying.length === 0) {
        if (minIdx === -1) {
            octave = octave + 1;
            rv = {octave: octave, scalenote: 0, num: scale[0].num, dnom: scale[0].dnom, fpt: scale[0].fpt };
        } else {
            rv = {octave: octave, scalenote: minIdx, num: scale[minIdx].num, dnom: scale[minIdx].dnom, fpt: scale[minIdx].fpt };
        }
        return rv;
    }
    // there are other notes playing: so we can't simply return the best scale
    // match. so we have to find another note.

    // the idea here is to "fan out" -- take the "min" note found above, start
    // with the scale notes directly above and below, and test the closest one
    // to see if it harmonizes with the existing notes. if it doesn't, push it
    // up/down and go through the loop again. mathematically we should be
    // guaranteed to find a match, even if it's a P1 with an existing note.
    if (minIdx === -1) {
        minIdx = 0;
        octave = octave + 1;
    }
    topPos = minIdx;
    topOctave = octave;
    bottomPos = minIdx;
    bottomOctave = octave;
    cycCount = 0;
    while (true) {
        cycCount = cycCount + 1;
        if (cycCount === 100) {
            jsabort('crash because stuck in endless loop (1864)');
        }
        topDist = Math.abs((topOctave + scale[topPos].fpt) - originalFullPitch);
        bottomDist = Math.abs((bottomOctave + scale[bottomPos].fpt) - originalFullPitch);
        if (topDist < bottomDist) {
            currentPos = topPos;
            currentOctave = topOctave;
            topPos = topPos + 1;
            if (topPos === numOfNotes) {
                topOctave = topOctave + 1;
                topPos = 0;
            }
        } else {
            currentPos = bottomPos;
            currentOctave = bottomOctave;
            bottomPos = bottomPos - 1;
            if (bottomPos < 0) {
                bottomOctave = bottomOctave - 1;
                bottomPos = numOfNotes - 1;
            }
        }
        if (umtDetermineIfFits(scale[currentPos].num, scale[currentPos].dnom, listOfNotesAlreadyPlaying, chord)) {
            rv = {octave: currentOctave, scalenote: currentPos, num: scale[currentPos].num, dnom: scale[currentPos].dnom, fpt: scale[currentPos].fpt };
            return rv;
        }
    }
}

function umtSanitTestEntireScore(lpnum, doOutput, chord) {
    "use strict";
    var parts, tab, currentTime, beyondAll, stillGoing, bustOutCount, playingNow, pncount, vcnum, notenum, partlen, i, x, y, result, xnum, ynum, xdnom, ydnom, xrest, yrest, descrip;
    parts = gUmt.loop[lpnum].score.songTab[tab].parts;
    tab = gUmt.UIParams.currentTab;
    currentTime = 0;
    stillGoing = true;
    bustOutCount = 0;
    while (stillGoing) {
        bustOutCount = bustOutCount + 1;
        if (bustOutCount === 1024) {
            jsabort('ugh, we are stuck in an endless loop.');
        }
        beyondAll = true;
        playingNow = [];
        pncount = 0;
        for (vcnum = 0; vcnum < parts; vcnum = vcnum + 1) {
            partlen = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].cursor;
            for (i = 0; i < partlen; i = i + 1) {
                if (gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[i].harmDnom >= 0) {
                    if (gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[i].starttime <= currentTime) {
                        if (gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[i].starttime + gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[i].duration > currentTime) {
                            playingNow[pncount] = {voice: vcnum, note: i};
                            pncount = pncount + 1;
                            beyondAll = false;
                        }
                    }
                }
            }
        }
        if (doOutput) {
//            if (pncount > 0) {
//                playingNow[0].note = 1; /  * evil hack to force a dissonance for testing purposes
//            }
            descrip = '';
            for (i = 0; i < pncount; i = i + 1) {
                vcnum = playingNow[i].voice;
                notenum = playingNow[i].note;
                xnum = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[notenum].harmNum;
                xdnom = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[notenum].harmDnom;
                descrip = descrip + ' and ' + xnum + ' / ' + xdnom;
            }
        }
        for (x = 0; x < pncount - 1; x = x + 1) {
            for (y = x + 1; y < pncount; y = y + 1) {
                vcnum = playingNow[x].voice;
                notenum = playingNow[x].note;
                xnum = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[notenum].harmNum;
                xdnom = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[notenum].harmDnom;
                xrest = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[notenum].rest;
                vcnum = playingNow[y].voice;
                notenum = playingNow[y].note;
                ynum = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[notenum].harmNum;
                ydnom = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[notenum].harmDnom;
                yrest = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[notenum].rest;
                if ((xrest === false) && (yrest === false)) {
                    result = umtIsConsOrderInd(xnum, xdnom, ynum, ydnom, chord);
                    if (result === false) {
                        jsabort('BANG!! we just ran into dissonance!');
                    }
                }
            }
        }
        if (beyondAll) {
            stillGoing = false;
        } else {
            currentTime = currentTime + 1;
        }
    }
}

function umtGetScaleByAbbrv(scaleAbbrv) {
    "use strict";
    switch (scaleAbbrv) {
    case 'chroma13':
        return umtGetScale13Chromatic();
    case 'chroma11regreg':
        return umtGetScale11ChromaticRegReg();
    case 'maj7reg':
        return umtGetScale7MajorReg();
    case 'minnat7regreg':
        return umtGetScale7MinorNaturalRegReg();
    case 'minharm7reg':
        return umtGetScale7MinorHarmonicReg(); // use this one
    case 'minmelo7reg':
        return umtGetScale7MinorMelodicReg();
    case 'arabicmaj7':
        return umtGetScale7ArabicishMajor();
    case 'arabicmin7':
        return umtGetScale7ArabicishMinor();
    case 'pentatonic23reg':
        return umtGetScale5Pentatonic23Reg();
    case 'pentatonic131reg':
        return umtGetScale5Pentatonic131Reg();
    case 'pentatonic32reg':
        return umtGetScale5Pentatonic32Reg();
    case 'pentatonic221reg':
        return umtGetScale5Pentatonic221Reg();
    case 'pentatonic122reg':
        return umtGetScale5Pentatonic122Reg();
    case 'quad':
        return umtGetScale4Quadtonic();
    case 'tri':
        return umtGetScale3Tritonic();
    case 'chroma11altreg':
        return umtGetScale11ChromaticAltReg();
    case 'chroma11regalt':
        return umtGetScale11ChromaticRegAlt();
    case 'chroma11altalt':
        return umtGetScale11ChromaticAltAlt();
    case 'maj7alt':
        return umtGetScale7MajorAlt();
    case 'minnat7altreg':
        return umtGetScale7MinorNaturalAltReg();
    case 'minnat7regalt':
        return umtGetScale7MinorNaturalRegAlt();
    case 'minnat7altalt':
        return umtGetScale7MinorNaturalAltAlt();
    case 'minharm7alt':
        return umtGetScale7MinorHarmonicAlt();
    case 'minmelo7alt':
        return umtGetScale7MinorMelodicAlt();
    case 'pentatonic23alt':
        return umtGetScale5Pentatonic23Alt();
    case 'pentatonic32alt':
        return umtGetScale5Pentatonic32Alt();
    case 'tritone2test':
        return umtGetScale2TritoneTest();
    case 'ionian7':
        return umtGetScale7ModeIonian();
    case 'dorian7':
        return umtGetScale7ModeDorian();
    case 'phrygian7':
        return umtGetScale7ModePhrygian();
    case 'lydian7tt':
        return umtGetScale7ModeLydianTT();
    case 'mixolydian7':
        return umtGetScale7ModeMixolydian();
    case 'aeolian7':
        return umtGetScale7ModeAeolian();
    case 'locrian7tt':
        return umtGetScale7ModeLocrianTT();
    case 'hungarian7tt':
        return umtGetScale7HungarianRegRegTT();
    case 'chroma15tt':
        return umtGetScale15ChromaticTT();
    case 'chroma12regregtt':
        return umtGetScale12ChromaticRegRegTT();
    case 'arabic7':
        return umtGetScale7Arabic();
    case 'freygish7':
        return umtGetScale7FreygishPhrygianDominant();
    case 'ukranian7':
        return umtGetScale7UkranianDorian();
    default:
        jsabort("unrecognized scale code: " + scaleAbbrv);
        break;
    }
}

function umtHarmonizeScore(lpnum, tab) {
    "use strict";
    var theScale, chord, parts, vcnum, notecount, i, currentTime, currentPosition, timeRemaining, offEnd, stillGoing, maxFound, cycleCount, stillUnfoundMaxes, cycleUnfoundCount, maxIdx, poz, listOfNotesAlreadyPlaying, harmonizedInfo, minIdx, dist, lonapCursr;
    theScale = umtAddFloatsToScale(umtGetScaleByAbbrv(gUmt.loop[lpnum].score.songTab[tab].scale));
    chord = gUmt.loop[lpnum].score.songTab[tab].chord;
    // clear old data
    parts = gUmt.loop[lpnum].score.songTab[tab].parts;
    for (vcnum = 0; vcnum < parts; vcnum = vcnum + 1) {
        notecount = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].cursor;
        for (i = 0; i < notecount; i = i + 1) {
            gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[i].harmOctave = -1;
            gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[i].harmNum = -1;
            gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[i].harmDnom = -1;
        }
    }
    // and off we go
    // this is a tricky function that absolutely relies on the position in the
    // notes array and the duration information being exactly right

    // the way it works is by setting current position to 0, and then advancing
    // the current position when time runs out, and setting the time remaining
    // to the duration of that note.

    // on each cycle, it subtracts the duration of the shortest note from each
    // of the 'time remaining' values for every note

    // however, while it uses the shortest note (minIdx) for subtracting time
    // (and thereby virtually 'plays' the piece), it uses the longest note
    // (maxIdx) for setting the harmony first

    // maxIdx is actually the longest "unharmonized" note -- not necessarily
    // the longest note
    currentTime = 0;
    currentPosition = [];
    for (i = 0; i < parts; i = i + 1) {
        currentPosition[i] = 0;
    }
    timeRemaining = [];
    for (i = 0; i < parts; i = i + 1) {
        timeRemaining[i] = gUmt.loop[lpnum].score.songTab[tab].voice[i].notes[currentPosition[i]].duration;
    }
    offEnd = [];
    for (i = 0; i < parts; i = i + 1) {
        if (currentPosition[i] === gUmt.loop[lpnum].score.songTab[tab].voice[i].cursor) {
            offEnd[i] = true;
        } else {
            offEnd[i] = false;
        }
    }
    stillGoing = false;
    for (i = 0; i < parts; i = i + 1) {
        if (offEnd[i] === false) {
            stillGoing = true;
        }
    }
    maxFound = [];
    cycleCount = 0;
    while (stillGoing) {
        cycleCount = cycleCount + 1;
        if (cycleCount > 3072) {
            jsabort('caught in endless loop?  cycle count blew up. (2112)');
            return;
        }
        for (i = 0; i < parts; i = i + 1) {
            maxFound[i] = false;
        }
        stillUnfoundMaxes = false;
        for (i = 0; i < parts; i = i + 1) {
            if (offEnd[i] === false) {
                if (maxFound[i] === false) {
                    stillUnfoundMaxes = true;
                }
            }
        }
        cycleUnfoundCount = 0;
        while (stillUnfoundMaxes) {
            cycleUnfoundCount = cycleUnfoundCount + 1;
            if (cycleUnfoundCount > 100) {
                jsabort('kot in endless looooop?? cycle count unfound blew up.');
                return;
            }
            // find max
            maxIdx = -1;
            for (i = 0; i < parts; i = i + 1) {
                if (offEnd[i] === false) {
                    if (maxFound[i] === false) {
                        if (maxIdx === -1) {
                            maxIdx = i;
                        } else {
                            if (timeRemaining[i] > timeRemaining[maxIdx]) {
                                maxIdx = i;
                            }
                        }
                    }
                }
            }
            if (maxIdx === -1) {
                jsabort('maxIdx is -1 -- should be impossible');
                return;
            }
            maxFound[maxIdx] = true;
            // here is the actual "harmonization" code -- everything else is
            // just looping
            if (gUmt.loop[lpnum].score.songTab[tab].voice[maxIdx].notes[currentPosition[maxIdx]].harmDnom === -1) {
                poz = currentPosition[maxIdx];
                // find all other notes that are turned on at the same time
                listOfNotesAlreadyPlaying = [];
                lonapCursr = 0;
                for (i = 0; i < parts; i = i + 1) {
                    if (currentPosition[i] < gUmt.loop[lpnum].score.songTab[tab].voice[i].cursor) { // check that we're not off the end
                        if (gUmt.loop[lpnum].score.songTab[tab].voice[i].notes[currentPosition[i]].harmDnom !== -1) {
                            // sanity check 2
                            if (currentTime < gUmt.loop[lpnum].score.songTab[tab].voice[i].notes[currentPosition[i]].starttime) {
                                jsabort('START TIME IS AFTER CURRENT TIME! OH NO!');
                            }
                            if (currentTime >= (gUmt.loop[lpnum].score.songTab[tab].voice[i].notes[currentPosition[i]].starttime + gUmt.loop[lpnum].score.songTab[tab].voice[i].notes[currentPosition[i]].duration)) {
                                jsabort('START TIME + DURATION IS BEFORE CURRENT TIME!! OH NO!!');
                            }
                            if (gUmt.loop[lpnum].score.songTab[tab].voice[i].percussion === false) {
                                if (gUmt.loop[lpnum].score.songTab[tab].voice[i].notes[currentPosition[i]].rest === false) {
                                    listOfNotesAlreadyPlaying[lonapCursr] = {
                                        octave: gUmt.loop[lpnum].score.songTab[tab].voice[i].notes[currentPosition[i]].harmOctave,
                                        num: gUmt.loop[lpnum].score.songTab[tab].voice[i].notes[currentPosition[i]].harmNum,
                                        dnom: gUmt.loop[lpnum].score.songTab[tab].voice[i].notes[currentPosition[i]].harmDnom
                                    };
                                    lonapCursr = lonapCursr + 1;
                                }
                            }
                        }
                    }
                }
                harmonizedInfo = umtFindMostHarmonicNote(gUmt.loop[lpnum].score.songTab[tab].voice[maxIdx].notes[poz].pitch, theScale, listOfNotesAlreadyPlaying, chord);
                // sanity check 1
                if (currentTime !== gUmt.loop[lpnum].score.songTab[tab].voice[maxIdx].notes[currentPosition[maxIdx]].starttime) {
                    cx('START TIMES DO NOT MATCH! OH NO!');
                    cx('currentTime is ' + currentTime);
                    cx('gUmt.loop[lpnum].score.songTab[tab].voice[maxIdx].notes[currentPosition[maxIdx]].starttime is ' + gUmt.loop[lpnum].score.songTab[tab].voice[maxIdx].notes[currentPosition[maxIdx]].starttime);
                    cx('lpnum is ' + lpnum);
                    cx('maxIdx is ' + maxIdx);
                    cx('currentPosition[maxIdx] is ' + currentPosition[maxIdx]);
                    console.log('gUmt', gUmt);
                    jsabort('START TIMES DO NOT MATCH! OH NO!');
                }
                gUmt.loop[lpnum].score.songTab[tab].voice[maxIdx].notes[currentPosition[maxIdx]].harmOctave = harmonizedInfo.octave;
                gUmt.loop[lpnum].score.songTab[tab].voice[maxIdx].notes[currentPosition[maxIdx]].harmNum = harmonizedInfo.num;
                gUmt.loop[lpnum].score.songTab[tab].voice[maxIdx].notes[currentPosition[maxIdx]].harmDnom = harmonizedInfo.dnom;
                // umtSanitTestEntireScore(lpnum, false);
            }
            // end of actual "harmonization" code"
            stillUnfoundMaxes = false; // this loop could no doubt be optimized
            for (i = 0; i < parts; i = i + 1) {
                if (offEnd[i] === false) {
                    if (maxFound[i] === false) {
                        stillUnfoundMaxes = true;
                    }
                }
            }
        }
        // find min
        minIdx = -1;
        for (i = 0; i < parts; i = i + 1) {
            if (offEnd[i] === false) {
                if (minIdx === -1) {
                    minIdx = i;
                } else {
                    if (timeRemaining[i] < timeRemaining[minIdx]) {
                        minIdx = i;
                    }
                }
            }
        }
        // subtract dist
        dist = timeRemaining[minIdx];
        currentTime += dist;
        for (i = 0; i < parts; i = i + 1) {
            if (offEnd[i] === false) {
                timeRemaining[i] -= dist;
            }
        }
        // advance positions
        for (i = 0; i < parts; i = i + 1) {
            if (offEnd[i] === false) {
                if (timeRemaining[i] === 0) {
                    currentPosition[i] = currentPosition[i] + 1;
                    if (currentPosition[i] === gUmt.loop[lpnum].score.songTab[tab].voice[i].cursor) {
                        offEnd[i] = true;
                    } else {
                        timeRemaining[i] = gUmt.loop[lpnum].score.songTab[tab].voice[i].notes[currentPosition[i]].duration;
                    }
                }
            }
        }
        for (i = 0; i < parts; i = i + 1) {
            if (currentPosition[i] === gUmt.loop[lpnum].score.songTab[tab].voice[i].cursor) {
                offEnd[i] = true;
            }
        }
        stillGoing = false;
        for (i = 0; i < parts; i = i + 1) {
            if (offEnd[i] === false) {
                stillGoing = true;
            }
        }
    }
    // umtSanitTestEntireScore(lpnum, true);
    // cx('umtHarmonizeScore(lpnum) done');
}

function umtExecHarmonizeScore() {
    "use strict";
    umtHarmonizeScore(0, 0);
}

function umtPlayHarmonized(lpnum) {
    "use strict";
    var tab, fromMoment, center, tempoScalar, numVoices, voicenum, notenum, duration, amplitude, frequency, startTime, instSpecificParams, harmonizedOctave, harmonizedNum, harmonizedDnom, instrument;
    tab = gUmt.UIParams.currentTab;
    fromMoment = gUmt.globalCtx.currentTime + 1;
    center = gUmt.loop[lpnum].score.songTab[tab].centernoteLog;
    tempoScalar = 60 / gUmt.loop[lpnum].score.tempo;
    numVoices = gUmt.loop[lpnum].score.songTab[tab].parts;
    for (voicenum = 0; voicenum < numVoices; voicenum = voicenum + 1) {
        for (notenum = 0; notenum < gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].cursor; notenum = notenum + 1) {
            if (gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].rest === false) {
                harmonizedOctave = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].harmOctave;
                harmonizedNum = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].harmNum;
                harmonizedDnom = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].harmDnom;
                duration = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].duration * tempoScalar;
                amplitude = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].amplitude;
                amplitude = amplitude / numVoices;
                instSpecificParams = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].instParams;
                frequency = Math.exp((harmonizedOctave + center) * gUmt.LOG2);
                frequency = frequency * (harmonizedNum / harmonizedDnom);
                startTime = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].starttime * tempoScalar;
                instrument = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].instrument;
                cx("(1155) instrument: " + instrument);
                if (instrument === 0) {
                    umtTestQueUpANoteSineWave(fromMoment, frequency, startTime, duration, amplitude, instSpecificParams);
                } else {
                    umtTestQueUpANoteSineWave(fromMoment, frequency, startTime, duration, amplitude, instSpecificParams);
                }
            }
        }
    }
}

function umtDumpHarmonized(lpnum) {
    "use strict";
    var tab, numVoices, voicenum, notenum, duration, amplitude, startTime, harmonizedOctave, harmonizedNum, harmonizedDnom;
    tab = gUmt.UIParams.currentTab;
    numVoices = gUmt.loop[lpnum].score.songTab[tab].parts;
    cx('numVoices is ' + numVoices);
    for (voicenum = 0; voicenum < numVoices; voicenum = voicenum + 1) {
        cx('  voicenum is ' + voicenum);
        for (notenum = 0; notenum < gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].cursor; notenum = notenum + 1) {
            harmonizedOctave = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].harmOctave;
            harmonizedNum = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].harmNum;
            harmonizedDnom = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].harmDnom;
            duration = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].duration;
            amplitude = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].amplitude;
            amplitude = amplitude / numVoices;
            startTime = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].starttime;
            if (gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].rest) {
                cx('    note ' + notenum + ', start ' + startTime + ', duration ' + duration + ', rest');
            } else {
                cx('    note ' + notenum + ', start ' + startTime + ', duration ' + duration + ', octave ' + harmonizedOctave + ', num ' + harmonizedNum + ', dnom ' + harmonizedDnom + ', amplitude ' + amplitude);
            }
        }
    }
}

function umtExecPlayHarmonized() {
    "use strict";
    umtPlayHarmonized(0);
}

function umtExecRunTests() {
    "use strict";
    umtTestIsConsonant();
    window.alert('Tests passed.');
}

function umtExecDisonanceTest() {
    "use strict";
    var firstNum, firstDnom, secondNum, secondDnom, diff, result;
    firstNum = document.getElementById('firstNum').value;
    firstNum = parseInt(firstNum, 10);
    cx('firstNum is ' + firstNum);
    firstDnom = document.getElementById('firstDnom').value;
    firstDnom = parseInt(firstDnom, 10);
    cx('firstDnom is ' + firstDnom);
    secondNum = document.getElementById('secondNum').value;
    secondNum = parseInt(secondNum, 10);
    cx('secondNum is ' + secondNum);
    secondDnom = document.getElementById('secondDnom').value;
    secondDnom = parseInt(secondDnom, 10);
    cx('secondDnom is ' + secondDnom);
    cx('  so we got ' + firstNum + ' / ' + firstDnom + ', ' + secondNum + ' / ' + secondDnom);
    diff = umtFractSubtract(firstNum, firstDnom, secondNum, secondDnom);
    cx('diff is ' + diff.num + ' / ' + diff.dnom);
    if (diff.num < 0) {
        // second is bigger
        cx('second is bigger');
        result = umtIsConsonant(firstNum, firstDnom, secondNum, secondDnom, "no");
    } else {
        // first is bigger
        cx('first is bigger');
        result = umtIsConsonant(secondNum, secondDnom, firstNum, firstDnom, "no");
    }
    cx('result is ' + result);
    if (result) {
        window.alert('consonant');
    } else {
        window.alert('DISSONANT');
    }
}

function umtGenRhythmSubset(randomObj, minSize, chunkSize) {
    "use strict";
    var setSize, rv, currentTime, position, amountLeft, dur;
    setSize = chunkSize / minSize;
    rv = [];
    currentTime = 0;
    position = 0;
    while (currentTime < setSize) {
        amountLeft = setSize - currentTime;
        if (amountLeft === 1) {
            dur = 1;
        } else {
            dur = Math.floor(randomObj.genrandReal2() * amountLeft + 1);
        }
        rv[position] = dur * minSize;
        position = position + 1;
        currentTime = currentTime + dur;
    }
    return rv;
}

function umtGenerateRhythm(randomObj, minSize, chunkSize, totalLength) {
    "use strict";
    var rv, currentStart, chunkData, endPt, chunkLen, idx;
    if (chunkSize === totalLength) {
        return umtGenRhythmSubset(randomObj, minSize, chunkSize);
    }
    rv = [];
    for (currentStart = 0; currentStart < totalLength; currentStart = currentStart + chunkSize) {
        chunkData = umtGenRhythmSubset(randomObj, minSize, chunkSize);
        endPt = rv.length;
        chunkLen = chunkData.length;
        for (idx = 0; idx < chunkLen; idx = idx + 1) {
            rv[endPt + idx] = chunkData[idx];
        }
    }
    return rv;
}

function umtAddSymmetryBaseToVoice(lpnum, tab, vcnum, minSize, chunkSize, totalLength, centerOctave, restyness, noteDistance, ampVariation, volume, instrumentName, instrumentParamNames, instSpecificParams) {
    "use strict";
    var rhythm, lenRhy, idx, duration, pitch, amplitude, volscalar, instParamCurrent, instParCount, instParamIdx, ourParamName, paramvalue;
    volscalar = 2.7;
    volume = Math.exp(volume * volscalar) / Math.exp(volscalar); // this is done to "logarithmize" the volume slider
    rhythm = umtGenerateRhythm(gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].randRhythm, minSize, chunkSize, totalLength);
    lenRhy = rhythm.length;
    for (idx = 0; idx < lenRhy; idx = idx + 1) {
        duration = rhythm[idx];
        pitch = (gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].randPitch.genrandReal2() * (2 * noteDistance)) - noteDistance;
        if (gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].randRests.genrandReal2() < restyness) {
            umtAddNote(lpnum, tab, vcnum, true, centerOctave, duration, 1, null);
        } else {
            amplitude = (1.0 - (gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].randAmp.genrandReal2() * ampVariation) * 0.9) * volume;
            // The idea here is to go through the param names for this instrument and pull out the corresponding "patterns" value from instSpecificParams
            // We ignore all parameters that don't apply to the current instrument. This way the user can flip between instruments and the system won't forget their previous settings.
            instParamCurrent = {};
            instParCount = 0;
            for (instParamIdx in instrumentParamNames) {
                if (instrumentParamNames.hasOwnProperty(instParamIdx)) {
                    ourParamName = instrumentParamNames[instParamIdx].name;
                    if (instSpecificParams.hasOwnProperty(instrumentName + "_" + ourParamName + "_patterns")) {
                        paramvalue = instSpecificParams[instrumentName + "_" + ourParamName + "_patterns"];
                        instParamCurrent[ourParamName] = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].randInstPat.genrandReal2() * paramvalue;
                        instParCount = instParCount + 1;
                    }
                }
            }
            if (instParCount === 0) {
                instParamCurrent = null;
            }
            umtAddNote(lpnum, tab, vcnum, false, centerOctave + pitch, duration, amplitude, instParamCurrent);
        }
    }
}

function umtSchedulePlayOfNote(lpnum, tab, voicenum, notenum, ampScalar, tempoScalar, center, adjustedStartTime) {
    "use strict";
    var harmonizedOctave, harmonizedNum, harmonizedDnom, duration, amplitude, instSpecificParams, frequency, instrument;
    if (gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].rest === false) {
        harmonizedOctave = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].harmOctave;
        harmonizedNum = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].harmNum;
        harmonizedDnom = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].harmDnom;
        duration = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].duration * tempoScalar;
        amplitude = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].amplitude;
        amplitude = (amplitude * Math.exp((amplitude - 1.0) * 2.0)) * ampScalar;
        instSpecificParams = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].instParams;
        frequency = Math.exp((harmonizedOctave + center) * gUmt.LOG2);
        frequency = frequency * (harmonizedNum / harmonizedDnom);
        instrument = gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].instrument;
        gUmt.instrumentBank[instrument].queUpANote(adjustedStartTime, frequency, duration, amplitude, instSpecificParams);
    }
}

var umtExecReSeed;

function umtSchedulePlayOfSegment() {
    "use strict";
    var tab, lpnum, currentTime, compositonlag, windowStart, windowStop, loopUnitLen, loopLen, numLoopTabCycles, fromMoment, center, tempoScalar, numVoices, voicenum, notenum, adjustedStartTime, masterVolScaler, ampScalar, regularTime, timeInMs, interval, numTabs, numLoopTotalCycles;
    tab = gUmt.UIParams.currentTab;
    lpnum = gUmt.currentlyPlayingLoop;
    // if (gUmt.loop[lpnum].score.playAllTabs) {
    //     cx("Scheduling playback of segment from tab ALL, loop " + ctstr(lpnum));
    // } else {
    //     cx("Scheduling playback of segment from tab " + ctstr(tab) + ", loop " + ctstr(lpnum));
    // }
    currentTime = gUmt.globalCtx.currentTime;
    // figure out our playback window for the segment we are going to play in this timer callback
    windowStart = currentTime;
    compositonlag = gUmt.compositionLag;
    if (compositonlag < 0.1) {
        compositonlag = 0.1;
    }
    windowStop = currentTime + (compositonlag * 2.5);
    if (windowStart < gUmt.playedUpTo) {
        windowStart = gUmt.playedUpTo;
    }
    masterVolScaler = gUmt.UIParams.mastervol; // Math.exp((gUmt.UIParams.mastervol - 1.0) * 2.0);
    if (gUmt.loop[gUmt.currentlyPlayingLoop].score.songTab[tab].parts > 0) {
        // stuff that applies to all notes
        loopUnitLen = gUmt.loop[lpnum].score.songTab[tab].voice[0].nextStart;
        tempoScalar = 60 / gUmt.loop[lpnum].score.tempo;
        loopLen = loopUnitLen * tempoScalar;
        numLoopTabCycles = Math.floor(windowStart / loopLen);
        fromMoment = numLoopTabCycles * loopLen;
        center = gUmt.loop[lpnum].score.songTab[tab].centernoteLog;
        numVoices = gUmt.loop[lpnum].score.songTab[tab].parts;
        if (numVoices === 1) {
            ampScalar = masterVolScaler / 1.4142135623730951;
        } else {
            ampScalar = masterVolScaler / numVoices;
        }
        if (gUmt.loop[lpnum].score.playAllTabs) {
            // figure out which tab
            numTabs = gUmt.loop[lpnum].score.numTabs;
            numLoopTotalCycles = Math.floor(numLoopTabCycles / numTabs);
            tab = numLoopTabCycles - (numLoopTotalCycles * numTabs);
            // currrent tab
            // cx("    playback current tab " + ctstr(tab));
            // because we switched tabs, numVoices and other things may have changed, so we have to recalculate them
            center = gUmt.loop[lpnum].score.songTab[tab].centernoteLog;
            numVoices = gUmt.loop[lpnum].score.songTab[tab].parts;
            if (numVoices === 1) {
                ampScalar = masterVolScaler / 1.4142135623730951;
            } else {
                ampScalar = masterVolScaler / numVoices;
            }
            for (voicenum = 0; voicenum < numVoices; voicenum = voicenum + 1) {
                for (notenum = 0; notenum < gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].cursor; notenum = notenum + 1) {
                    adjustedStartTime = (gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].starttime * tempoScalar) + fromMoment;
                    if (adjustedStartTime >= windowStart) {
                        if (adjustedStartTime < windowStop) {
                            umtSchedulePlayOfNote(lpnum, tab, voicenum, notenum, ampScalar, tempoScalar, center, adjustedStartTime);
                        }
                    }
                }
            }
            // next tab
            tab = tab + 1;
            if (tab === numTabs) {
                tab = 0;
            }
            // cx("        playback next tab " + ctstr(tab));
            if (gUmt.loop[gUmt.currentlyPlayingLoop].score.songTab[tab].parts > 0) {
                // because we switched tabs, numVoices and other things may have changed, so we have to recalculate them
                center = gUmt.loop[lpnum].score.songTab[tab].centernoteLog;
                numVoices = gUmt.loop[lpnum].score.songTab[tab].parts;
                if (numVoices === 1) {
                    ampScalar = masterVolScaler / 1.4142135623730951;
                } else {
                    ampScalar = masterVolScaler / numVoices;
                }
                for (voicenum = 0; voicenum < numVoices; voicenum = voicenum + 1) {
                    for (notenum = 0; notenum < gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].cursor; notenum = notenum + 1) {
                        adjustedStartTime = (gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].starttime * tempoScalar) + fromMoment;
                        adjustedStartTime = adjustedStartTime + loopLen;
                        if (adjustedStartTime < windowStop) {
                            umtSchedulePlayOfNote(lpnum, tab, voicenum, notenum, ampScalar, tempoScalar, center, adjustedStartTime);
                        }
                    }
                }
            }
        } else {
            for (voicenum = 0; voicenum < numVoices; voicenum = voicenum + 1) {
                for (notenum = 0; notenum < gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].cursor; notenum = notenum + 1) {
                    adjustedStartTime = (gUmt.loop[lpnum].score.songTab[tab].voice[voicenum].notes[notenum].starttime * tempoScalar) + fromMoment;
                    if (adjustedStartTime < windowStart) {
                        adjustedStartTime = adjustedStartTime + loopLen;
                    }
                    if (adjustedStartTime < windowStop) {
                        umtSchedulePlayOfNote(lpnum, tab, voicenum, notenum, ampScalar, tempoScalar, center, adjustedStartTime);
                    }
                }
            }
        }
    }
    gUmt.playedUpTo = windowStop;
    // hack -- UI logic in the playback system?
    if (document.getElementById("continuous").checked) {
        regularTime = new Date(); // year, month [, day, hour, minute, second, millisecond]);
        timeInMs = regularTime.getTime();
        interval = timeInMs - gUmt.lastReSeedTime;
        cx(interval);
        if ((interval > 120000) || (interval < 0)) {
            umtExecReSeed();
        }
    }
    if (gUmt.timerIsOn) {
        if (compositonlag > 1.0) {
            compositonlag = 1.0;
        }
        window.setTimeout(umtSchedulePlayOfSegment, compositonlag * 1000);
    }
}

function umtDoTimerPulse() {
    "use strict";
    umtSchedulePlayOfSegment();
}

function umtAutomaticStart(lpnum) {
    "use strict";
    gUmt.currentlyPlayingLoop = lpnum;
    if (!gUmt.timerIsOn) {
        window.setTimeout(umtDoTimerPulse, 500);
    }
    gUmt.timerIsOn = true;
}

function umtAutomaticStop() {
    "use strict";
    gUmt.timerIsOn = false;
}

function umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose) {
    "use strict";
    var segmentStart, ix, segmentEnd, tsRhCursor, tsPiCursor, minPitch, maxPitch, thisPitch, midpointPitch, rhythmCursor, pitchCursor, terminationCursor, rest, duration, amplitude, instParams, percent, bevelAmount, segmentLen, rangeTestStart, rangeTestEnd, rangeTestCursor, rangePitch, rangeMin, rangeMax, rangeScalar, rangeTranspose;
    // first find the start and end of the segment, and the starting point for the rhythm cursor (tsRhCursor) and pitch cursor (tsPiCursor) which can be different if there is rhythm or pitch scrolling
    segmentStart = -1;
    tsRhCursor = -1; // ts == "time scroll"; rh == "rhythm", pi == "pitch"
    tsPiCursor = -1;
    for (ix = 0; ix < gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].cursor; ix = ix + 1) {
        // yes, we search the whole voice -- this is ok because loops are short.
        // If the sytem is ever used for long compositions, this will need to
        // be replaced with interval halving
        if (segmentStart === -1) {
            if (gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[ix].starttime >= startTime) {
                segmentStart = ix;
                maxPitch = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[ix].pitch;
                minPitch = maxPitch;
            }
        }
        if (gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[ix].starttime < endTime) {
            segmentEnd = ix;
        }
        if (tsRhCursor === -1) {
            if (gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[ix].starttime >= (startTime + timeRhythmScroll)) {
                tsRhCursor = ix;
            }
        }
        if (tsPiCursor === -1) {
            if (gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[ix].starttime >= (startTime + timePitchScroll)) {
                tsPiCursor = ix;
            }
        }
        if ((gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[ix].starttime >= startTime) && (gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[ix].starttime < endTime)) {
            // if notes are "playing" get min and max
            // we need min and max for scrolling effect
            thisPitch = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[ix].pitch;
            if (thisPitch > maxPitch) {
                maxPitch = thisPitch;
            }
            if (thisPitch < minPitch) {
                minPitch = thisPitch;
            }
        }
    }
    if (tsRhCursor === -1) {
        tsRhCursor = 0;
    }
    if (tsPiCursor === -1) {
        tsPiCursor = 0;
    }
    segmentLen = segmentEnd - segmentStart + 1;
    midpointPitch = (minPitch + maxPitch) / 2;
    // time scroll cursors handle "horizontal" scrolling (pitch and rhythm as separate channels)
    rhythmCursor = tsRhCursor;
    pitchCursor = tsPiCursor;
    if (rhythmDirection === -1) {
        rhythmCursor = segmentEnd - (tsRhCursor - segmentStart);
    }
    if (pitchesDirection === -1) {
        pitchCursor = segmentEnd - (tsPiCursor - segmentStart);
    }
    terminationCursor = segmentStart;
    rangeTestStart = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].cursor;
    // execute the copy+transform
    while (terminationCursor <= segmentEnd) {
        rest = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[pitchCursor].rest;
        thisPitch = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[pitchCursor].pitch;
        duration = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[rhythmCursor].duration;
        amplitude = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[rhythmCursor].amplitude;
        instParams = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[rhythmCursor].instParams;
        // actual pitch scroll handles "vertical" scrolling
        if (actualPitchScroll !== 0) {
            thisPitch = thisPitch    + actualPitchScroll;
            if (thisPitch > maxPitch) {
                thisPitch = thisPitch - (maxPitch - minPitch);
            } else {
                if (thisPitch < minPitch) {
                    thisPitch = thisPitch + (maxPitch - minPitch);
                }
            }
        }
        if (pitchScale !== 1) {
            thisPitch = ((thisPitch - midpointPitch) * pitchScale) + midpointPitch;
        }
        // "bevel" bevels only towards the end note, but bevel combined with
        // transpose can bevel both ends; having an additional parameter to
        // bevel the front end would be redundant because it would just be
        // subtracted from transpose
        if (pitchBevel !== 0) {
            percent = (gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[terminationCursor].starttime - startTime) / (endTime - startTime);
            bevelAmount = pitchBevel * percent;
            thisPitch = thisPitch + bevelAmount;
        }
        if (pitchTranspose !== 0) {
            thisPitch = thisPitch + pitchTranspose;
        }
        umtAddNote(lpnum, tab, vcnum, rest, thisPitch, duration, amplitude, instParams);
        rhythmCursor = rhythmCursor + rhythmDirection;
        if (rhythmCursor > segmentEnd) {
            rhythmCursor = rhythmCursor - segmentLen;
        }
        if (rhythmCursor < segmentStart) {
            rhythmCursor = pitchCursor + segmentLen;
        }
        pitchCursor = pitchCursor + pitchesDirection;
        if (pitchCursor > segmentEnd) {
            pitchCursor = pitchCursor - segmentLen;
        }
        if (pitchCursor < segmentStart) {
            pitchCursor = pitchCursor + segmentLen;
        }
        terminationCursor = terminationCursor + 1;
    }
    // see if we went out of range, and if so, transpose in direction of proper
    // range (allowing for slight overshoot)
    rangeTestEnd = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].cursor;
    minPitch = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[rangeTestStart].pitch;
    maxPitch = minPitch;
    for (rangeTestCursor = rangeTestStart; rangeTestCursor < rangeTestEnd; rangeTestCursor = rangeTestCursor + 1) {
        rangePitch = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[rangeTestCursor].pitch;
        if (rangePitch < minPitch) {
            minPitch = rangePitch;
        }
        if (rangePitch > maxPitch) {
            maxPitch = rangePitch;
        }
    }
    rangeMin = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].rangeBottom;
    rangeMax = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].rangeTop;
    if ((minPitch < rangeMin) && (maxPitch > rangeMax)) {
        jsabort('exceeded both min and max for range');
        // exceeded both min and max -- need to scale and transpose
        rangeScalar = (rangeMax - rangeMin) / (maxPitch - minPitch);
        rangeTranspose = ((maxPitch - minPitch) / 2) - ((rangeMax - rangeMin) / 2);
        for (ix = rangeTestStart; ix < rangeTestEnd; ix = ix + 1) {
            gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[ix].pitch = (gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[ix].pitch * rangeScalar) - rangeTranspose;
        }
    } else {
        if (minPitch < rangeMin) {
            rangeTranspose = (rangeMin - minPitch) / 2;
            for (ix = rangeTestStart; ix < rangeTestEnd; ix = ix + 1) {
                gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[ix].pitch = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[ix].pitch + rangeTranspose;
            }
        } else {
            if (maxPitch > rangeMax) {
                rangeTranspose = (maxPitch - rangeMax) / 2;
                for (ix = rangeTestStart; ix < rangeTestEnd; ix = ix + 1) {
                    gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[ix].pitch = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[ix].pitch - rangeTranspose;
                }
            }
        }
    }
}

function umtTestResetCopytransTestSequence() {
    "use strict";
    umtClearLoop(0, 0, 400, 432, "maj7reg", "triad");
    umtAddVoice(0, 0, 0, 0, 4, 6, "tuningfork", false);
    umtAddNote(0, 0, 0, false, 5.0, 1, 0.99, false);
    umtAddNote(0, 0, 0, false, 5.1, 1, 0.99, false);
    umtAddNote(0, 0, 0, false, 5.2, 2, 0.99, false);
    umtAddNote(0, 0, 0, false, 5.3, 4, 0.99, false);
    umtAddNote(0, 0, 0, false, 5.4, 8, 0.99, false);
    umtAddNote(0, 0, 0, false, 5.5, 16, 0.99, false);
}

function umtTestCheckCopytransPitches(pitchList, startingIndex, failMessage) {
    "use strict";
    var tab, x, pt;
    tab = gUmt.UIParams.currentTab;
    cx("checking pitches/" + failMessage);
    x = startingIndex;
    for (pt in pitchList) {
        if (pitchList.hasOwnProperty(pt)) {
            if (gUmt.loop[0].score.songTab[tab].voice[0].notes[x].pitch !== pitchList[pt]) {
                jsabort("test failed: pitches/" + failMessage);
            }
            x = x + 1;
        }
    }
}

function umtTestCheckCopytransDurations(durationList, startingIndex, failMessage) {
    "use strict";
    var tab, x, dr;
    tab = gUmt.UIParams.currentTab;
    cx("checking durations/" + failMessage);
    x = startingIndex;
    for (dr in durationList) {
        if (durationList.hasOwnProperty(dr)) {
            if (gUmt.loop[0].score.songTab[tab].voice[0].notes[x].duration !== durationList[dr]) {
                jsabort("test failed: durations/" + failMessage);
            }
            x = x + 1;
        }
    }
}

function umtTestSetupCopyTransTestSection() {
    "use strict";
    var lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose;

    tab = 0;

    // exact copy
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = 1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.0, 5.1, 5.2, 5.3, 5.4, 5.5], 6, "exact copy");
    umtTestCheckCopytransDurations([1, 1, 2, 4, 8, 16], 6, "exact copy");

    // transpose
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = 1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0.4;
    umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.4, 5.5, 5.6000000000000005, 5.7, 5.800000000000001, 5.9], 6, "transpose");
    umtTestCheckCopytransDurations([1, 1, 2, 4, 8, 16], 6, "transpose");

    // reverse-rhythm
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = -1;
    pitchesDirection = 1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.0, 5.1, 5.2, 5.3, 5.4, 5.5], 6, "reverse-rhythm");
    umtTestCheckCopytransDurations([16, 8, 4, 2, 1, 1], 6, "reverse-rhythm");

    // reverse-pitch
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = -1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.5, 5.4, 5.3, 5.2, 5.1, 5.0], 6, "reverse-pitch");
    umtTestCheckCopytransDurations([1, 1, 2, 4, 8, 16], 6, "reverse-pitch");

    // reverse-both
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = -1;
    pitchesDirection = -1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.5, 5.4, 5.3, 5.2, 5.1, 5.0], 6, "reverse-both");
    umtTestCheckCopytransDurations([16, 8, 4, 2, 1, 1], 6, "reverse-both");

    // scale-positive
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = 1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 0.5;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.125, 5.175, 5.225, 5.275, 5.325, 5.375], 6, "scale-positive");
    umtTestCheckCopytransDurations([1, 1, 2, 4, 8, 16], 6, "scale-positive");

    // scale-1
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = 1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = -1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.5, 5.4, 5.3, 5.2, 5.1, 5.0], 6, "scale-1");
    umtTestCheckCopytransDurations([1, 1, 2, 4, 8, 16], 6, "scale-1");

    // scale-negative
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = 1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = -0.5;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.375, 5.325, 5.275, 5.225, 5.175, 5.125], 6, "scale-negative");
    umtTestCheckCopytransDurations([1, 1, 2, 4, 8, 16], 6, "scale-negative");

    // tilt-ascending
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = 1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 1.0;
    pitchTranspose = -0.5;
    umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([4.5, 4.63125, 4.7625, 4.925, 5.15, 5.5], 6, "tilt-ascending");
    umtTestCheckCopytransDurations([1, 1, 2, 4, 8, 16], 6, "tilt-ascending");

    // tilt-descending
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = 1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = -1.0;
    pitchTranspose = 0.5;
    umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.5, 5.56875, 5.6375, 5.675, 5.65, 5.5], 6, "tilt-descending");
    umtTestCheckCopytransDurations([1, 1, 2, 4, 8, 16], 6, "tilt-descending");

    // scroll-rhythm
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = 1;
    timeRhythmScroll = 8;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.0, 5.1, 5.2, 5.3, 5.4, 5.5], 6, "scroll-rhythm");
    umtTestCheckCopytransDurations([8, 16, 1, 1, 2, 4], 6, "scroll-rhythm");

    // scroll-pitch
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = 1;
    timeRhythmScroll = 0;
    timePitchScroll = 8;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.4, 5.5, 5.0, 5.1, 5.2, 5.3], 6, "scroll-pitch");
    umtTestCheckCopytransDurations([1, 1, 2, 4, 8, 16], 6, "scroll-pitch");

    // scroll-both
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = 1;
    timeRhythmScroll = 8;
    timePitchScroll = 8;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.4, 5.5, 5.0, 5.1, 5.2, 5.3], 6, "scroll-both");
    umtTestCheckCopytransDurations([8, 16, 1, 1, 2, 4], 6, "scroll-both");

    // reverse-rhythm
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = -1;
    pitchesDirection = 1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.0, 5.1, 5.2, 5.3, 5.4, 5.5], 6, "reverse-rhythm");
    umtTestCheckCopytransDurations([16, 8, 4, 2, 1, 1], 6, "reverse-rhythm");

    // reverse-pitch
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = 1;
    pitchesDirection = -1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.5, 5.4, 5.3, 5.2, 5.1, 5.0], 6, "reverse-pitch");
    umtTestCheckCopytransDurations([1, 1, 2, 4, 8, 16], 6, "reverse-pitch");

    //reverse-both
    umtTestResetCopytransTestSequence();
    lpnum = 0;
    vcnum = 0;
    startTime = 0;
    endTime = 32;
    rhythmDirection = -1;
    pitchesDirection = -1;
    timeRhythmScroll = 0;
    timePitchScroll = 0;
    actualPitchScroll = 0;
    pitchScale = 1.0;
    pitchBevel = 0;
    pitchTranspose = 0;
    umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    umtTestCheckCopytransPitches([5.5, 5.4, 5.3, 5.2, 5.1, 5.0], 6, "reverse-both");
    umtTestCheckCopytransDurations([16, 8, 4, 2, 1, 1], 6, "reverse-both");

    window.alert("Tests passed");
}

function umtExecTestCopyTrans(lpnum) {
    "use strict";
    var parts, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose, csrPos, csrStart, duration;
    parts = gUmt.loop[lpnum].score.songTab[tab].parts;
    tab = gUmt.UIParams.currentTab;
    for (vcnum = 0; vcnum < parts; vcnum = vcnum + 1) {
        startTime = 0;
        csrPos = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].cursor;
        csrStart = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[csrPos - 1].starttime;
        duration = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[csrPos - 1].duration;
        endTime = csrStart + duration;
        rhythmDirection = 1;
        pitchesDirection = 1;
        timeRhythmScroll = 0;
        timePitchScroll = 0;
        actualPitchScroll = 0;
        pitchScale = 1.0;
        pitchBevel = 0;
        pitchTranspose = 0.5;
        umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
        csrPos = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].cursor;
        csrStart = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[csrPos - 1].starttime;
        duration = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[csrPos - 1].duration;
        endTime = csrStart + duration;
        pitchTranspose = 0.7;
        umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
        csrPos = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].cursor;
        csrStart = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[csrPos - 1].starttime;
        duration = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[csrPos - 1].duration;
        endTime = csrStart + duration;
        pitchTranspose = -1.33;
        pitchScale = 2.0;
        rhythmDirection = 1;
        pitchesDirection = -1;
        umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
    }
    cx('umtExecTestCopyTrans() done');
}

function umtUIIsPartInUI(ptnum) {
    "use strict";
    if (document.getElementById("voice_row_" + ptnum)) {
        return true;
    }
    return false;
}

function umtComposeTab(lpnum, tab) {
    "use strict";
    var compositionVoice, UIVoice, songNumber, octave, rangeMin, rangeMax, instrumentName, percussion, minSize, chunkSize, totalLength, centerOctave, restyness, ampVariation, volume, noteDistance, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose, symmetryPattern, csrPos, csrStart, duration, loopDuration, vcnum, instParamNames, instSpecificParams;
    if (gUmt.noReenterAddingVoice) {
        jsabort("umtComposeTab called during add voice");
    }
    cx("Composing tab " + ctstr(tab) + " to loop " + ctstr(lpnum));
    umtClearLoop(lpnum, tab, gUmt.UIParams.tempo, gUmt.UIParams.songTab[tab].centernote, gUmt.UIParams.songTab[tab].scale, gUmt.UIParams.songTab[tab].chord);
    compositionVoice = 0;
    loopDuration = gUmt.UIParams.loopDuration;
    // while (umtUIIsPartInUI(UIVoice)) {
    for (UIVoice = 0; UIVoice < gUmt.UIParams.parts; UIVoice = UIVoice + 1) {
        if (gUmt.UIParams.songTab[tab].voice[UIVoice].playing) {
            songNumber = gUmt.UIParams.songTab[tab].voice[UIVoice].songNumber;
            octave = gUmt.UIParams.songTab[tab].voice[UIVoice].octave;
            rangeMin = octave - 1.25;
            rangeMax = octave + 1.25;
            instrumentName = gUmt.UIParams.songTab[tab].voice[UIVoice].instrument;
            percussion = gUmt.instrumentParams[instrumentName].percussion;
            umtAddVoice(lpnum, tab, compositionVoice, songNumber, rangeMin, rangeMax, instrumentName, percussion);
            minSize = gUmt.UIParams.songTab[tab].voice[UIVoice].minNote;
            chunkSize = gUmt.UIParams.songTab[tab].voice[UIVoice].chunkSize;
            totalLength = gUmt.UIParams.songTab[tab].voice[UIVoice].frameSize;
            centerOctave = octave;
            restyness = gUmt.UIParams.songTab[tab].voice[UIVoice].restyness;
            ampVariation = gUmt.UIParams.songTab[tab].voice[UIVoice].ampVariation;
            noteDistance = gUmt.UIParams.songTab[tab].voice[UIVoice].noteDistance;
            volume = gUmt.UIParams.songTab[tab].voice[UIVoice].volume;
            instParamNames = gUmt.instrumentParams[instrumentName].parameters;
            instSpecificParams = gUmt.UIParams.songTab[tab].voice[UIVoice].instSpecificParams;
            umtAddSymmetryBaseToVoice(lpnum, tab, compositionVoice, minSize, chunkSize, totalLength, centerOctave, restyness, noteDistance, ampVariation, volume, instrumentName, instParamNames, instSpecificParams);
            // we have voices and base rhythms; now need symmetry
            startTime = 0;
            csrPos = gUmt.loop[lpnum].score.songTab[tab].voice[compositionVoice].cursor;
            csrStart = gUmt.loop[lpnum].score.songTab[tab].voice[compositionVoice].notes[csrPos - 1].starttime; // can eliminate intermediaries
            duration = gUmt.loop[lpnum].score.songTab[tab].voice[compositionVoice].notes[csrPos - 1].duration;
            endTime = csrStart + duration;
            while (endTime < loopDuration) {
                // set default parameters, then modify defaults according to UI
                rhythmDirection = 1;
                pitchesDirection = 1;
                timeRhythmScroll = 0;
                timePitchScroll = 0;
                actualPitchScroll = 0;
                pitchScale = 1.0;
                pitchBevel = 0;
                pitchTranspose = 0;
                symmetryPattern = gUmt.UIParams.songTab[tab].voice[UIVoice].symmetry[endTime].pattern;
                switch (symmetryPattern) {
                case 'trans':
                    pitchTranspose = (2 * gUmt.UIParams.songTab[tab].voice[UIVoice].symmetry[endTime].transParam) * (gUmt.loop[lpnum].score.songTab[tab].voice[compositionVoice].randTrans.genrandReal1() - 0.5);
                    break;
                case 'invert':
                    pitchScale = -1.0;
                    break;
                case 'scale':
                    pitchScale = gUmt.UIParams.songTab[tab].voice[UIVoice].symmetry[endTime].scaleParam * gUmt.loop[lpnum].score.songTab[tab].voice[compositionVoice].randScale.genrandReal1();
                    break;
                case 'tilt':
                    pitchBevel = gUmt.UIParams.songTab[tab].voice[UIVoice].symmetry[endTime].tiltParam * gUmt.loop[lpnum].score.songTab[tab].voice[compositionVoice].randTilt.genrandReal1();
                    pitchTranspose = -(pitchBevel / 2);
                    break;
                case 'reverserhythm':
                    rhythmDirection = -1;
                    break;
                case 'reversepitch':
                    pitchesDirection = -1;
                    break;
                case 'reverseboth':
                    rhythmDirection = -1;
                    pitchesDirection = -1;
                    break;
                case 'scrollrhythm':
                    timeRhythmScroll = (gUmt.UIParams.songTab[tab].voice[UIVoice].symmetry[endTime].scrollbothParam * gUmt.loop[lpnum].score.songTab[tab].voice[compositionVoice].randTilt.genrandReal1()) * (endTime - startTime);
                    break;
                case 'scrollpitch':
                    timePitchScroll = (gUmt.UIParams.songTab[tab].voice[UIVoice].symmetry[endTime].scrollbothParam * gUmt.loop[lpnum].score.songTab[tab].voice[compositionVoice].randTilt.genrandReal1()) * (endTime - startTime);
                    break;
                case 'scrollboth':
                    timeRhythmScroll = (gUmt.UIParams.songTab[tab].voice[UIVoice].symmetry[endTime].scrollbothParam * gUmt.loop[lpnum].score.songTab[tab].voice[compositionVoice].randTilt.genrandReal1()) * (endTime - startTime);
                    timePitchScroll = timeRhythmScroll;
                    break;
                default:
                    jsabort("unrecognized symmetry pattern in composition: " + symmetryPattern);
                    break;
                }
                vcnum = compositionVoice;
                umtCopyAndTransform(lpnum, tab, vcnum, startTime, endTime, rhythmDirection, pitchesDirection, timeRhythmScroll, timePitchScroll, actualPitchScroll, pitchScale, pitchBevel, pitchTranspose);
                startTime = 0;
                csrPos = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].cursor;
                csrStart = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[csrPos - 1].starttime;
                duration = gUmt.loop[lpnum].score.songTab[tab].voice[vcnum].notes[csrPos - 1].duration;
                endTime = csrStart + duration;
            }
            compositionVoice = compositionVoice + 1;
        }
    }
    umtHarmonizeScore(lpnum, tab);
}

function umtMakeSureTabRecomposeFlagsExist(lpnum, numTabs) {
    "use strict";
    var tab;
    if (!gUmt.tabRecomposeFlags.hasOwnProperty(lpnum)) {
        gUmt.tabRecomposeFlags[lpnum] = [];
    }
    for (tab = 0; tab < numTabs; tab = tab + 1) {
        if (!gUmt.tabRecomposeFlags[lpnum].hasOwnProperty(tab)) {
            gUmt.tabRecomposeFlags[lpnum][tab] = true; // default to true; tab is dirty, needs to be recomposed
        }
    }
}

function umtSetAllTabsAllLoopsToRecompose() {
    "use strict";
    var lpnum, tab, numTabs;
    numTabs = gUmt.UIParams.numTabs;
    for (lpnum = 0; lpnum < 2; lpnum = lpnum + 1) {
        if (!gUmt.tabRecomposeFlags.hasOwnProperty(lpnum)) {
            gUmt.tabRecomposeFlags[lpnum] = [];
        }
        for (tab = 0; tab < numTabs; tab = tab + 1) {
            gUmt.tabRecomposeFlags[lpnum][tab] = true; // default to true; tab is dirty, needs to be recomposed
        }
    }
}

function umtComposeAllTabs(lpnum) {
    "use strict";
    var tab, numTabs;
    numTabs = gUmt.UIParams.numTabs;
    umtMakeSureTabRecomposeFlagsExist(lpnum, numTabs);
    for (tab = 0; tab < numTabs; tab = tab + 1) {
        if (gUmt.tabRecomposeFlags[lpnum][tab]) {
            umtComposeTab(lpnum, tab);
        }
        gUmt.tabRecomposeFlags[lpnum][tab] = false;
    }
    // these must be done afterward because "score" object might not exist until after call to umtComposeTab()
    gUmt.loop[lpnum].score.numTabs = numTabs;
    gUmt.loop[lpnum].score.playAllTabs = true;
}

// composition algorithm demarcation

function umtExecTimerPulse() {
    "use strict";
    umtDoTimerPulse();
}

function umtExecAutomaticStart() {
    "use strict";
    var tab;
    if (gUmt.noReenterCompose === false) {
        gUmt.noReenterCompose = true;
        if (gUmt.UIParams.playAllTabs) {
            gUmt.tabRecomposeFlags = [];
            umtComposeAllTabs(1);
            gUmt.loop[1].score.playAllTabs = true;
        } else {
            tab = gUmt.UIParams.currentTab;
            umtComposeTab(1, tab);
            gUmt.loop[1].score.playAllTabs = false;
        }
    }
    umtAutomaticStart(1);
    gUmt.noReenterCompose = false;
}

function umtExecAutomaticStop() {
    "use strict";
    console.log(gUmt);
    umtAutomaticStop();
}

function umtDisableUI() {
    "use strict";
    window.document.getElementById("start_automatic").disabled = true;
    window.document.getElementById("stop_automatic").disabled = true;
}

function umtEnableUI() {
    "use strict";
    window.document.getElementById("start_automatic").disabled = false;
    window.document.getElementById("stop_automatic").disabled = false;
}

function umtAutomaticallyRecomposeLoopFromUIParams() {
    "use strict";
    var oldLoop, newLoop, startTime, stopTime, diffTime, tab;
    cx("Automatically Recompose Loop From UI Params");
    if (gUmt.timerIsOn) {
        oldLoop = gUmt.currentlyPlayingLoop;
        newLoop = 1 - oldLoop;
        // old_tempoScalar = 60 / gUmt.loop[oldLoop].score.tempo;
        // old_offset = gUmt.loop[oldLoop].score.playbackTimeOffset;
    } else {
        return;
    }
    startTime = gUmt.globalCtx.currentTime;
    umtDisableUI();
    tab = gUmt.UIParams.currentTab;
    if (gUmt.UIParams.playAllTabs) {
        umtMakeSureTabRecomposeFlagsExist(0, gUmt.UIParams.numTabs);
        umtMakeSureTabRecomposeFlagsExist(1, gUmt.UIParams.numTabs);
        gUmt.tabRecomposeFlags[0][tab] = true;
        gUmt.tabRecomposeFlags[1][tab] = true;
        umtComposeAllTabs(newLoop);
        gUmt.loop[newLoop].score.playAllTabs = true;
        gUmt.loop[newLoop].score.numTabs = gUmt.UIParams.numTabs;
    } else {
        umtComposeTab(newLoop, tab);
        gUmt.loop[newLoop].score.playAllTabs = false;
    }
    // new_tempoScalar = 60 / gUmt.loop[newLoop].score.tempo;
    // currentTime = gUmt.globalCtx.currentTime + old_offset;
    // current_units = currentTime / old_tempoScalar;
    // virtual_new_time = current_units * new_tempoScalar;
    // offset_difference = currentTime - virtual_new_time;
    // loopUnitLen = gUmt.loop[newLoop].score.songTab[tab].voice[0].nextStart;
    // loopLen = loopUnitLen * new_tempoScalar;
    // offset_difference = offset_difference - (Math.floor(offset_difference / loopLen) * loopLen);  // modulo
    // gUmt.loop[newLoop].score.playbackTimeOffset = offset_difference;
    // gUmt.loop[newLoop].score.playbackTimeOffset = 0;
    umtAutomaticStart(newLoop);
    umtEnableUI();
    stopTime = gUmt.globalCtx.currentTime;
    diffTime = stopTime - startTime;
    gUmt.compositionLag = diffTime;
    window.document.getElementById("test_composition_time").value = diffTime;
    // cx("gUmt.compositionLag = " + ctstr(gUmt.compositionLag));
    // cx("gUmt.compositionLag = " + ctstr(gUmt.compositionLag));
}

function umtExecScaleChange() {
    "use strict";
    var listbox, scaleparam, tab;
    listbox = window.document.getElementById("lb_scale");
    scaleparam = listbox.options[listbox.selectedIndex].value;
    tab = gUmt.UIParams.currentTab;
    gUmt.UIParams.songTab[tab].scale = scaleparam;
    if (gUmt.noReenterAddingVoice === false) {
        umtAutomaticallyRecomposeLoopFromUIParams();
    }
}

function umtExecChordChange() {
    "use strict";
    var listbox, chordparam, tab;
    listbox = window.document.getElementById("lb_chord");
    chordparam = listbox.options[listbox.selectedIndex].value;
    tab = gUmt.UIParams.currentTab;
    gUmt.UIParams.songTab[tab].chord = chordparam;
    if (gUmt.noReenterAddingVoice === false) {
        umtAutomaticallyRecomposeLoopFromUIParams();
    }
}

function umtExecPlayVoiceChange(event) {
    "use strict";
    var elemid, UIVoiceNum, checkd, tab;
    elemid = event.target.id;
    UIVoiceNum = Number(elemid.substring(9));
    checkd = document.getElementById(elemid).checked;
    tab = gUmt.UIParams.currentTab;
    gUmt.UIParams.songTab[tab].voice[UIVoiceNum].playing = checkd;
    if (gUmt.noReenterAddingVoice === false) {
        umtAutomaticallyRecomposeLoopFromUIParams();
    }
    // document.getElementById("start_automatic").disabled = false;
    // document.getElementById("stop_automatic").disabled = false;
}

function umtExecSongNumberChange(event) {
    "use strict";
    var elemid, UIVoiceNum, listbox, tab;
    elemid = event.target.id;
    UIVoiceNum = Number(elemid.substring(10));
    listbox = window.document.getElementById("songnumber" + UIVoiceNum);
    tab = gUmt.UIParams.currentTab;
    gUmt.UIParams.songTab[tab].voice[UIVoiceNum].songNumber = Number(listbox.options[listbox.selectedIndex].value);
    if (gUmt.noReenterAddingVoice === false) {
        if (gUmt.UIParams.songTab[tab].voice[UIVoiceNum].playing) {
            umtAutomaticallyRecomposeLoopFromUIParams();
        }
    }
}

function umtUICreateClosureFunctionsForSymmetrySlidersOutsideALoop(voiceNumber, patternSize) {
    "use strict";
    jQuery("#slider_symmetry_transParam" + voiceNumber + "_" + patternSize).slider({min: 0, max: 10, step: 1, value: 10, orientation: "horizontal", change: function (event, ui) {
        var tab, newvalue, patternDuration;
        tab = gUmt.UIParams.currentTab;
        // patternDuration and patternSize are two names for the same thing
        // but we have to use two different names so they will refer to
        // different variables and the closure will work
        patternDuration = patternSize;
        if (gUmt.noReenterAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value / 10;
                window.document.getElementById("display_symmetry_transParam" + voiceNumber + "_" + patternDuration).innerHTML = (newvalue * 100) + "%";
                gUmt.UIParams.songTab[tab].voice[voiceNumber].symmetry[patternDuration].transParam = newvalue;
                if (gUmt.UIParams.songTab[tab].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    jQuery("#slider_symmetry_scaleParam" + voiceNumber + "_" + patternSize).slider({min: 0, max: 24, step: 1, value: 12, orientation: "horizontal", change: function (event, ui) {
        var tab, newvalue, patternDuration;
        tab = gUmt.UIParams.currentTab;
        patternDuration = patternSize;
        if (gUmt.noReenterAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = (ui.value - 12) / 10;
                window.document.getElementById("display_symmetry_scaleParam" + voiceNumber + "_" + patternDuration).innerHTML = (newvalue * 100) + "%";
                gUmt.UIParams.songTab[tab].voice[voiceNumber].symmetry[patternDuration].scaleParam = newvalue;
                if (gUmt.UIParams.songTab[tab].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    jQuery("#slider_symmetry_tiltParam" + voiceNumber + "_" + patternSize).slider({min: 0, max: 24, step: 1, value: 12, orientation: "horizontal", change: function (event, ui) {
        var tab, newvalue, patternDuration;
        tab = gUmt.UIParams.currentTab;
        patternDuration = patternSize;
        if (gUmt.noReenterAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = (ui.value - 12) / 10;
                window.document.getElementById("display_symmetry_tiltParam" + voiceNumber + "_" + patternDuration).innerHTML = (newvalue * 100) + "%";
                gUmt.UIParams.songTab[tab].voice[voiceNumber].symmetry[patternDuration].tiltParam = newvalue;
                if (gUmt.UIParams.songTab[tab].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    jQuery("#slider_symmetry_scrollrhythmParam" + voiceNumber + "_" + patternSize).slider({min: 0, max: 10, step: 1, value: 10, orientation: "horizontal", change: function (event, ui) {
        var tab, newvalue, patternDuration;
        tab = gUmt.UIParams.currentTab;
        patternDuration = patternSize;
        if (gUmt.noReenterAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value / 10;
                window.document.getElementById("display_symmetry_scrollrhythmParam" + voiceNumber + "_" + patternDuration).innerHTML = (newvalue * 100) + "%";
                gUmt.UIParams.songTab[tab].voice[voiceNumber].symmetry[patternDuration].scrollrhythmParam = newvalue;
                if (gUmt.UIParams.songTab[tab].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    jQuery("#slider_symmetry_scrollpitchParam" + voiceNumber + "_" + patternSize).slider({min: 0, max: 10, step: 1, value: 10, orientation: "horizontal", change: function (event, ui) {
        var tab, newvalue, patternDuration;
        tab = gUmt.UIParams.currentTab;
        patternDuration = patternSize;
        if (gUmt.noReenterAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value / 10;
                window.document.getElementById("display_symmetry_scrollpitchParam" + voiceNumber + "_" + patternDuration).innerHTML = (newvalue * 100) + "%";
                gUmt.UIParams.songTab[tab].voice[voiceNumber].symmetry[patternDuration].scrollpitchParam = newvalue;
                if (gUmt.UIParams.songTab[tab].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    jQuery("#slider_symmetry_scrollbothParam" + voiceNumber + "_" + patternSize).slider({min: 0, max: 10, step: 1, value: 10, orientation: "horizontal", change: function (event, ui) {
        var tab, newvalue, patternDuration;
        tab = gUmt.UIParams.currentTab;
        patternDuration = patternSize;
        if (gUmt.noReenterAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value / 10;
                window.document.getElementById("display_symmetry_scrollbothParam" + voiceNumber + "_" + patternDuration).innerHTML = (newvalue * 100) + "%";
                gUmt.UIParams.songTab[tab].voice[voiceNumber].symmetry[patternDuration].scrollbothParam = newvalue;
                if (gUmt.UIParams.songTab[tab].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
}

function umtUIShowOrHideAppropriateSymmetrySliders(symmetrySelected, suffix) {
    "use strict";
    var displayTrans, displayScale, displayTilt, displayScrollrhythm, displayScrollpitch, displayScrollboth;
    displayTrans = "none";
    displayScale = "none";
    displayTilt = "none";
    displayScrollrhythm = "none";
    displayScrollpitch = "none";
    displayScrollboth = "none";
    switch (symmetrySelected) {
    case 'trans':
        displayTrans = "block";
        break;
    case 'invert':
        break;
    case 'scale':
        displayScale = "block";
        break;
    case 'tilt':
        displayTilt = "block";
        break;
    case 'reverserhythm':
        break;
    case 'reversepitch':
        break;
    case 'reverseboth':
        break;
    case 'scrollrhythm':
        displayScrollrhythm = "block";
        break;
    case 'scrollpitch':
        displayScrollpitch = "block";
        break;
    case 'scrollboth':
        displayScrollboth = "block";
        break;
    default:
        jsabort("unrecognized symmetry selected: " + symmetrySelected);
        break;
    }
    window.document.getElementById("slider_symmetry_transParam" + suffix).style.display = displayTrans;
    window.document.getElementById("display_symmetry_transParam" + suffix).style.display = displayTrans;
    window.document.getElementById("slider_symmetry_scaleParam" + suffix).style.display = displayScale;
    window.document.getElementById("display_symmetry_scaleParam" + suffix).style.display = displayScale;
    window.document.getElementById("slider_symmetry_tiltParam" + suffix).style.display = displayTilt;
    window.document.getElementById("display_symmetry_tiltParam" + suffix).style.display = displayTilt;
    window.document.getElementById("slider_symmetry_scrollrhythmParam" + suffix).style.display = displayScrollrhythm;
    window.document.getElementById("display_symmetry_scrollrhythmParam" + suffix).style.display = displayScrollrhythm;
    window.document.getElementById("slider_symmetry_scrollpitchParam" + suffix).style.display = displayScrollpitch;
    window.document.getElementById("display_symmetry_scrollpitchParam" + suffix).style.display = displayScrollpitch;
    window.document.getElementById("slider_symmetry_scrollbothParam" + suffix).style.display = displayScrollboth;
    window.document.getElementById("display_symmetry_scrollbothParam" + suffix).style.display = displayScrollboth;
}

function umtExecPervoiceSymmetryChange(event) {
    "use strict";
    var elemid, listbox, selectedvalue, i, voiceNumber, symSize, symmetryPattern, tab;
    elemid = event.target.id;
    listbox = event.target;
    selectedvalue = listbox.options[listbox.selectedIndex].value;
    elemid = elemid.substring(12);
    umtUIShowOrHideAppropriateSymmetrySliders(selectedvalue, elemid);
    i = elemid.indexOf("_");
    voiceNumber = elemid.substring(0, i);
    symSize = elemid.substring(i + 1);
    symmetryPattern = selectedvalue;
    tab = gUmt.UIParams.currentTab;
    gUmt.UIParams.songTab[tab].voice[voiceNumber].symmetry[symSize].pattern = symmetryPattern;
    if (gUmt.UIParams.songTab[tab].voice[voiceNumber].playing) {
        umtAutomaticallyRecomposeLoopFromUIParams();
    }
}

function umtUiTurnOnSymmetryPatterns(row, patternLabel, isOn) {
    "use strict";
    var suffix, block, inline;
    suffix = row + "_" + patternLabel;
    if (isOn) {
        block = "block";
        inline = "inline";
    } else {
        block = "none";
        inline = "none";
    }
    window.document.getElementById("display_symmetrylevel" + suffix).style.display = inline;
    window.document.getElementById("display_symmetrylevel" + suffix).innerHTML = patternLabel;
    window.document.getElementById("sel_symmetry" + suffix).style.display = inline;
    window.document.getElementById("slider_symmetry_transParam" + suffix).style.display = block;
    window.document.getElementById("display_symmetry_transParam" + suffix).style.display = block;
    window.document.getElementById("slider_symmetry_scaleParam" + suffix).style.display = block;
    window.document.getElementById("display_symmetry_scaleParam" + suffix).style.display = block;
    window.document.getElementById("slider_symmetry_tiltParam" + suffix).style.display = block;
    window.document.getElementById("display_symmetry_tiltParam" + suffix).style.display = block;
    window.document.getElementById("slider_symmetry_scrollrhythmParam" + suffix).style.display = block;
    window.document.getElementById("display_symmetry_scrollrhythmParam" + suffix).style.display = block;
    window.document.getElementById("slider_symmetry_scrollpitchParam" + suffix).style.display = block;
    window.document.getElementById("display_symmetry_scrollpitchParam" + suffix).style.display = block;
    window.document.getElementById("slider_symmetry_scrollbothParam" + suffix).style.display = block;
    window.document.getElementById("display_symmetry_scrollbothParam" + suffix).style.display = block;
}

function umtUiSetSymmetryListboxAndSlider(row, patternDuration) {
    "use strict";
    var suffix, absvalue, slidervalue, tab;
    suffix = row + "_" + patternDuration;
    tab = gUmt.UIParams.currentTab;
    window.document.getElementById("sel_symmetry" + suffix).value = gUmt.UIParams.songTab[tab].voice[row].symmetry[patternDuration].pattern;
    // trans param
    absvalue = gUmt.UIParams.songTab[tab].voice[row].symmetry[patternDuration].transParam;
    slidervalue = absvalue * 10;
    window.document.getElementById("display_symmetry_transParam" + suffix).innerHTML = (absvalue * 100) + "%";
    jQuery("#slider_symmetry_transParam" + suffix).slider({ value: slidervalue });
    // scale param
    absvalue = gUmt.UIParams.songTab[tab].voice[row].symmetry[patternDuration].scaleParam;
    slidervalue = (absvalue * 10) + 12;
    window.document.getElementById("display_symmetry_scaleParam" + suffix).innerHTML = (absvalue * 100) + "%";
    jQuery("#slider_symmetry_scaleParam" + suffix).slider({ value: slidervalue });
    // tilt param
    absvalue = gUmt.UIParams.songTab[tab].voice[row].symmetry[patternDuration].tiltParam;
    slidervalue = (absvalue * 10) + 12;
    window.document.getElementById("display_symmetry_tiltParam" + suffix).innerHTML = (absvalue * 100) + "%";
    jQuery("#slider_symmetry_tiltParam" + suffix).slider({ value: slidervalue });
    // scrollrhythm param
    absvalue = gUmt.UIParams.songTab[tab].voice[row].symmetry[patternDuration].scrollrhythmParam;
    slidervalue = absvalue * 10;
    window.document.getElementById("display_symmetry_scrollrhythmParam" + suffix).innerHTML = (absvalue * 100) + "%";
    jQuery("#slider_symmetry_scrollrhythmParam" + suffix).slider({ value: slidervalue });
    // scrollpitch param
    absvalue = gUmt.UIParams.songTab[tab].voice[row].symmetry[patternDuration].scrollpitchParam;
    slidervalue = absvalue * 10;
    window.document.getElementById("display_symmetry_scrollpitchParam" + suffix).innerHTML = (absvalue * 100) + "%";
    jQuery("#slider_symmetry_scrollpitchParam" + suffix).slider({ value: slidervalue });
    // scrollboth param
    absvalue = gUmt.UIParams.songTab[tab].voice[row].symmetry[patternDuration].scrollbothParam;
    slidervalue = absvalue * 10;
    window.document.getElementById("display_symmetry_scrollbothParam" + suffix).innerHTML = (absvalue * 100) + "%";
    jQuery("#slider_symmetry_scrollbothParam" + suffix).slider({ value: slidervalue });
}

var umtUiCascadeFrameSizeChanges, umtUiCascadeChunkSizeChanges, umtUiCascadeMinNoteChanges;

umtUiCascadeFrameSizeChanges = function (voiceNumber, newvalue) {
    "use strict";
    var tab, chunkSize, loopDuration, maxLoopDuration, symSize, slidervalue, symmetryPattern;
    tab = gUmt.UIParams.currentTab;
    chunkSize = gUmt.UIParams.songTab[tab].voice[voiceNumber].chunkSize;
    if (newvalue < chunkSize) {
        chunkSize = newvalue;
        slidervalue = Math.floor((Math.log(chunkSize) / Math.log(2)) + 0.01);
        jQuery("#slider_chunksize" + voiceNumber).slider({ value: slidervalue });
        window.document.getElementById("display_chunksize" + voiceNumber).innerHTML = newvalue;
        gUmt.UIParams.songTab[tab].voice[voiceNumber].chunkSize = chunkSize;
        // cx("voiceNumber" + ctstr(voiceNumber) + " chunkSize" + ctstr(chunkSize));
        umtUiCascadeChunkSizeChanges(voiceNumber, chunkSize);
    }
    loopDuration = gUmt.UIParams.loopDuration;
    maxLoopDuration = gUmt.UIParams.maxLoopDuration;
    symSize = 1;
    while (symSize < maxLoopDuration) {
        if (symSize < loopDuration) {
            if (symSize < newvalue) {
                umtUiTurnOnSymmetryPatterns(voiceNumber, symSize, false);
            } else {
                umtUiSetSymmetryListboxAndSlider(voiceNumber, symSize);
                umtUiTurnOnSymmetryPatterns(voiceNumber, symSize, true);
                symmetryPattern = gUmt.UIParams.songTab[tab].voice[voiceNumber].symmetry[symSize].pattern;
                umtUIShowOrHideAppropriateSymmetrySliders(symmetryPattern, voiceNumber + "_" + symSize);
            }
        } else {
            umtUiTurnOnSymmetryPatterns(voiceNumber, symSize, false);
        }
        symSize = symSize * 2;
    }
};

umtUiCascadeChunkSizeChanges = function (voiceNumber, newvalue) {
    "use strict";
    var tab, minNote, frameSize, slidervalue;
    tab = gUmt.UIParams.currentTab;
    minNote = gUmt.UIParams.songTab[tab].voice[voiceNumber].minNote;
    if (newvalue < minNote) {
        minNote = newvalue;
        slidervalue = Math.floor((Math.log(minNote) / Math.log(2)) + 0.01);
        jQuery("#slider_minnote" + voiceNumber).slider({ value: slidervalue });
        window.document.getElementById("display_minnote" + voiceNumber).innerHTML = newvalue;
        gUmt.UIParams.songTab[tab].voice[voiceNumber].minNote = minNote;
        umtUiCascadeMinNoteChanges(voiceNumber, minNote);
    }
    frameSize = gUmt.UIParams.songTab[tab].voice[voiceNumber].frameSize;
    if (newvalue > frameSize) {
        frameSize = newvalue;
        slidervalue = Math.floor((Math.log(frameSize) / Math.log(2)) + 0.01);
        jQuery("#slider_framesize" + voiceNumber).slider({ value: slidervalue });
        window.document.getElementById("display_framesize" + voiceNumber).innerHTML = newvalue;
        gUmt.UIParams.songTab[tab].voice[voiceNumber].frameSize = frameSize;
        umtUiCascadeFrameSizeChanges(voiceNumber, frameSize);
    }
};

umtUiCascadeMinNoteChanges = function (voiceNumber, newvalue) {
    "use strict";
    var tab, chunkSize, slidervalue;
    tab = gUmt.UIParams.currentTab;
    chunkSize = gUmt.UIParams.songTab[tab].voice[voiceNumber].chunkSize;
    if (newvalue > chunkSize) {
        chunkSize = newvalue;
        slidervalue = Math.floor((Math.log(chunkSize) / Math.log(2)) + 0.01);
        jQuery("#slider_chunksize" + voiceNumber).slider({ value: slidervalue });
        window.document.getElementById("display_chunksize" + voiceNumber).innerHTML = newvalue;
        gUmt.UIParams.songTab[tab].voice[voiceNumber].chunkSize = chunkSize;
        umtUiCascadeChunkSizeChanges(voiceNumber, chunkSize);
    }
};

function umtUISetDefaultInstSpecificParamsForNewInstrument(voiceNumber, instrumentName) {
    "use strict";
    var tab, instParameters, instParamIdx, instParamSet, paramName;
    tab = gUmt.UIParams.currentTab;
    instParameters = gUmt.instrumentParams[instrumentName].parameters;
    for (instParamIdx in instParameters) {
        if (instParameters.hasOwnProperty(instParamIdx)) {
            instParamSet = instParameters[instParamIdx];
            paramName = instParamSet.name;
            if (!gUmt.UIParams.songTab[tab].voice[voiceNumber].instSpecificParams.hasOwnProperty(instrumentName + "_" + paramName + "_patterns")) {
                gUmt.UIParams.songTab[tab].voice[voiceNumber].instSpecificParams[instrumentName + "_" + paramName + "_patterns"] = 0.0;
            }
        }
    }
}

function umtUICreateClosureFunctionsForInstrumentSpecificParametersOutsideALoop(instrumentName, paramName, voiceNumber) {
    "use strict";
    jQuery("#slider_instr_" + instrumentName + "_" + paramName + "_" + voiceNumber + "_patterns").slider({min: 0, max: 10, step: 1, value: 0, orientation: "vertical", change: function (event, ui) {
        var tab, newvalue, absvalue, aspercentage;
        if (gUmt.noReenterAddingVoice === false) {
            if (event.type === "slidechange") {
                tab = gUmt.UIParams.currentTab;
                newvalue = ui.value;
                absvalue = newvalue / 10;
                aspercentage = newvalue * 10;
                window.document.getElementById("display_instr_" + instrumentName + "_" + paramName + "_" + voiceNumber + "_patterns").innerHTML = aspercentage + "%";
                gUmt.UIParams.songTab[tab].voice[voiceNumber].instSpecificParams[instrumentName + "_" + paramName + "_patterns"] = absvalue;
                if (gUmt.UIParams.songTab[tab].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
        });
}

function umtCreateInstrumentSpecificParameterControls(voiceNumber, instrumentName) {
    "use strict";
    var cellidname, text, i, instrSpecificControlHTML, parameters, idx, instpar, template;
    cellidname = "instparameterscell";
    text = document.getElementById(cellidname + "xx").innerHTML;
    i = text.indexOf("xx");
    while (i >= 0) {
        text = text.substring(0, i) + voiceNumber + text.substring(i + 2);
        i = text.indexOf("xx");
    }
    instrSpecificControlHTML = '<table border="0"><tr>';
    parameters = gUmt.instrumentParams[instrumentName].parameters;
    for (idx in parameters) {
        if (parameters.hasOwnProperty(idx)) {
            instpar = parameters[idx];
            instrSpecificControlHTML = instrSpecificControlHTML + '<td>' + instpar.display + '<br />';
            template = document.getElementById("instrument_parameter_template").innerHTML;
            i = template.indexOf("ZZ");
            while (i >= 0) {
                template = template.substring(0, i) + instrumentName + template.substring(i + 2);
                i = template.indexOf("ZZ");
            }
            i = template.indexOf("YY");
            while (i >= 0) {
                template = template.substring(0, i) + instpar.name + template.substring(i + 2);
                i = template.indexOf("YY");
            }
            i = template.indexOf("XX");
            while (i >= 0) {
                template = template.substring(0, i) + voiceNumber + template.substring(i + 2);
                i = template.indexOf("XX");
            }
            instrSpecificControlHTML = instrSpecificControlHTML + template + '</td>';
        }
    }
    instrSpecificControlHTML = instrSpecificControlHTML + '</tr></table>';
    i = text.indexOf("<!-- inst_specific_param_ins_point -->");
    text = text.substring(0, i) + instrSpecificControlHTML + text.substring(i); // paste
    document.getElementById(cellidname + voiceNumber).innerHTML = text;
    for (idx in parameters) {
        if (parameters.hasOwnProperty(idx)) {
            instpar = parameters[idx];
            umtUICreateClosureFunctionsForInstrumentSpecificParametersOutsideALoop(instrumentName, instpar.name, voiceNumber);
        }
    }
}

function umtUiSetInstrumentSpecificSliders(voiceNumber) {
    "use strict";
    var tab, instrumentName, instParameters, instParamIdx, instParamSet, paramName, absvalue, slidervalue;
    tab = gUmt.UIParams.currentTab;
    instrumentName = gUmt.UIParams.songTab[tab].voice[voiceNumber].instrument;
    instParameters = gUmt.instrumentParams[instrumentName].parameters;
    for (instParamIdx in instParameters) {
        if (instParameters.hasOwnProperty(instParamIdx)) {
            instParamSet = instParameters[instParamIdx];
            paramName = instParamSet.name;
            absvalue = gUmt.UIParams.songTab[tab].voice[voiceNumber].instSpecificParams[instrumentName + "_" + paramName + "_patterns"];
            slidervalue = absvalue * 10;
            window.document.getElementById("display_instr_" + instrumentName + "_" + paramName + "_" + voiceNumber + "_patterns").innerHTML = (absvalue * 100) + "%";
            jQuery("#slider_instr_" + instrumentName + "_" + paramName + "_" + voiceNumber + "_patterns").slider({ value: slidervalue });
        }
    }
}

function umtExecInstrumentChange() {
    "use strict";
    var elemid, UIVoiceNum, listbox, newinstr, tab;
    elemid = event.target.id;
    UIVoiceNum = Number(elemid.substring(10));
    listbox = window.document.getElementById("instrument" + UIVoiceNum);
    newinstr = listbox.options[listbox.selectedIndex].value;
    tab = gUmt.UIParams.currentTab;
    gUmt.UIParams.songTab[tab].voice[UIVoiceNum].instrument = newinstr;
    umtUISetDefaultInstSpecificParamsForNewInstrument(UIVoiceNum, newinstr);
    umtCreateInstrumentSpecificParameterControls(UIVoiceNum, newinstr);
    umtUiSetInstrumentSpecificSliders(UIVoiceNum);
    if (gUmt.noReenterAddingVoice === false) {
        umtAutomaticallyRecomposeLoopFromUIParams();
    }
}

// universal voice copy function -- used by both Add Voice and Add Tab
function umtUiCopyTabVoice(fromTab, fromVoice, toTab, toVoice) {
    "use strict";
    var prev, pvsym, pvinstspec, currentinstspec, instParamName;
    prev = gUmt.UIParams.songTab[fromTab].voice[fromVoice];
    pvsym = gUmt.UIParams.songTab[fromTab].voice[fromVoice].symmetry;
    gUmt.UIParams.songTab[toTab].voice[toVoice] = {
        playing: prev.playing,
        instrument: prev.instrument,
        volume: prev.volume,
        songNumber: prev.songNumber,
        octave: prev.octave,
        noteDistance: prev.noteDistance,
        restyness: prev.restyness,
        ampVariation: prev.ampVariation,
        minNote: prev.minNote,
        chunkSize: prev.chunkSize,
        frameSize: prev.frameSize,
        symmetry: {
            1: {
                pattern: pvsym[1].pattern,
                transParam: pvsym[1].transParam,
                scaleParam: pvsym[1].scaleParam,
                tiltParam: pvsym[1].tiltParam,
                scrollrhythmParam: pvsym[1].scrollrhythmParam,
                scrollpitchParam: pvsym[1].scrollpitchParam,
                scrollbothParam: pvsym[1].scrollbothParam
            },
            2: {
                pattern: pvsym[2].pattern,
                transParam: pvsym[2].transParam,
                scaleParam: pvsym[2].scaleParam,
                tiltParam: pvsym[2].tiltParam,
                scrollrhythmParam: pvsym[2].scrollrhythmParam,
                scrollpitchParam: pvsym[2].scrollpitchParam,
                scrollbothParam: pvsym[2].scrollbothParam
            },
            4: {
                pattern: pvsym[4].pattern,
                transParam: pvsym[4].transParam,
                scaleParam: pvsym[4].scaleParam,
                tiltParam: pvsym[4].tiltParam,
                scrollrhythmParam: pvsym[4].scrollrhythmParam,
                scrollpitchParam: pvsym[4].scrollpitchParam,
                scrollbothParam: pvsym[4].scrollbothParam
            },
            8: {
                pattern: pvsym[8].pattern,
                transParam: pvsym[8].transParam,
                scaleParam: pvsym[8].scaleParam,
                tiltParam: pvsym[8].tiltParam,
                scrollrhythmParam: pvsym[8].scrollrhythmParam,
                scrollpitchParam: pvsym[8].scrollpitchParam,
                scrollbothParam: pvsym[8].scrollbothParam
            },
            16: {
                pattern: pvsym[16].pattern,
                transParam: pvsym[16].transParam,
                scaleParam: pvsym[16].scaleParam,
                tiltParam: pvsym[16].tiltParam,
                scrollrhythmParam: pvsym[16].scrollrhythmParam,
                scrollpitchParam: pvsym[16].scrollpitchParam,
                scrollbothParam: pvsym[16].scrollbothParam
            },
            32: {
                pattern: pvsym[32].pattern,
                transParam: pvsym[32].transParam,
                scaleParam: pvsym[32].scaleParam,
                tiltParam: pvsym[32].tiltParam,
                scrollrhythmParam: pvsym[32].scrollrhythmParam,
                scrollpitchParam: pvsym[32].scrollpitchParam,
                scrollbothParam: pvsym[32].scrollbothParam
            },
            64: {
                pattern: pvsym[64].pattern,
                transParam: pvsym[64].transParam,
                scaleParam: pvsym[64].scaleParam,
                tiltParam: pvsym[64].tiltParam,
                scrollrhythmParam: pvsym[64].scrollrhythmParam,
                scrollpitchParam: pvsym[64].scrollpitchParam,
                scrollbothParam: pvsym[64].scrollbothParam
            },
            128: {
                pattern: pvsym[128].pattern,
                transParam: pvsym[128].transParam,
                scaleParam: pvsym[128].scaleParam,
                tiltParam: pvsym[128].tiltParam,
                scrollrhythmParam: pvsym[128].scrollrhythmParam,
                scrollpitchParam: pvsym[128].scrollpitchParam,
                scrollbothParam: pvsym[128].scrollbothParam
            },
            256: {
                pattern: pvsym[256].pattern,
                transParam: pvsym[256].transParam,
                scaleParam: pvsym[256].scaleParam,
                tiltParam: pvsym[256].tiltParam,
                scrollrhythmParam: pvsym[256].scrollrhythmParam,
                scrollpitchParam: pvsym[256].scrollpitchParam,
                scrollbothParam: pvsym[256].scrollbothParam
            },
            512: {
                pattern: pvsym[512].pattern,
                transParam: pvsym[512].transParam,
                scaleParam: pvsym[512].scaleParam,
                tiltParam: pvsym[512].tiltParam,
                scrollrhythmParam: pvsym[512].scrollrhythmParam,
                scrollpitchParam: pvsym[512].scrollpitchParam,
                scrollbothParam: pvsym[512].scrollbothParam
            },
            1024: {
                pattern: pvsym[1024].pattern,
                transParam: pvsym[1024].transParam,
                scaleParam: pvsym[1024].scaleParam,
                tiltParam: pvsym[1024].tiltParam,
                scrollrhythmParam: pvsym[1024].scrollrhythmParam,
                scrollpitchParam: pvsym[1024].scrollpitchParam,
                scrollbothParam: pvsym[1024].scrollbothParam
            }
        },
        instSpecificParams: {},
        copyChangesToOtherTabs: false
    };
    pvinstspec = gUmt.UIParams.songTab[fromTab].voice[fromVoice].instSpecificParams;
    currentinstspec = gUmt.UIParams.songTab[toTab].voice[toVoice].instSpecificParams;
    for (instParamName in pvinstspec) {
        if (pvinstspec.hasOwnProperty(instParamName)) {
            currentinstspec[instParamName] = pvinstspec[instParamName];
        }
    }
}

function umtUiSetListboxByValue(listbox, value) {
    "use strict";
    var options, i, valstr;
    options = listbox.options;
    valstr = value.toString();
    for (i = 0; i < options.length; i = i + 1) {
        if (options[i].value === valstr) {
            options[i].selected = true;
        }
    }
}

var umtExecDeleteVoiceClick; // has to exist for next function; can't be rearranged because tried that and functions really are circular

function umtUiAddRow(voiceNumber) {
    "use strict";
    var text, i, displayNumber, columnidlist, idx, cellidname, j, rowcontent, y, yyy, currentrowhtml, listenElement;
    // First, add the HTML
    jQuery('#voices_table > tbody:last').append('<tr id="voice_row_' + voiceNumber + '"><td id="voicedescriptcell' + voiceNumber + '" valign="top"> Voice Description Cell ' + voiceNumber + '</td><td id="voiceplaycell' + voiceNumber + '" valign="top"></td><td id="voiceinstrumentcell' + voiceNumber + '" valign="top"><td id="voicevolumecell' + voiceNumber + '" valign="top"></td><td id="voicesongnumcell' + voiceNumber + '" valign="top" align="center"></td><td id="voiceoctavecell' + voiceNumber + '" valign="top" align="center"></td><td id="voicenotedistcell' + voiceNumber + '" valign="top" align="center"></td><td id="voicerestynesscell' + voiceNumber + '" valign="top" align="center"></td><td id="voiceampvariationcell' + voiceNumber + '" valign="top" align="center"></td><td id="voiceminnotecell' + voiceNumber + '" valign="top" align="center"></td><td id="voicechunksizecell' + voiceNumber + '" valign="top" align="center"></td><td id="voiceframesizecell' + voiceNumber + '" valign="top" align="center"></td><td id="voicesymmetriescell' + voiceNumber + '" valign="top" align="center"></td><td id="instparameterscell' + voiceNumber + '" valign="top" align="center"></td><td id="voicedeletecell' + voiceNumber + '" valign="top" align="center"></td></tr>');
    // Then, paste in standard templates for each of the cells
    text = document.getElementById("voicedescriptcellxx").innerHTML;
    displayNumber = voiceNumber + 1;
    i = text.indexOf("XX");
    text = text.substring(0, i) + displayNumber + text.substring(i + 2);
    document.getElementById("voicedescriptcell" + voiceNumber).innerHTML = text;
    columnidlist = ["voiceplaycell", "voiceinstrumentcell", "voicevolumecell", "voicesongnumcell", "voiceoctavecell", "voicenotedistcell", "voicerestynesscell", "voiceampvariationcell", "voiceminnotecell", "voicechunksizecell", "voiceframesizecell", "voicesymmetriescell", "instparameterscell", "voicedeletecell"];
    for (idx in columnidlist) {
        if (columnidlist.hasOwnProperty(idx)) {
            cellidname = columnidlist[idx];
            text = document.getElementById(cellidname + "xx").innerHTML;
            i = text.indexOf("xx");
            while (i >= 0) {
                text = text.substring(0, i) + voiceNumber + text.substring(i + 2);
                i = text.indexOf("xx");
            }
            if (cellidname === "voicesymmetriescell") {
                i = text.indexOf("<tr>");
                j = text.indexOf("</tr>");
                rowcontent = text.substring(i, j + 6);
                text = text.substring(0, i) + text.substring(j + 5); // cut
                for (y = 0; y <= 10; y = y + 1) { // BUGBUG 10 is hard-coded
                    currentrowhtml = rowcontent;
                    i = currentrowhtml.indexOf("yyy");
                    while (i >= 0) {
                        yyy = Math.pow(2, y);
                        currentrowhtml = currentrowhtml.substring(0, i) + yyy + currentrowhtml.substring(i + 3);
                        i = currentrowhtml.indexOf("yyy");
                    }
                    i = text.indexOf("<!-- insertion_point -->");
                    text = text.substring(0, i) + currentrowhtml + text.substring(i); // paste
                }
            }
            document.getElementById(cellidname + voiceNumber).innerHTML = text;
        }
    }
    // Add event listeners
    // Play
    listenElement = document.getElementById("playvoice" + voiceNumber);
    listenElement.addEventListener("change", umtExecPlayVoiceChange, true);
    // Instrument
    listenElement = document.getElementById("instrument" + voiceNumber);
    listenElement.addEventListener("change", umtExecInstrumentChange, true);
    // Song Number
    listenElement = document.getElementById("songnumber" + voiceNumber);
    listenElement.addEventListener("change", umtExecSongNumberChange, true);
    // Volume
    jQuery("#slider_volume" + voiceNumber).slider({min: 0, max: 10, step: 1, value: 5, orientation: "vertical", change: function (event, ui) {
        var tab, newvalue, absvalue, aspercentage;
        tab = gUmt.UIParams.currentTab;
        if (gUmt.noReenterAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                absvalue = newvalue / 10;
                aspercentage = newvalue * 10;
                window.document.getElementById("display_volume" + voiceNumber).innerHTML = aspercentage + "%";
                gUmt.UIParams.songTab[tab].voice[voiceNumber].volume = absvalue;
                if (gUmt.UIParams.songTab[tab].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    // Octave
    jQuery("#slider_octave" + voiceNumber).slider({min: 0, max: 9, step: 1, value: 5, orientation: "vertical", change: function (event, ui) {
        var tab, newvalue;
        tab = gUmt.UIParams.currentTab;
        if (gUmt.noReenterAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                window.document.getElementById("display_octave" + voiceNumber).innerHTML = newvalue;
                gUmt.UIParams.songTab[tab].voice[voiceNumber].octave = newvalue;
                if (gUmt.UIParams.songTab[tab].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    // Note distance
    jQuery("#slider_notedistance" + voiceNumber).slider({min: 0, max: 10, step: 1, value: 5, orientation: "vertical", change: function (event, ui) {
        var tab, newvalue, absvalue, aspercentage;
        tab = gUmt.UIParams.currentTab;
        if (gUmt.noReenterAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                absvalue = newvalue / 10;
                aspercentage = newvalue * 10;
                window.document.getElementById("display_notedistance" + voiceNumber).innerHTML = aspercentage + "%";
                gUmt.UIParams.songTab[tab].voice[voiceNumber].noteDistance = absvalue;
                if (gUmt.UIParams.songTab[tab].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    // Restyness
    jQuery("#slider_restyness" + voiceNumber).slider({min: 0, max: 10, step: 1, value: 0, orientation: "vertical", change: function (event, ui) {
        var tab, newvalue, absvalue, aspercentage;
        tab = gUmt.UIParams.currentTab;
        if (gUmt.noReenterAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                absvalue = newvalue / 10;
                aspercentage = newvalue * 10;
                window.document.getElementById("display_restyness" + voiceNumber).innerHTML = aspercentage + "%";
                gUmt.UIParams.songTab[tab].voice[voiceNumber].restyness = absvalue;
                if (gUmt.UIParams.songTab[tab].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    // Amplitude variation
    jQuery("#slider_ampvariation" + voiceNumber).slider({min: 0, max: 10, step: 1, value: 0, orientation: "vertical", change: function (event, ui) {
        var tab, newvalue, absvalue, aspercentage;
        tab = gUmt.UIParams.currentTab;
        if (gUmt.noReenterAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                absvalue = newvalue / 10;
                aspercentage = newvalue * 10;
                window.document.getElementById("display_ampvariation" + voiceNumber).innerHTML = aspercentage + "%";
                gUmt.UIParams.songTab[tab].voice[voiceNumber].ampVariation = absvalue;
                if (gUmt.UIParams.songTab[tab].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    // Min note
    jQuery("#slider_minnote" + voiceNumber).slider({min: 0, max: 7, step: 1, value: 3, orientation: "vertical", change: function (event, ui) {
        var tab, newvalue;
        tab = gUmt.UIParams.currentTab;
        if (gUmt.noReenterAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                newvalue = Math.pow(2, newvalue);
                window.document.getElementById("display_minnote" + voiceNumber).innerHTML = newvalue;
                gUmt.UIParams.songTab[tab].voice[voiceNumber].minNote = newvalue;
                gUmt.noReenterAddingVoice = true;
                umtUiCascadeMinNoteChanges(voiceNumber, newvalue);
                gUmt.noReenterAddingVoice = false;
                if (gUmt.UIParams.songTab[tab].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    // Chunk size
    jQuery("#slider_chunksize" + voiceNumber).slider({min: 0, max: 7, step: 1, value: 3, orientation: "vertical", change: function (event, ui) {
        var tab, newvalue;
        tab = gUmt.UIParams.currentTab;
        if (gUmt.noReenterAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                newvalue = Math.pow(2, newvalue);
                window.document.getElementById("display_chunksize" + voiceNumber).innerHTML = newvalue;
                gUmt.UIParams.songTab[tab].voice[voiceNumber].chunkSize = newvalue;
                gUmt.noReenterAddingVoice = true;
                umtUiCascadeChunkSizeChanges(voiceNumber, newvalue);
                gUmt.noReenterAddingVoice = false;
                if (gUmt.UIParams.songTab[tab].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    // Frame size
    jQuery("#slider_framesize" + voiceNumber).slider({min: 0, max: 7, step: 1, value: 3, orientation: "vertical", change: function (event, ui) {
        // BUGBUG: Important -- the max value needs to me MANUALLY sync'd with the loop size -- this needs to be fixed to be computed!
        var tab, newvalue;
        tab = gUmt.UIParams.currentTab;
        if (gUmt.noReenterAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                newvalue = Math.pow(2, newvalue);
                window.document.getElementById("display_framesize" + voiceNumber).innerHTML = newvalue;
                gUmt.UIParams.songTab[tab].voice[voiceNumber].frameSize = newvalue;
                gUmt.noReenterAddingVoice = true;
                umtUiCascadeFrameSizeChanges(voiceNumber, newvalue);
                gUmt.noReenterAddingVoice = false;
                if (gUmt.UIParams.songTab[tab].voice[voiceNumber].playing) {
                    umtAutomaticallyRecomposeLoopFromUIParams();
                }
            }
        }
    }
         });
    // Symmetries
    for (y = 0; y < 10; y = y + 1) {
        yyy = Math.pow(2, y);
        listenElement = document.getElementById("sel_symmetry" + voiceNumber + "_" + yyy);
        listenElement.addEventListener("change", umtExecPervoiceSymmetryChange, true);
        umtUICreateClosureFunctionsForSymmetrySlidersOutsideALoop(voiceNumber, yyy);
    }
    // Close box
    listenElement = document.getElementById("deletevoice" + voiceNumber);
    listenElement.addEventListener("click", umtExecDeleteVoiceClick, true);
}

function umtUiCopyUiParamsToActualUi() {
    "use strict";
    var parts, tab, i, absvalue, slidervalue, loopDuration, maxLoopDuration, frameSize, symSize, symmetryPattern;
    // Important note: This function does not copy the tabs! It copies all the values outside the tabs, and all the values inside the tab *for the current tab* but does not change or configure the tabs themselves!!
    gUmt.noReenterAddingVoice = true;
    // tempo
    absvalue = gUmt.UIParams.tempo;
    window.document.getElementById("display_tempo_value").innerHTML = absvalue;
    slidervalue = absvalue; // no translation for tempo!
    jQuery("#slider_tempo").slider({ value: slidervalue });
    // master volume
    absvalue = gUmt.UIParams.mastervol;
    window.document.getElementById("display_mastervol_value").innerHTML = (absvalue * 100) + "%";
    slidervalue = absvalue * 100;
    jQuery("#slider_mastervol").slider({ value: slidervalue });
    // play selected tab or all tabs (loop tabs "one" or "all")
    if (gUmt.UIParams.playAllTabs) {
        document.getElementById("loop_tabs_all").checked = true;
    } else {
        document.getElementById("loop_tabs_one").checked = true;
    }
    // Loop length
    umtUiSetListboxByValue(document.getElementById("lb_tab_length"), gUmt.UIParams.loopDuration);
    // current tab
    tab = gUmt.UIParams.currentTab;
    // scale
    umtUiSetListboxByValue(document.getElementById("lb_scale"), gUmt.UIParams.songTab[tab].scale);
    // chords
    umtUiSetListboxByValue(document.getElementById("lb_chord"), gUmt.UIParams.songTab[tab].chord);
    // center note
    absvalue = gUmt.UIParams.songTab[tab].centernote;
    window.document.getElementById("display_centernote_value").innerHTML = absvalue;
    slidervalue = (Math.log(absvalue / 432) / Math.log(1.25)) + 5.0;
    slidervalue = Math.floor(slidervalue + 0.1); // in case of rounding error on the logarithm
    jQuery("#slider_centernote").slider({ value: slidervalue });
    // now we loop through each part
    parts = gUmt.UIParams.parts;
    for (i = 0; i < parts; i = i + 1) {
        if (!umtUIIsPartInUI(i)) {
            umtUiAddRow(i);
        }
    }
    loopDuration = gUmt.UIParams.loopDuration;
    maxLoopDuration = gUmt.UIParams.maxLoopDuration;
    for (i = 0; i < parts; i = i + 1) {
        // checkbox
        if (gUmt.UIParams.songTab[tab].voice[i].playing) {
            document.getElementById("playvoice" + i).checked = true;
        } else {
            document.getElementById("playvoice" + i).checked = false;
        }
        // instrument
        umtUiSetListboxByValue(document.getElementById("instrument" + i), gUmt.UIParams.songTab[tab].voice[i].instrument);
        // song number
        umtUiSetListboxByValue(document.getElementById("songnumber" + i), gUmt.UIParams.songTab[tab].voice[i].songNumber);
        // volume
        absvalue = gUmt.UIParams.songTab[tab].voice[i].volume;
        window.document.getElementById("display_volume" + i).innerHTML = (absvalue * 100) + "%";
        slidervalue = absvalue * 10;
        jQuery("#slider_volume" + i).slider({ value: slidervalue });
        // octave
        absvalue = gUmt.UIParams.songTab[tab].voice[i].octave;
        window.document.getElementById("display_octave" + i).innerHTML = absvalue;
        slidervalue = absvalue;
        jQuery("#slider_octave" + i).slider({ value: slidervalue });
        // note distance
        absvalue = gUmt.UIParams.songTab[tab].voice[i].noteDistance;
        window.document.getElementById("display_notedistance" + i).innerHTML = (absvalue * 100) + "%";
        slidervalue = absvalue * 10;
        jQuery("#slider_notedistance" + i).slider({ value: slidervalue });
        // restyness
        absvalue = gUmt.UIParams.songTab[tab].voice[i].restyness;
        window.document.getElementById("display_restyness" + i).innerHTML = (absvalue * 100) + "%";
        slidervalue = absvalue * 10;
        jQuery("#slider_restyness" + i).slider({ value: slidervalue });
        // amplitude variation
        absvalue = gUmt.UIParams.songTab[tab].voice[i].ampVariation;
        window.document.getElementById("display_ampvariation" + i).innerHTML = (absvalue * 100) + "%";
        slidervalue = absvalue * 10;
        jQuery("#slider_ampvariation" + i).slider({ value: slidervalue });
        // min note
        absvalue = gUmt.UIParams.songTab[tab].voice[i].minNote;
        window.document.getElementById("display_minnote" + i).innerHTML = absvalue;
        slidervalue = Math.floor((Math.log(absvalue) / Math.log(2)) + 0.01);
        jQuery("#slider_minnote" + i).slider({ value: slidervalue });
        // chunk size
        absvalue = gUmt.UIParams.songTab[tab].voice[i].chunkSize;
        window.document.getElementById("display_chunksize" + i).innerHTML = absvalue;
        slidervalue = Math.floor((Math.log(absvalue) / Math.log(2)) + 0.01);
        jQuery("#slider_chunksize" + i).slider({ value: slidervalue });
        // frame size
        absvalue = gUmt.UIParams.songTab[tab].voice[i].frameSize;
        window.document.getElementById("display_framesize" + i).innerHTML = absvalue;
        slidervalue = Math.floor((Math.log(absvalue) / Math.log(2)) + 0.01);
        jQuery("#slider_framesize" + i).slider({ value: slidervalue });
        // symmetry patterns and parameters
        umtCreateInstrumentSpecificParameterControls(i, gUmt.UIParams.songTab[tab].voice[i].instrument);
        umtUiSetInstrumentSpecificSliders(i);
        symSize = 1;
        frameSize = gUmt.UIParams.songTab[tab].voice[i].frameSize;
        while (symSize <= maxLoopDuration) {
            if (symSize < frameSize) {
                umtUiTurnOnSymmetryPatterns(i, symSize, false);
            } else {
                if (symSize >= loopDuration) {
                    umtUiTurnOnSymmetryPatterns(i, symSize, false);
                } else {
                    umtUiTurnOnSymmetryPatterns(i, symSize, true);
                    umtUiSetSymmetryListboxAndSlider(i, symSize);
                    symmetryPattern = gUmt.UIParams.songTab[tab].voice[i].symmetry[symSize].pattern;
                    // symmetry listbox
                    umtUiSetListboxByValue(document.getElementById("sel_symmetry" + i + "_" + symSize), symmetryPattern);
                    umtUIShowOrHideAppropriateSymmetrySliders(symmetryPattern, i + "_" + symSize);
                }
            }
            symSize = symSize * 2;
        }
    }
    i = parts;
    while (umtUIIsPartInUI(i)) {
        jQuery("#voice_row_" + i).remove();
        i = i + 1;
    }
    gUmt.noReenterAddingVoice = false;
}

function umtUiDeleteVoice(voiceNum) {
    "use strict";
    var tab, vcnum;
    gUmt.UIParams.parts = gUmt.UIParams.parts - 1;
    for (tab = 0; tab < gUmt.UIParams.numTabs; tab = tab + 1) {
        for (vcnum = voiceNum; vcnum < gUmt.UIParams.parts; vcnum = vcnum + 1) {
            umtUiCopyTabVoice(tab, vcnum + 1, tab, vcnum);
        }
    }
    if (gUmt.noReenterAddingVoice === false) {
        umtAutomaticallyRecomposeLoopFromUIParams();
    }
    umtUiCopyUiParamsToActualUi();
}

umtExecDeleteVoiceClick = function () {
    "use strict";
    var elemid, UIVoiceNum;
    elemid = event.target.id;
    UIVoiceNum = Number(elemid.substring(11));
    umtUiDeleteVoice(UIVoiceNum);
};

function umtExecAddVoice() {
    "use strict";
    var tab, voiceNum, songnum, dup;
    tab = gUmt.UIParams.currentTab;
    voiceNum = gUmt.UIParams.parts;
    songnum = voiceNum + 1;
    if (voiceNum === 0) {
        gUmt.UIParams.songTab[tab].voice[voiceNum] = {
            playing: false,
            instrument: "tuningfork",
            volume: 1.0,
            songNumber: songnum,
            octave: 5,
            noteDistance: 0.3,
            restyness: 0.0,
            ampVariation: 0.5,
            minNote: 4,
            chunkSize: 4,
            frameSize: 16,
            symmetry: {
                1: {
                    pattern: "trans",
                    transParam: 0,
                    scaleParam: 0,
                    tiltParam: 0,
                    scrollrhythmParam: 0,
                    scrollpitchParam: 0,
                    scrollbothParam: 0
                },
                2: {
                    pattern: "trans",
                    transParam: 0,
                    scaleParam: 0,
                    tiltParam: 0,
                    scrollrhythmParam: 0,
                    scrollpitchParam: 0,
                    scrollbothParam: 0
                },
                4: {
                    pattern: "trans",
                    transParam: 0,
                    scaleParam: 0,
                    tiltParam: 0,
                    scrollrhythmParam: 0,
                    scrollpitchParam: 0,
                    scrollbothParam: 0
                },
                8: {
                    pattern: "trans",
                    transParam: 0,
                    scaleParam: 0,
                    tiltParam: 0,
                    scrollrhythmParam: 0,
                    scrollpitchParam: 0,
                    scrollbothParam: 0
                },
                16: {
                    pattern: "trans",
                    transParam: 0,
                    scaleParam: 0,
                    tiltParam: 0,
                    scrollrhythmParam: 0,
                    scrollpitchParam: 0,
                    scrollbothParam: 0
                },
                32: {
                    pattern: "trans",
                    transParam: 0,
                    scaleParam: 0,
                    tiltParam: 0,
                    scrollrhythmParam: 0,
                    scrollpitchParam: 0,
                    scrollbothParam: 0
                },
                64: {
                    pattern: "trans",
                    transParam: 0,
                    scaleParam: 0,
                    tiltParam: 0,
                    scrollrhythmParam: 0,
                    scrollpitchParam: 0,
                    scrollbothParam: 0
                },
                128: {
                    pattern: "trans",
                    transParam: 0,
                    scaleParam: 0,
                    tiltParam: 0,
                    scrollrhythmParam: 0,
                    scrollpitchParam: 0,
                    scrollbothParam: 0
                },
                256: {
                    pattern: "trans",
                    transParam: 0,
                    scaleParam: 0,
                    tiltParam: 0,
                    scrollrhythmParam: 0,
                    scrollpitchParam: 0,
                    scrollbothParam: 0
                },
                512: {
                    pattern: "trans",
                    transParam: 0,
                    scaleParam: 0,
                    tiltParam: 0,
                    scrollrhythmParam: 0,
                    scrollpitchParam: 0,
                    scrollbothParam: 0
                },
                1024: {
                    pattern: "trans",
                    transParam: 0,
                    scaleParam: 0,
                    tiltParam: 0,
                    scrollrhythmParam: 0,
                    scrollpitchParam: 0,
                    scrollbothParam: 0
                }
            },
            instSpecificParams: {},
            copyChangesToOtherTabs: true
        };
    } else {
        for (dup = 0; dup < gUmt.UIParams.numTabs; dup = dup + 1) {
            umtUiCopyTabVoice(tab, voiceNum - 1, dup, voiceNum);
            gUmt.UIParams.songTab[dup].voice[voiceNum].playing = false;
            gUmt.UIParams.songTab[dup].voice[voiceNum].songNumber = songnum;
            if (dup === tab) {
                gUmt.UIParams.songTab[dup].voice[voiceNum].copyChangesToOtherTabs = true;
            }
        }
    }
    umtUISetDefaultInstSpecificParamsForNewInstrument(voiceNum, gUmt.UIParams.songTab[tab].voice[voiceNum].instrument);
    gUmt.UIParams.parts = gUmt.UIParams.parts + 1;
    umtUiCopyUiParamsToActualUi();
}

function umtExecTestDumtGmt() {
    "use strict";
    // cx("gUmt = " + ctstr(gUmt));
    console.log(gUmt);
}

// have to use var syntax for this function to get the forward reference to pass jslint

umtExecReSeed = function () {
    "use strict";
    var tab, currentTime, timeInMs, rng, i;
    tab = gUmt.UIParams.currentTab;
    currentTime = new Date(); // year, month [, day, hour, minute, second, millisecond]);
    timeInMs = currentTime.getTime();
    gUmt.lastReSeedTime = timeInMs;
    timeInMs = timeInMs - (Math.floor(timeInMs / 256) * 256);
    rng = umtGetRando(timeInMs);
    for (i = 0; i < gUmt.UIParams.parts; i = i + 1) {
        gUmt.UIParams.songTab[tab].voice[i].songNumber = Math.floor(rng.genrandReal2() * 50 + 1);
    }
    umtUiCopyUiParamsToActualUi();
    if (gUmt.noReenterAddingVoice === false) {
        umtAutomaticallyRecomposeLoopFromUIParams();
    }
};

function umtUiCopyTabAll(fromTab, toTab) {
    "use strict";
    var vcnum;
    gUmt.UIParams.songTab[toTab] = {
        centernote: gUmt.UIParams.songTab[fromTab].centernote,
        chord: gUmt.UIParams.songTab[fromTab].chord,
        scale: gUmt.UIParams.songTab[fromTab].scale,
        voice: [ ]
    };
    for (vcnum = 0; vcnum < gUmt.UIParams.parts; vcnum = vcnum + 1) {
        umtUiCopyTabVoice(fromTab, vcnum, toTab, vcnum);
    }
}

function umtUiClearAllCopyFlags() {
    "use strict";
    var tab, vcnum;
    for (tab = 0; tab < gUmt.UIParams.numTabs; tab = tab + 1) {
        for (vcnum = 0; vcnum < gUmt.UIParams.parts; vcnum = vcnum + 1) {
            gUmt.UIParams.songTab[tab].voice[vcnum].copyChangesToOtherTabs = false;
        }
    }
}

function umtUiAddTab() {
    "use strict";
    umtUiClearAllCopyFlags();
    umtUiCopyTabAll(gUmt.UIParams.currentTab, gUmt.UIParams.numTabs);
    gUmt.UIParams.numTabs = gUmt.UIParams.numTabs + 1;
    if (gUmt.UIParams.playAllTabs) {
        umtComposeTab(0, gUmt.UIParams.numTabs - 1);
        umtComposeTab(1, gUmt.UIParams.numTabs - 1);
    }
}

function umtUiDeleteTab(tab) {
    "use strict";
    var i;
    gUmt.UIParams.numTabs = gUmt.UIParams.numTabs - 1;
    for (i = tab; i < gUmt.UIParams.numTabs; i = i + 1) {
        umtUiCopyTabAll(i + 1, i);
    }
}

function umtUiHiddenCopyBetweenTabs() {
    "use strict";
    var tab, vcnum, inner;
    // This function assumes there cannot be more than one "copyChangesToOtherTabs" set on any given voice for all tabs
    for (tab = 0; tab < gUmt.UIParams.numTabs; tab = tab + 1) {
        for (vcnum = 0; vcnum < gUmt.UIParams.parts; vcnum = vcnum + 1) {
            if (gUmt.UIParams.songTab[tab].voice[vcnum].copyChangesToOtherTabs) {
                for (inner = 0; inner < gUmt.UIParams.numTabs; inner = inner + 1) {
                    if (inner !== tab) {
                        umtUiCopyTabVoice(tab, vcnum, inner, vcnum);
                    }
                }
            }
        }
    }
    umtUiClearAllCopyFlags();
}

function umtExecLoopTabsOne() {
    "use strict";
    gUmt.UIParams.playAllTabs = false;
    umtAutomaticallyRecomposeLoopFromUIParams();
}

function umtExecLoopTabsAll() {
    "use strict";
    gUmt.UIParams.playAllTabs = true;
    umtAutomaticallyRecomposeLoopFromUIParams();
}

function umtUiClipChunkSizeAndFrameSizeAtLoopLength() {
    "use strict";
    var tab, numTabs, vcnum, numVoices, loopDuration;
    numTabs = gUmt.UIParams.numTabs;
    numVoices = gUmt.UIParams.parts;
    loopDuration = gUmt.UIParams.loopDuration;
    for (tab = 0; tab < numTabs; tab = tab + 1) {
        for (vcnum = 0; vcnum < numVoices; vcnum = vcnum + 1) {
            if (gUmt.UIParams.songTab[tab].voice[vcnum].minNote > loopDuration) {
                gUmt.UIParams.songTab[tab].voice[vcnum].minNote = loopDuration;
            }
            if (gUmt.UIParams.songTab[tab].voice[vcnum].chunkSize > loopDuration) {
                gUmt.UIParams.songTab[tab].voice[vcnum].chunkSize = loopDuration;
            }
            if (gUmt.UIParams.songTab[tab].voice[vcnum].frameSize > loopDuration) {
                gUmt.UIParams.songTab[tab].voice[vcnum].frameSize = loopDuration;
            }
        }
    }
}

function umtExecLoopLengthChange() {
    "use strict";
    var listbox, looplenparam;
    listbox = window.document.getElementById("lb_tab_length");
    looplenparam = Number(listbox.options[listbox.selectedIndex].value);
    gUmt.UIParams.loopDuration = looplenparam;
    if (gUmt.noReenterAddingVoice === false) {
        umtUiClipChunkSizeAndFrameSizeAtLoopLength();
        umtUiCopyUiParamsToActualUi();
        umtSetAllTabsAllLoopsToRecompose();
        umtAutomaticallyRecomposeLoopFromUIParams();
    }
}

// main

gUmt = {
    TAU: Math.PI * 2,
    LOG2: Math.log(2),
    globalCtx: umtGetAudioContext(),
    globalRng: umtGetRando(0),
    cachedNotes: {},
    cachedWads: {},
    instrumentBank: {},
    cachedFittings: {},
    loop: [],
    playedUpTo: 0,
    timerIsOn: false,
    currentlyPlayingLoop: 0,
    compositionLag: 0,
    noReenterCompose: false,
    noReenterAddingVoice: false,
    UIParams: {
        tempo: 360,
        mastervol: 0.9,
        songTab: [
            {
                scale: 'maj7reg',
                chord: "triad",
                centernote: 432,
                voice: []
            }
        ],
        loopDuration: 128,
        maxLoopDuration: 1024,
        parts: 0,
        currentTab: 0,
        numTabs: 1,
        playAllTabs: false
    },
    tabRecomposeFlags: []
};

// console.log(gUmt);

jQuery(function () {
    "use strict";
    var tabContent, tabTemplate, tabCounter, tabs, dialog, form;
    jQuery("#slider_tempo").slider({min: 60, max: 960, step: 30, value: 360, orientation: "horizontal", change: function (event, ui) {
        var newvalue;
        if (gUmt.noReenterAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                window.document.getElementById("display_tempo_value").innerHTML = newvalue;
                gUmt.UIParams.tempo = newvalue;
                umtSetAllTabsAllLoopsToRecompose();
                umtAutomaticallyRecomposeLoopFromUIParams();
            }
        }
    }
         });
    jQuery("#slider_centernote").slider({min: 1, max: 9, step: 1, value: 5, orientation: "horizontal", change: function (event, ui) {
        var tab, newvalue;
        tab = gUmt.UIParams.currentTab;
        if (gUmt.noReenterAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                newvalue = Math.pow((4 / 3), newvalue - 5) * 432;
                window.document.getElementById("display_centernote_value").innerHTML = newvalue;
                gUmt.UIParams.songTab[tab].centernote = newvalue;
                umtAutomaticallyRecomposeLoopFromUIParams();
            }
        }
    }
         });
    jQuery("#slider_mastervol").slider({min: 0, max: 100, step: 10, value: 90, orientation: "horizontal", change: function (event, ui) {
        var newvalue;
        if (gUmt.noReenterAddingVoice === false) {
            if (event.type === "slidechange") {
                newvalue = ui.value;
                window.document.getElementById("display_mastervol_value").innerHTML = newvalue;
                gUmt.UIParams.mastervol = newvalue / 100.0;
                umtSetAllTabsAllLoopsToRecompose();
                umtAutomaticallyRecomposeLoopFromUIParams();
            }
        }
    }
         });

    // tabs
    // actual addTab function: adds new tab using the input from the form above
    function addTab() {
        // var label, id, li, tabContentHtml;
        // label = tabTitle.val() || "Tab " + tabCounter;
        var label, id, li, tabContentHtml, nextTabNum, nextTabStr, i, c;
        nextTabNum = tabCounter - 1; // gUmt.UIParams.numTabs;
        nextTabStr = nextTabNum.toString(26);
        label = "";
        for (i = 0; i < nextTabStr.length; i = i + 1) {
            c = nextTabStr.charCodeAt(i);
            if (c > 57) {
                label = label + String.fromCharCode(c - 22);
            } else {
                label = label + String.fromCharCode(c + 17);
            }
        }
        id = "tabs-" + tabCounter;
        li = jQuery(tabTemplate.replace(/#\{href\}/g, "#" + id).replace(/#\{label\}/g, label));
        tabContentHtml = tabContent.val() || "Tab " + tabCounter + " content.";
        tabContentHtml = "";

        tabs.find(".ui-tabs-nav").append(li);
        tabs.append("<div id='" + id + "'><p>" + tabContentHtml + "</p></div>");
        tabs.tabs("refresh");
        tabCounter = tabCounter + 1;
        umtUiAddTab();
    }

    // tabTitle = jQuery("#tab_title");
    tabContent = jQuery("#tab_content");
    tabTemplate = "<li><a href='#{href}'>#{label}</a> <span class='ui-icon ui-icon-close' role='presentation'>Remove Tab</span></li>";
    tabCounter = 2;

    tabs = jQuery("#tabs").tabs({
        activate: function (event, ui) {
            var active;
            console.log(event);
            console.log(ui);
            active = jQuery("#tabs").tabs("option", "active");
            // window.alert(active);
            gUmt.UIParams.currentTab = active;
            umtUiHiddenCopyBetweenTabs();
            umtUiCopyUiParamsToActualUi();
            if (!gUmt.UIParams.playAllTabs) {
                umtAutomaticallyRecomposeLoopFromUIParams();
            }
        }
    });

    // modal dialog init: custom buttons and a "close" callback resetting the form inside
    dialog = jQuery("#dialog").dialog({
        autoOpen: false,
        modal: true,
        buttons: {
            Add: function () {
                addTab();
                jQuery(this).dialog("close");
            },
            Cancel: function () {
                jQuery(this).dialog("close");
            }
        },
        close: function () {
            form[0].reset();
        }
    });

    // addTab form: calls addTab function on submit and closes the dialog
    form = dialog.find("form").submit(function (event) {
        addTab();
        dialog.dialog("close");
        event.preventDefault();
    });

    // addTab button: just opens the dialog
    jQuery("#add_tab")
        .button()
        .click(function () {
            // dialog.dialog("open");
            addTab();
        });

    // close icon: removing the tab on click
    tabs.delegate("span.ui-icon-close", "click", function () {
        var panelId, kids, count, tabNumber;
        panelId = jQuery(this).closest("li").remove().attr("aria-controls");
        count = 0;
        tabNumber = -1;
        kids = tabs.children();
        kids.each(function (index) {
            // console.log(index + ": " + jQuery(this).id);
            console.log(index + ": " + this.id);
            if (this.id === panelId) {
                // window.alert("found!!");
                tabNumber = count;
            }
            if (this.id.substring(0, 5) === "tabs-") {
                count = count + 1;
            }
        });
        // window.alert("Tab removed: " + ctstr(tabNumber));
        umtUiDeleteTab(tabNumber);
        umtAutomaticallyRecomposeLoopFromUIParams();
        jQuery("#" + panelId).remove();
        tabs.tabs("refresh");
    });

    tabs.bind("keyup", function (event) {
        if (event.altKey && event.keyCode === jQuery.ui.keyCode.BACKSPACE) {
            var panelId = tabs.find(".ui-tabs-active").remove().attr("aria-controls");
            jQuery("#" + panelId).remove();
            tabs.tabs("refresh");
        }
    });

    // start song
    umtCreateInstrumentBank();
    umtExecAddVoice();
    document.getElementById("playvoice0").checked = true;
    gUmt.UIParams.songTab[0].voice[0].playing = true;
    // umtExecAutomaticStart();
});

</script>

</head>
<body>
<div id="dialog" title="Tab data">
	<form>
		<fieldset class="ui-helper-reset">
			<label for="tab_title">Title</label>
			<input type="text" name="tab_title" id="tab_title" value="Tab Title" class="ui-widget-content ui-corner-all">
			<label for="tab_content">Content</label>
			<textarea name="tab_content" id="tab_content" class="ui-widget-content ui-corner-all">Tab content</textarea>
		</fieldset>
	</form>
</div>

  <section>
    <h1>UMT: The Ultimate Music Toy</h1>

<p>
    <input type="button" id="start_automatic" value="Start Music" />
    <input type="button" id="stop_automatic" value="Stop Music" />
    <!-- input type="button" id="test_play_raw" value="Test Play Raw" / -->
    <!--input type="button" id="test_dump_gumt" value="Test Dump gUmt" / -->
    <!-- input type="button" id="test_symmetry_system" value="Test Symmetry System" / -->
    Composition time (RA) <input type="text" id="test_composition_time" value="0" />
</p>

<hr />

<p> Stuff that applies to whole score </p>

<p> Tempo:

<div id="slider_tempo" class="ddrg" style="width:200px;"></div>

<div id="display_tempo_value">360</div>

</p>

<p> Master volume control:

<div id="slider_mastervol" class="ddrg" style="width:200px;"></div>

<div id="display_mastervol_value">90</div>

</p>

<p> <input type="radio" name="loop_tabs" value="one" id="loop_tabs_one" checked="checked" /> Play selected tab <input type="radio" name="loop_tabs" value="all" id="loop_tabs_all" /> Play all tabs </p>

<button id="add_tab">Add Tab</button>

Tab length: <select id="lb_tab_length">
    <option value="1">1</option>
    <option value="2">2</option>
    <option value="4">4</option>
    <option value="8">8</option>
    <option value="16">16</option>
    <option value="32">32</option>
    <option value="64">64</option>
    <option value="128">128</option>
    <option value="256">256</option>
    <option value="512">512</option>
    <option value="1024">1024</option>
</select>

<div id="tabs">
	<ul>
		<li><a href="#tabs-1">A</a> <span class="ui-icon ui-icon-close" role="presentation">Remove Tab</span></li>
	</ul>


<p> Scale:

<select id="lb_scale">
    <option value="chroma15tt">Chromatic 15 (alt)*</option>
    <option value="chroma13">Chromatic 13 (alt)</option>
    <option value="chroma12regregtt">Chromatic 12*</option>
    <option value="chroma11regreg">Chromatic 11</option>
    <option value="hungarian7tt">Hungarian Minor 7*</option>
    <option value="arabic7">Arabic 7</option>
    <option value="freygish7">Freygish Phrygian Dominant 7</option>
    <option value="ukranian7">Ukranian Dorian 7</option>
    <option value="minharm7reg">Minor Harmonic 7</option>
    <option value="minnat7regreg">Minor Natural 7</option>
    <option value="maj7reg" selected="selected">Major/Ionian Mode 7</option>
    <!-- option value="ionian7" Ionian Mode 7 /option -->
    <option value="dorian7">Dorian Mode 7</option>
    <option value="phrygian7">Phrygian Mode 7</option>
    <option value="lydian7tt">Lydian Mode 7*</option>
    <option value="mixolydian7">Mixolydian Mode 7</option>
    <option value="aeolian7">Aeolian Mode 7</option>
    <option value="locrian7tt">Locrian Mode 7*</option>
    <option value="pentatonic23reg">Pentatonic 5 (2+3 standard)</option>
    <option value="pentatonic131reg">Pentatonic 5 (1+3+1)</option>
    <option value="pentatonic32reg">Pentatonic 5 (3+2)</option>
    <option value="pentatonic221reg">Pentatonic 5 (2+2+1)</option>
    <option value="pentatonic122reg">Pentatonic 5 (1+2+2)</option>
    <option value="quad">Quadtonic 4</option>
    <option value="tri">Tritonic 3</option>
    <option value="tritone2test">Tritone Test 2*</option>
</select>

* = contains tritone

</p>

<p> Chords allowed:

<select id="lb_chord">
    <option value="perfect">Perfect</option>
    <option value="major">Major</option>
    <option value="triad" selected="selected">Triads</option>
    <option value="reg">7th chords</option>
    <!-- option value="alt" Allow 7th chords (alt) /option -->
    <!-- option value="any" Allow all chords (allow dissonance) /option -->
</select>

</p>

<p> Center note (tonic/key):

<div id="slider_centernote" class="ddrg" style="width:200px;"></div>

<div id="display_centernote_value">432</div>

</p>

<p>

<input type="button" id="reseed" value="Re-randomize" />

<input type="checkbox" id="continuous" /> Continuous

</p>

<hr />

<div id="voice_template" style="display:none;" >
	<p><b>This is the template row</b></p>
	<table border="0">
		<tr>
			<td id="voicedescriptcellxx" valign="top">
				Voice #XX
			</td><td id="voiceplaycellxx" valign="top">
				Play
				<br />
				<input type="checkbox" name="playvoicexx" id="playvoicexx">
			</td><td id="voicevolumecellxx" valign="top" align="center">
				Volume: <br />
				<div id="slider_volumexx" class="ddrg" style="height:100px;"></div> <br />
				<div id="display_volumexx"></div>
			</td><td id="voiceinstrumentcellxx" valign="top" align="center">
				Instrument: <br />
				<select name="instrumentxx" id="instrumentxx">
					<option value="tuningfork">Sine wave</option>
					<!-- option value="squarewave" Square /option -->
					<option value="squarevar">Square wave</option>
					<!-- option value="trianglewave" Triangle /option -->
					<option value="squarerisingpitch">Square w/rising pitch</option>
					<option value="squarestartstop">Square Start/Stop</option>
					<option value="trianglevar">Triangle wave</option>
					<!-- option value="sawtoothwave" Sawtooth /option -->
					<option value="sawtoothvar">Sawtooth wave</option>
					<!-- option value="forwardsnoise" Noise /option -->
					<!-- option value="backwardsnoise" Backwards noise /option -->
					<option value="steampop">Slapping pencil</option>
					<!-- option value="fmsynthoriginal" FM Synthesis /option -->
					<option value="fmsynthvar">FM Synthesis</option>
					<option value="fmsynthstartstop">FM Synthesis/Start/Stop</option>
					<option value="fmsynthsquare">FM Synthesis Square</option>
					<!-- option value="wadsin" WAD Sine /option -->
					<!-- option value="wadkick" WAD Kick /option -->
					<option value="wadbass">WAD Bass</option>
					<option value="wadsnare">WAD Snare</option>
					<option value="wadhihatopen">WAD Hihat Open</option>
					<option value="wadhihatclosed">WAD Hihat Closed</option>
					<option value="wadflute">WAD Flute</option>
					<option value="wadpiano">WAD Piano</option>
				</select>
			</td><td id="voicesongnumcellxx" valign="top" align="center">
				Seed: <br />
				<select name="songnumberxx" id="songnumberxx">
					<option value="1">1</option>
					<option value="2">2</option>
					<option value="3">3</option>
					<option value="4">4</option>
					<option value="5">5</option>
					<option value="6">6</option>
					<option value="7">7</option>
					<option value="8">8</option>
					<option value="9">9</option>
					<option value="10">10</option>
					<option value="11">11</option>
					<option value="12">12</option>
					<option value="13">13</option>
					<option value="14">14</option>
					<option value="15">15</option>
					<option value="16">16</option>
					<option value="17">17</option>
					<option value="18">18</option>
					<option value="19">19</option>
					<option value="20">20</option>
					<option value="21">21</option>
					<option value="22">22</option>
					<option value="23">23</option>
					<option value="24">24</option>
					<option value="25">25</option>
					<option value="26">26</option>
					<option value="27">27</option>
					<option value="28">28</option>
					<option value="29">29</option>
					<option value="30">30</option>
					<option value="31">31</option>
					<option value="32">32</option>
					<option value="33">33</option>
					<option value="34">34</option>
					<option value="35">35</option>
					<option value="36">36</option>
					<option value="37">37</option>
					<option value="38">38</option>
					<option value="39">39</option>
					<option value="40">40</option>
					<option value="41">41</option>
					<option value="42">42</option>
					<option value="43">43</option>
					<option value="44">44</option>
					<option value="45">45</option>
					<option value="46">46</option>
					<option value="47">47</option>
					<option value="48">48</option>
					<option value="49">49</option>
					<option value="50">50</option>
				</select>
			</td><td id="voiceoctavecellxx" valign="top" align="center">
				Octave: <br />
				<div id="slider_octavexx" class="ddrg" style="height:100px;"></div> <br />
				<div id="display_octavexx"></div>
			</td><td id="voicenotedistcellxx" valign="top" align="center">
				Note Distance:<br />
				<div id="slider_notedistancexx" class="ddrg" style="height:100px;"></div> <br />
				<div id="display_notedistancexx"></div>
			</td><td id="voicerestynesscellxx" valign="top" align="center">
				Restyness:<br />
				<div id="slider_restynessxx" class="ddrg" style="height:100px;"></div> <br />
				<div id="display_restynessxx"></div>
			</td><td id="voiceampvariationcellxx" valign="top" align="center">
				Ampl. Var.:<br />
				<div id="slider_ampvariationxx" class="ddrg" style="height:100px;"></div> <br />
				<div id="display_ampvariationxx"></div>
			</td><td id="voiceminnotecellxx" valign="top" align="center">
				Min Note:<br />
				<div id="slider_minnotexx" class="ddrg" style="height:100px;"></div> <br />
				<div id="display_minnotexx"></div>
			</td><td id="voicechunksizecellxx" valign="top" align="center">
				Max Note:<br />
				<div id="slider_chunksizexx" class="ddrg" style="height:100px;"></div> <br />
				<div id="display_chunksizexx"></div>
			</td><td id="voiceframesizecellxx" valign="top" align="center">
				Frame Size:<br />
				<div id="slider_framesizexx" class="ddrg" style="height:100px;"></div> <br />
				<div id="display_framesizexx"></div>
			</td><td id="voicesymmetriescellxx" valign="top" align="center">
				Symmetry Patterns: <br />
				<table border="0">
					<tr>
						<td valign="center" align="right">
							<span id="display_symmetrylevelxx_yyy" style="display:none;">1</span>
						</td><td valign="top">
							<select name="sel_symmetryxx_yyy" id="sel_symmetryxx_yyy" style="display:none;">
								<option value="trans">Transpose</option>
								<option value="invert">Invert</option>
								<option value="scale">Scale</option>
								<option value="tilt">Tilt</option>
								<option value="reverseboth">Reverse</option>
								<option value="reverserhythm">Reverse-rhythm</option>
								<option value="reversepitch">Reverse-pitch</option>
								<option value="scrollboth">Scroll</option>
								<option value="scrollrhythm">Scroll-rhythm</option>
								<option value="scrollpitch">Scroll-pitch</option>
							</select>
						</td><td valign="top" align="center">
							<div id="slider_symmetry_transParamxx_yyy" class="ddrg" style="width:100px;display:none;"></div>
							<span id="display_symmetry_transParamxx_yyy" style="display:none;">readout</span>
							<div id="slider_symmetry_scaleParamxx_yyy" class="ddrg" style="width:100px;display:none;"></div>
							<span id="display_symmetry_scaleParamxx_yyy" style="display:none;">readout</span>
							<div id="slider_symmetry_tiltParamxx_yyy" class="ddrg" style="width:100px;display:none;"></div>
							<span id="display_symmetry_tiltParamxx_yyy" style="display:none;">readout</span>
							<div id="slider_symmetry_scrollrhythmParamxx_yyy" class="ddrg" style="width:100px;display:none;"></div>
							<span id="display_symmetry_scrollrhythmParamxx_yyy" style="display:none;">readout</span>
							<div id="slider_symmetry_scrollpitchParamxx_yyy" class="ddrg" style="width:100px;display:none;"></div>
							<span id="display_symmetry_scrollpitchParamxx_yyy" style="display:none;">readout</span>
							<div id="slider_symmetry_scrollbothParamxx_yyy" class="ddrg" style="width:100px;display:none;"></div>
							<span id="display_symmetry_scrollbothParamxx_yyy" style="display:none;">readout</span>
						</td>
					</tr>
					<!-- insertion_point -->
				</table>
			</td><td id="instparameterscellxx" valign="top" align="center">
				<!-- inst_specific_param_ins_point -->
			</td>
			<td id="voicedeletecellxx" valign="top" align="center">
				<input type="button" name="deletevoicexx" id="deletevoicexx" value="X">
			</td>
		</tr>
	</table>
</div>

<div id="instrument_parameter_template" style="display:none;" >
	<table border="0"><tr>
		<td>
			<div id="slider_instr_ZZ_YY_XX_patterns" class="ddrg" style="height:100px;"></div> <br />
			<div id="display_instr_ZZ_YY_XX_patterns"></div><br />
		</td>
	</table>
</div>

<div id="voices_section">
	<table id="voices_table" border="0">
		<tbody>
		</tbody>
	</table>
</div>

<input id="add_voice" type="button" value="Add a voice" />

	<div id="tabs-1"></div>
</div>

  </section>
<script>

var umtListenElement = document.getElementById("start_automatic");
umtListenElement.addEventListener("click", umtExecAutomaticStart, true);

umtListenElement = document.getElementById("stop_automatic");
umtListenElement.addEventListener("click", umtExecAutomaticStop, true);

umtListenElement = document.getElementById("lb_scale");
umtListenElement.addEventListener("change", umtExecScaleChange, true);

umtListenElement = document.getElementById("lb_chord");
umtListenElement.addEventListener("change", umtExecChordChange, true);

var umtListenElement = document.getElementById("reseed");
umtListenElement.addEventListener("click", umtExecReSeed, true);

umtListenElement = document.getElementById("add_voice");
umtListenElement.addEventListener("click", umtExecAddVoice, true);

umtListenElement = document.getElementById("loop_tabs_one");
umtListenElement.addEventListener("click", umtExecLoopTabsOne, true);

umtListenElement = document.getElementById("loop_tabs_all");
umtListenElement.addEventListener("click", umtExecLoopTabsAll, true);

umtListenElement = document.getElementById("lb_tab_length");
umtListenElement.addEventListener("change", umtExecLoopLengthChange, true);

// umtListenElement = document.getElementById("test_play_raw");
// umtListenElement.addEventListener("click", umtExecPlayRawScore, true);

// umtListenElement = document.getElementById("test_dump_gumt");
// umtListenElement.addEventListener("click", umtExecTestDumtGmt, true);

// umtListenElement = document.getElementById("test_symmetry_system");
// umtListenElement.addEventListener("click", umtTestSetupCopyTransTestSection, true);

</script>

</body>
</html>
